<html>
<head><title>ABINIT : BASIC input variables.</title>
<link rel=stylesheet type="text/css" href="formabinit.css">
</head>
<body bgcolor="#ffffff">

<hr>
<a name="top"></a>

<h1>ABINIT, basic input variables:</h1>
<h2>List and description.</h2>

<hr>

<p>This document lists and provides the description
of the name (keywords) of the "basic" input
variables to be used in the main input file of the abinis code.

<p>The new user is advised to read first the
  <a href="new_user_guide.html">new user's guide</a>,
  before reading the present file. It will be easier to discover the
  present file with the help of the <a href="Tutorial/welcome.html">tutorial</a>.

<p>When the user is sufficiently familiarized with ABINIT, the reading of the
  ~ABINIT/Infos/tuning file might be useful. For response-function calculations using
  abinis, the complementary file ~ABINIT/Infos/respfn_help is needed.

<h5>Copyright (C) 1998-2008 ABINIT group (DCA, XG, RC)
<br> This file is distributed under the terms of the GNU General Public License, see
~ABINIT/Infos/copyright or <a href="http://www.gnu.org/copyleft/gpl.txt">
http://www.gnu.org/copyleft/gpl.txt </a>.
<br> For the initials of contributors, see ~ABINIT/Infos/contributors .
</h5>

<HR ALIGN=left>
Goto :
<A href="http://www.abinit.org"><B>ABINIT home Page</B></A>
<B> | </B>
<A href="../users/acknowledgments.html"><B>Suggested acknowledgments</B></A>
<B> | </B>
<A href="keyhr.html"><B>List of input variables</B></A>
<B> | </B>
<A href="../tutorial/welcome.html"><B>Tutorial home page</B></A>
<B> | </B>
<A href="../users/bibliography.html"><B>Bibliography</B></A>
<HR ALIGN=left>
Help files :
<A href="../users/new_user_guide.html"><B>New user's guide</B></A>
<B> | </B>
<A href="../users/abinis_help.html"><B>Abinis (main)</B></A>
<B> | </B>
<A href="../users/respfn_help.html"><B>Abinis (respfn)</B></A>
<B> | </B>
<A href="../users/mrgddb_help.html"><B>Mrgddb</B></A>
<B> | </B>
<A href="../users/anaddb_help.html"><B>Anaddb</B></A>
<B> | </B>
<A href="../users/aim_help.html"><B>AIM (Bader)</B></A>
<B> | </B>
<A href="../users/cut3d_help.html"><B>Cut3D</B></A>
<B> | </B>
<A href="../users/optic_help.html"><B>Optic</B></A>
<B> | </B>
<A href="../users/mrgscr_help.html"><B>Mrgscr</B></A>
<HR ALIGN=left>

Files that describe other input variables:<br>
<ul>
<li> Developer variables, <A HREF="vardev.html">VARDEV</a></li>
<li> File handling variables, <A HREF="varfil.html">VARFIL</a></li>
<li> Geometry builder + symmetry related variables, <A HREF="vargeo.html">VARGEO</a></li>
<li> Ground-state calculation variables, <A HREF="vargs.html">VARGS</a></li>
<li> GW variables, <A HREF="vargw.html">VARGW</a></li>
<li> Internal variables, <A HREF="varint.html">VARINT</a></li>
<li> Parallelisation variables, <A HREF="varpar.html">VARPAR</a></li>
<li> Projector-Augmented Wave variables, <A HREF="varpaw.html">VARPAW</a></li>
<li> Response Function variables, <A HREF="varrf.html">VARRF</a></li>
<li> Structural optimization variables, <A HREF="varrlx.html">VARRLX</a></li>
<li> Wannier90 interface variables, <A href="varw90.html">VARW90</a></li>
</ul>
<hr>

<h3><b> Content of the file : alphabetical list of "basic" variables.</b></h3>
 <br>A.
 <a href="varbas.html#acell">acell</a>&nbsp;&nbsp;
 <a href="varbas.html#angdeg">angdeg</a>&nbsp;&nbsp;
 <br>B.
 <br>C.
 <br>D.
 <br>E.
 <a href="varbas.html#ecut">ecut</a>&nbsp;&nbsp;
 <br>F.
 <br>G.
 <br>H.
 <br>I.
 <a href="varbas.html#iscf">iscf</a>&nbsp;&nbsp;
 <a href="varbas.html#ixc">ixc</a>&nbsp;&nbsp;
 <br>J.
 <a href="varbas.html#jdtset">jdtset</a>&nbsp;&nbsp;
 <br>K.
 <a href="varbas.html#kpt">kpt</a>&nbsp;&nbsp;
 <a href="varbas.html#kptnrm">kptnrm</a>&nbsp;&nbsp;
 <a href="varbas.html#kptopt">kptopt</a>&nbsp;&nbsp;
 <br>L.
 <br>M.
 <br>N.
 <a href="varbas.html#natom">natom</a>&nbsp;&nbsp;
 <a href="varbas.html#nband">nband</a>&nbsp;&nbsp;
 <a href="varbas.html#ndtset">ndtset</a>&nbsp;&nbsp;
 <a href="varbas.html#ngkpt">ngkpt</a>&nbsp;&nbsp;
 <a href="varbas.html#nkpt">nkpt</a>&nbsp;&nbsp;
 <a href="varbas.html#nshiftk">nshiftk</a>&nbsp;&nbsp;
 <a href="varbas.html#nsppol">nsppol</a>&nbsp;&nbsp;
 <a href="varbas.html#nstep">nstep</a>&nbsp;&nbsp;
 <a href="varbas.html#nsym">nsym</a>&nbsp;&nbsp;
 <a href="varbas.html#ntypat">ntypat</a>&nbsp;&nbsp;
 <br>O.
 <a href="varbas.html#occopt">occopt</a>&nbsp;&nbsp;
 <br>P.
 <br>Q.
 <br>R.
 <a href="varbas.html#rprim">rprim</a>&nbsp;&nbsp;
 <br>S.
 <a href="varbas.html#shiftk">shiftk</a>&nbsp;&nbsp;
 <a href="varbas.html#symrel">symrel</a>&nbsp;&nbsp;
 <br>T.
 <a href="varbas.html#tnons">tnons</a>&nbsp;&nbsp;
 <a href="varbas.html#toldfe">toldfe</a>&nbsp;&nbsp;
 <a href="varbas.html#toldff">toldff</a>&nbsp;&nbsp;
 <a href="varbas.html#tolrff">tolrff</a>&nbsp;&nbsp;
 <a href="varbas.html#tolvrs">tolvrs</a>&nbsp;&nbsp;
 <a href="varbas.html#tolwfr">tolwfr</a>&nbsp;&nbsp;
 <a href="varbas.html#typat">typat</a>&nbsp;&nbsp;
 <br>U.
 <a href="varbas.html#udtset">udtset</a>&nbsp;&nbsp;
 <a href="varbas.html#udtset">usewvl</a>&nbsp;&nbsp;
 <br>V.
 <br>W.
 <a href="varbas.html#wtk">wtk</a>&nbsp;&nbsp;
 <a href="varbas.html#wvl_hgrid">wvl_hgrid</a>&nbsp;&nbsp;
 <br>X.
 <a href="varbas.html#xangst">xangst</a>&nbsp;&nbsp;
 <a href="varbas.html#xcart">xcart</a>&nbsp;&nbsp;
 <a href="varbas.html#xred">xred</a>&nbsp;&nbsp;
 <br>Y.
 <br>Z.
 <a href="varbas.html#znucl">znucl</a>&nbsp;&nbsp;

<br><br><br><br><hr>
<font id="title"><a name="acell">acell</a></font>
<br><font id="definition">Mnemonics: scAle CELL</font>
<br><font id="category">Characteristic: EVOLVING, LENGTH  </font>
<br><font id="vartype">Variable type: real array acell(3)   </font>
<br><br><font id="text">Gives the length scales by which
dimensionless primitive translations (in "<a href="varbas.html#rprim">rprim</a>") are
to be multiplied.  By default, given in Bohr atomic units
(1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
if preferred, since <b>acell</b> has the
'<a href="../users/abinis_help.html#dimensions">LENGTH</a>' characteristics.
See further description of <b>acell</b> related to the
<a href="varbas.html#rprim">rprim</a> input variable.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="angdeg">angdeg</a></font>
<br><font id="definition">Mnemonics: ANGles in DEGrees  </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real array angdeg(3) </font>
<br><font id="default">Default is No Default (use <a href="varbas.html#rprim">rprim</a> as Default).</font>
<br><br><font id="text">Gives the angles between directions of
primitive vectors of the unit cell (in degrees),
as an alternative to the input array <a href="varbas.html#rprim">rprim</a> .
Will be used to set up <a href="varbas.html#rprim">rprim</a>,
that, together with the array <a href="varbas.html#acell">acell</a>, will be used to define the
primitive vectors.
<ul>
<li><b>angdeg</b>(1) is the angle between the 2nd and 3rd vectors,</li>
<li><b>angdeg</b>(2) is the angle between the 1st and 3rd vectors,</li>
<li><b>angdeg</b>(3) is the angle between the 1st and 2nd vectors,</li>
</ul>
If the three angles are equal within 1.0d-12 (except if they are exactly 90 degrees),
the three primitive
vectors are chosen so that the trigonal symmetry that exchange
them is along the z cartesian axis :
<pre>
R1=( a  ,           0,c)
R2=(-a/2, sqrt(3)/2*a,c)
R3=(-a/2,-sqrt(3)/2*a,c)
</pre>
where a<sup>2</sup>+c<sup>2</sup>=1.0d0
<br>
If the angles are not all equal (or if they are all 90 degrees), one will have the following
generic form :
<ul>
<li>R1=(1,0,0)</li>
<li>R2=(a,b,0)</li>
<li>R3=(c,d,e)</li>
</ul>
where each of the vectors is normalized,
and form the desired angles with the others.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ecut">ecut</a></font>
<br><font id="definition">Mnemonics: Energy CUToff </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><br><font id="text">Used for kinetic energy cutoff
which controls number
of planewaves at given k point by:
<br>(1/2)[(2 Pi)*(k+Gmax)]<sup>2</sup>=<b>ecut</b> for Gmax.
<br>All planewaves inside this "basis sphere" centered
at k are included in the basis (except if <a href="varrlx.html#dilatmx">dilatmx</a>
is defined).
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>ecut</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
(1 Ha=27.2113845 eV)
<br>This is the single parameter which can have an enormous
effect on the quality of a calculation; basically the larger
<b>ecut</b> is, the better converged the calculation is.  For fixed
geometry, the total energy MUST always decrease as <b>ecut</b> is
raised because of the variational nature of the problem.
<p>
<i>Usually one runs at least several calculations at various <b>ecut</b>
to investigate the convergence needed for reliable results.</i>
<p>
For k-points whose coordinates are build from 0 or 1/2,
the implementation of time-reversal symmetry that links
coefficients of the wavefunctions in reciprocal space
has been realized. See the input variable <a href="vardev.html#istwfk">istwfk</a>.
If activated (which corresponds to the Default mode),
this input variable <a href="vardev.html#istwfk">istwfk</a> will allow to
divide the number of plane wave (npw) treated explicitly
by a factor of two. Still, the final result should be identical with
the 'full' set of plane waves.
<p>See the input variable <a href="varrlx.html#ecutsm">ecutsm</a>, for the
smoothing of the kinetic energy, needed to optimize unit cell parameters.
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="iscf">iscf</a></font>
<br><font id="definition">Mnemonics: Integer for Self-Consistent-Field cycles </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 7 (norm-conserving) or 17 (PAW). (prior to v5.3 : 5 and 14) </font>
<br><br><font id="text">Controls the self-consistency.
<br>Positive, non-zero values =>
this is the usual choice for doing the usual ground state (GS)
calculations or for structural relaxation, where
the potential has to be determined self-consistently.
The choice between different algorithms for SCF is possible :
<ul>
<li>=1 => get the largest eigenvalue of the SCF cycle
        <br>(DEVELOP option, used with
        <a href="varfil.html#irdwfk">irdwfk</a>=1 or
        <a href="varfil.html#irdwfk">irdwfq</a>=1)</li>
<li>=2 => SCF cycle, simple mixing of the potential</li>
<li>=3 => SCF cycle, Anderson mixing of the potential</li>
<li>=4 => SCF cycle, Anderson mixing of the potential based on the two previous iterations</li>
<li>=5 => SCF cycle, CG based on the minim. of the energy with respect to the potential</li>
<li>=7 => SCF cycle, Pulay mixing of the potential based on the <a href="vardev.html#npulayit">npulayit</a> previous iterations</li>
<li>=12 => SCF cycle, simple mixing of the density</li>
<li>=13 => SCF cycle, Anderson mixing of the density</li>
<li>=14 => SCF cycle, Anderson mixing of the density based on the two previous iterations</li>
<li>=15 => SCF cycle, CG based on the minim. of the energy with respect to the density</li>
<li>=17 => SCF cycle, Pulay mixing of the density based on the <a href="vardev.html#npulayit">npulayit</a> previous iterations</li>
<li>Other positive values, including zero ones, are not allowed. </li>
</ul>
<p>
Such algorithms for treating the "SCF iteration history" should be coupled with accompanying algorithms
for the SCF "preconditioning". See the input variable <a href="vargs.html#iprcel">iprcel</a>.
The default value <a href="vargs.html#iprcel">iprcel</a>=0 is often a good choice, but
for inhomogeneous systems, you might gain a lot with <a href="vargs.html#iprcel">iprcel</a>=45.
<p>
(Warning : if <b>iscf</b>&gt;10, at present (v4.6), the energy printed at each SCF cycle is not variational -
 this should not affect the other properties, and at convergence, all values are OK)
<p>
- In the norm-conserving case,
the default option is <b>iscf</b>=7, which is a compromise between speed and reliability.
The value <b>iscf</b>= 2 is safer but slower.
<br>
- In the PAW case, default option is <b>iscf</b>=17.
 In PAW you have the possibility to mix density/potential on the fine or coarse FFT grid (see <a href="varpaw.html#pawmixdg">pawmixdg</a>).
<br>- Note that a Pulay mixing (<b>iscf</b>=7 or 17) with <a href="vardev.html#npulayit">npulayit</a>
=1 (resp. 2) is equivalent to an Anderson mixing with <b>iscf</b>=3 or 13 (resp. 4 or 14).
<br>- Also note that: <br>* when mixing is done on potential (iscf</b><10), total energy is computed by "direct" decomposition.
 <br>* when mixing is done on density (iscf</b>>=10), total energy is computed by "double counting" decomposition.
 <br>"Direct" and "double counting" decomposition of energy are equal when SCF cycle is converged. Note that,
  when using GGA XC functionals, these decompositions of energy can be slighty different due
  to imprecise computation of density gradients on FFT grid (difference decreases as size of FFT grid increases -
   see <a href="varbas.html#ecut">ecut</a> for NC pseudopotentials, <a href="varpaw.html#pawecutdg">pawecutdg</a> for PAW).
<br>
<br>Other (negative) options:
<ul>
<li>= -2 =>
a non-self-consistent calculation is to be done;
in this case an electron density rho(r) on a real space grid
(produced in a previous calculation) will be read from a
disk file (automatically if <a href="varbas.html#ndtset">ndtset</a>=0, or
according to the value of <a href="varfil.html#getden">getden</a>
if <a href="varbas.html#ndtset">ndtset</a>/=0).
<br>The name of the density file must be given as indicated
in the <a href="../users/abinis_help.html#4">section 4</a> of abinis_help.
<b>iscf</b>=-2 would be used for
band structure calculations, to permit computation of
the eigenvalues of occupied and unoccupied states at
arbitrary k points in the fixed self consistent potential
produced by some integration grid of k points.
Due to this typical use, ABINIT insist that either
<a href="varfil.html#prtvol">prtvol</a>&gt;2 or
<a href="varfil.html#prteig">prteig</a> does not vanish
when there are more than 50 k points.
<br>To compute the eigenvalues
(and wavefunctions) of unoccupied states in a separate
(non-selfconsistent) run, the user should
save the self-consistent rho(r)
and then run <b>iscf</b>=-2 for the intended set of k-points and bands.
<br>To prepare a run with <b>iscf</b>=-2, a density file
can be produced using the
parameter <a href="varfil.html#prtden">prtden</a> (see its description).
When a self-consistent set of wavefunctions is already available,
abinit can be used with
<a href="varbas.html#nstep">nstep</a>=0 (see Test_v2/t47.in),
and the adequate value of <a href="varfil.html#prtden">prtden</a>.
</li>
<li>= -3 =>
like -2, but initialize <a href="vargs.html#occ">occ</a> and <a href="varbas.html#wtk">wtk</a>,
directly or indirectly (using <a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a>)
depending on the value of <a href="varbas.html#occopt">occopt</a>.
<br>For GS, this option
might be used to generate Density-of-states
(thanks to <a href="varfil.html#prtdos">prtdos</a>),
or to produce STM charge density map (thanks to <a href="varfil.html#prtstm">prtstm</a>).
<br>For RF, this option is needed to compute the response to ddk perturbation.</li>

<li>= -1 => like -2, but the non-self-consistent calculation
is followed by the determination of excited states
within TDDFT. This is only possible for <a href="varbas.html#nkpt">nkpt</a>=1,
with <a href="varbas.html#kpt">kpt</a>=0 0 0.
Note that the oscillator strength needs to be defined with respect to
an origin of coordinate, thanks to the input variable
<a href="vargs.html#boxcenter">boxcenter</a>. The maximal
number of Kohn-Sham excitations to be used to build the
excited state TDDFT matrix can be defined by <a href="varrf.html#td_mexcit">td_mexcit</a>,
or indirectly by the maximum Kohn-Sham excitation energy
<a href="varrf.html#td_maxene">td_maxene</a>.
</li>
</ul>
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ixc">ixc</a></font>
<br><font id="definition">Mnemonics: Integer for eXchange-Correlation choice </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is <b>ixc</b>=1 (Teter parameterization). However, if all the
pseudopotentials have the same value of pspxc, the initial value of <b>ixc</b> will be
that common value.</font>
<br><br><font id="text">Controls the choice of exchange and correlation (xc).
<ul>
<li>0=> NO xc; </li>
</ul>
<ul>
<li>1=> LDA or LSD, Teter Pade parametrization (4/93, published in S. Goedecker, M. Teter, J. Huetter, Phys.Rev.B54, 1703 (1996)), which
  reproduces Perdew-Wang (which reproduces Ceperley-Alder!).</li>
<li>2=> LDA, Perdew-Zunger-Ceperley-Alder (no spin-polarization)</li>
<li>3=> LDA, old Teter rational polynomial parametrization (4/91)
    fit to Ceperley-Alder data (no spin-polarization)</li>
<li>4=> LDA, Wigner functional (no spin-polarization)</li>
<li>5=> LDA, Hedin-Lundqvist functional (no spin-polarization)</li>
<li>6=> LDA, "X-alpha" functional (no spin-polarization)</li>
<li>7=> LDA or LSD, Perdew-Wang 92 functional</li>
<li>8=> LDA or LSD, x-only part of the Perdew-Wang 92 functional</li>
<li>9=> LDA or LSD, x- and RPA correlation part of the Perdew-Wang 92 functional</li>
</ul>
<ul>
<li>11=> GGA, Perdew-Burke-Ernzerhof GGA functional</li>
<li>12=> GGA, x-only part of Perdew-Burke-Ernzerhof GGA functional</li>
<li>13=> GGA potential of van Leeuwen-Baerends, while for energy, Perdew-Wang 92 functional</li>
<li>14=> GGA, revPBE of Y. Zhang and W. Yang, Phys. Rev. Lett. 80, 890 (1998)</li>
<li>15=> GGA, RPBE of B. Hammer, L.B. Hansen and J.K. Norskov, Phys. Rev. B 59, 7413 (1999)</li>
<li>16=> GGA, HTCH93 of F.A. Hamprecht, A.J. Cohen, D.J. Tozer, N.C. Handy, J. Chem. Phys. 109, 6264 (1998)</li>
<li>17=> GGA, HTCH120 of A.D. Boese, N.L. Doltsinis, N.C. Handy, and M. Sprik, J. Chem. Phys 112, 1670 (1998) - The usual HCTH functional.</li>
<li>18=> (NOT AVAILABLE : tentative assignment, for planning purposes) GGA, BLYP.</li>
<li>19=> (NOT AVAILABLE : tentative assignment, for planning purposes) GGA, BP.</li>
</ul>
<ul>
<li>20=> Fermi-Amaldi xc ( -1/N Hartree energy, where N is the
      number of electrons per cell ; G=0 is not taken
      into account however), for TDDFT tests.
      No spin-pol. Does not work for RF.</li>
<li>21=> same as 20, except that the xc-kernel is the LDA (<b>ixc</b>=1) one,
      for TDDFT tests.</li>
<li>22=> same as 20, except that the xc-kernel is the Burke-Petersilka-Gross
      hybrid, for TDDFT tests.</li>
<li>23=> GGA of Z. Wu and R.E. Cohen, Phys. Rev. 73, 235116 (2006).</li>
<li>26=> GGA, HTCH147 of A.D. Boese, N.L. Doltsinis, N.C. Handy, and M. Sprik, J. Chem. Phys 112, 1670 (1998).</li>
<li>27=> GGA, HTCH407 of A.D. Boese, and N.C. Handy, J. Chem. Phys 114, 5497 (2001).</li>
<li>28=> (NOT AVAILABLE : tentative assignment, for planning purposes) GGA, OLYP.</li>
</ul>
<ul>
<li>30=> (tentative assignment, for testing purposes) X-only functional, from the Nanoquanta libxc, developed by Miguel Marques </li>
<li>31=> (tentative assignment, for testing purposes) X+ VWN C functional, from the Nanoquanta libxc, developed by Miguel Marques </li>
<li>32=> (tentative assignment, for testing purposes) X+ PZ C functional, from the Nanoquanta libxc, developed by Miguel Marques </li>
<li>33=> (tentative assignment, for testing purposes) X+ PW C functional, from the Nanoquanta libxc, developed by Miguel Marques </li>
<li>34=> (tentative assignment, for testing purposes) X+ AMGB C functional, from the Nanoquanta libxc, developed by Miguel Marques </li>
</ul>
<br>Note that the choice made here should agree with the choice
made in generating the original pseudopotential, except
for <b>ixc</b>=0 (usually only used for debugging).
A warning is issued if this is not the case.
However, the choices <b>ixc</b>=1, 2, 3 and 7 are fits to the same data, from
Ceperley-Alder, and are rather similar, at least for spin-unpolarized systems.
<br>The choice between the LDA and the LSDA
(or between the GGA and spin-GGA) is governed
by the value of <a href="varbas.html#nsppol">nsppol</a> (see below).
<p>
<br>NOTE : in the implementation of the spin-dependence of these
functionals, and in order to avoid divergences in their
derivatives, the interpolating function between spin-unpolarized
and fully-spin-polarized function has been slightly modified,
by including a zeta rescaled by 1.d0-1.d-6. This should affect
total energy at the level of 1.d-6Ha, and should
have an even smaller effect on differences of energies, or derivatives.
<br>The value <b>ixc</b>=10 is used internally : gives the difference between <b>ixc</b>=7 and
<b>ixc</b>=9, for use with an accurate RPA correlation energy.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="jdtset">jdtset</a></font>
<br><font id="definition">Mnemonics: index -J- for DaTaSETs </font>
<br><font id="category">Characteristic: NO MULTI </font>
<br><font id="vartype">Variable type: integer array <b>jdtset</b>(<a href="varbas.html#ndtset">ndtset</a>)</font>
<br><font id="default">Default is the series 1, 2, 3 ... <a href="varbas.html#ndtset">ndtset</a> .</font>
<br><br><font id="text">Gives the dataset index
of each of the datasets. This index will be used :
<ul>
<li>to determine which input variables are specific to each
    dataset, since the variable names for this
    dataset will be made from the bare variable
    name concatenated with this index, and only if
    such a composite variable name does not exist,
    the code will consider the bare variable name,
    or even, the Default;</li>
<li>to characterize output variable names, if their
    content differs from dataset to dataset;</li>
<li>to characterize output files ( root names appended with _DSx
    where 'x' is the dataset index ).</li>
</ul>
The allowed index values are between 1 and 99.
<br>An input variable name appended with 0 is not allowed.
<br>When <a href="varbas.html#ndtset">ndtset</a>==0, this array is not used, and moreover,
no input variable name appended with a digit is allowed.
This array might be initialized thanks to the use of
the input variable <a href="varbas.html#udtset">udtset</a>. In this case, <b>jdtset</b> cannot
be used.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="kpt">kpt</a></font>
<br><font id="definition">Mnemonics: K - PoinTs </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real array kpt(3,<a href="varbas.html#nkpt">nkpt</a>)  </font>
<br><font id="default">Default is 0. 0. 0. (for just one k-point, adequate for one molecule in a supercell)</font>
<br><br><font id="text">
Contains the k points in terms
of reciprocal space primitive translations (NOT in
cartesian coordinates!).
<br> Needed ONLY
if <a href="varbas.html#kptopt">kptopt</a>=0, otherwise
deduced from other input variables.

<p>It contains dimensionless numbers in terms of which
the cartesian coordinates would be:
<br><tele>k_cartesian = k1*G1+k2*G2+k3*G3 </tele>
<br>where <tele>(k1,k2,k3)</tele> represent the dimensionless "reduced
coordinates" and <tele>G1, G2, G3</tele> are the cartesian coordinates
of the primitive translation vectors.  G1,G2,G3 are related
to the choice of direct space primitive translation vectors
made in <a href="varbas.html#rprim">rprim</a>.
Note that an overall norm for the k
points is supplied by <a href="varbas.html#kptnrm">kptnrm</a>.  This allows
one to avoid supplying many digits for the k points to
represent such points as (1,1,1)/3.
<br>Note: one of the algorithms used to set up the sphere
of G vectors for the basis needs components of k-points
in the range [-1,1], so the
remapping is easily done by adding or subtracting 1 from
each component until it is in the range [-1,1].  That is,
given the k point normalization <a href="varbas.html#kptnrm">kptnrm</a> described below,
each component must lie in [-<a href="varbas.html#kptnrm">kptnrm</a>,<a href="varbas.html#kptnrm">kptnrm</a>].
<br>Not read if <a href="varbas.html#kptopt">kptopt</a>/=0 .</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="kptnrm">kptnrm</a></font>
<br><font id="definition">Mnemonics: K - PoinTs NoRMalization </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 1.</font>
<br><br><font id="text">
Establishes a normalizing denominator
for each k point.
Needed only
if <a href="vasbas.htm#kptopt">kptopt</a>&lt;=0, otherwise
deduced from other input variables.
<br>The k point coordinates as fractions
of reciprocal lattice translations are therefore
<a href="varbas.html#kpt">kpt</a>(mu,ikpt)/<b>kptnrm</b>.  <b>kptnrm</b> defaults to 1 and can
be ignored by the user.  It is introduced to avoid
the need for many digits in representing numbers such as 1/3.
<br>It cannot be smaller than 1.0d0
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="kptopt">kptopt</a></font>
<br><font id="definition">Mnemonics: KPoinTs OPTion </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0 .</font>
<br><br><font id="text">
Controls the set up of the k-points list.
The aim will be to initialize, by straight reading
or by a preprocessing approach based on other input variables,
the following input variables, giving the k points, their number,
and their weight:
<a href="varbas.html#kpt">kpt</a>,
<a href="varbas.html#kptnrm">kptnrm</a>,
<a href="varbas.html#nkpt">nkpt</a>,
and, for <a href="varbas.html#iscf">iscf</a>/=-2,
<a href="varbas.html#wtk">wtk</a>.

<p>
Often, the k points will form a lattice in reciprocal space. In this case,
one will also aim at initializing input variables that give
the reciprocal of this k-point lattice, as well as its shift with respect
to the origin:
<a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a>,
as well as on <a href="varbas.html#nshiftk">nshiftk</a> and
<a href="varbas.html#shiftk">shiftk</a>.

<ul>
<li>0=> read directly <a href="varbas.html#nkpt">nkpt</a>, <a href="varbas.html#kpt">kpt</a>,
<a href="varbas.html#kptnrm">kptnrm</a> and <a href="varbas.html#wtk">wtk</a>.
<li>1=> rely on <a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a>, as well as on
<a href="varbas.html#nshiftk">nshiftk</a> and
<a href="varbas.html#shiftk">shiftk</a> to set up the k points.
      Take fully into account the symmetry to generate the
     k points in the Irreducible Brillouin Zone only.<br>
     (This is the usual mode for GS calculations)</li>
<li>2=> rely on
<a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a>, as well as on
<a href="varbas.html#nshiftk">nshiftk</a> and
<a href="varbas.html#shiftk">shiftk</a> to set up the k points.
     Take into account only the time-reversal symmetry :
     k points will be generated in half the Brillouin zone.<br>
     (This is to be used when preparing or executing a
     RF calculation at q=(0 0 0) ) </li>
<li>3=> rely on <a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a>, as well as on
<a href="varbas.html#nshiftk">nshiftk</a> and
<a href="varbas.html#shiftk">shiftk</a> to set up the k points.
     Do not take into account any symmetry :
     k points will be generated in the full Brillouin zone.<br>
     (This is to be used when preparing or executing a
     RF calculation at non-zero q )</li>
<li>A negative value =>
rely on <a href="vargs.html#kptbounds">kptbounds</a>,
and <a href="vargs.html#ndivk">ndivk</a>
to set up a band structure calculation along different lines
     (allowed only for <a href="varbas.html#iscf">iscf</a>==-2).
The absolute value of <b>kptopt</b> gives the number of segments
of the band structure.
</li>
</ul>
In the case of a grid of k points, the auxiliary variables
<a href="vargs.html#kptrlen">kptrlen</a>,
<a href="varbas.html#ngkpt">ngkpt</a>  and
<a href="varfil.html#prtkpt">prtkpt</a> might help
you to select the optimal grid.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="natom">natom</a></font>
<br><font id="definition">Mnemonics: Number of ATOMs </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 1 </font>
<br><br><font id="text">
Gives the total number of atoms in the unit cell.
Default is 1 but you will obviously want to input this
value explicitly.
<br>Note that <b>natom</b> refers to all atoms in the unit cell, not
only to the irreducible set of atoms in the unit cell (using symmetry operations,
this set allows to recover all atoms). If you want
to specify only the irreducible set of atoms, use the
symmetriser, see the input variable <a href="vargeo.html#natrd">natrd</a>.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nband">nband</a></font>
<br><font id="definition">Mnemonics: Number of BANDs </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 1.</font>
<br><br><font id="text">
Gives number of bands, occupied plus
possibly unoccupied, for which wavefunctions are being computed
along with eigenvalues.
<br>Note : if the parameter
<a href="varbas.html#occopt">occopt</a> (see below) is not set to 2,
<b>nband</b> is a scalar integer, but
if the parameter <a href="varbas.html#occopt">occopt</a> is set to 2,
then <b>nband</b> must be an array <b>nband</b>(<a href="varbas.html#nkpt">nkpt</a>*
<a href="varbas.html#nsppol">nsppol</a>) giving the
number of bands explicitly for each k point.  This
option is provided in order to allow the number of
bands treated to vary from k point to k point.
<br>For the values of <a href="varbas.html#occopt">occopt</a> not equal to 0 or 2, <b>nband</b>
can be omitted. The number of bands will be set up
thanks to the use of the variable <a href="vargs.html#fband">fband</a>. The present Default
will not be used.
<p>If <a href="vargs.html#nspinor">nspinor</a> is 2, nband must be even for
each k point.
<p>In the case of a GW calculation (<a href="vargs.html#optdriver">optdriver</a>=3 or 4),
<b>nband</b> gives the number of bands to be treated to generate the screening (susceptibility
and dielectric matrix), as well as the self-energy. However, to generate the _KSS
file (see <a href="varfil.html#kssform">kssform</a>)
the relevant number of bands is given by <a href="vargw.html#nbandkss">nbandkss</a>.

</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ndtset">ndtset</a></font>
<br><font id="definition">Mnemonics: Number of DaTaSETs </font>
<br><font id="category">Characteristic: NO MULTI  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 (no multi-data set).</font>
<br><br><font id="text">
Gives the number of data sets to be
treated.
<br>If 0, means that the multi-data set treatment is not used,
so that the root filenames will not be appended with _DSx,
where 'x' is the dataset index defined
by the input variable <a href="varbas.html#jdtset">jdtset</a>,
and also that input names with a dataset index are not allowed.
Otherwise, <b>ndtset</b>=0 is equivalent to <b>ndtset</b>=1.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ngkpt">ngkpt</a></font>
<br><font id="definition">Mnemonics: Number of Grid points
for K PoinTs generation </font>
<br><font id="category">Characteristic: NOT INTERNAL </font>
<br><font id="vartype">Variable type: integer array ngkpt(3)</font>
<br><font id="default">Default is No Default</font>
<br><br><font id="text">
Used when <a href="varbas.html#kptopt">kptopt</a>>=0,
if <a href="vargs.html#kptrlatt">kptrlatt</a>
has not been defined (<a href="vargs.html#kptrlatt">kptrlatt</a>
and <b>ngkpt</b> are exclusive of each other).
<br> Its three positive components
give the number of k points of Monkhorst-Pack grids
(defined with respect to primitive axis in reciprocal space)
in each of the three dimensions.
<b>ngkpt</b> will be used to generate the
corresponding <a href="vargs.html#kptrlatt">kptrlatt</a>
input variable.
The use of <a href="varbas.html#nshiftk">nshiftk</a>
and <a href="varbas.html#shiftk">shiftk</a>, allows to generate
shifted grids, or Monkhorst-Pack grids defined
with respect to conventional unit cells.
<p>When <a href="varbas.html#nshiftk">nshiftk</a>=1,
<a href="vargs.html#kptrlatt">kptrlatt</a> is initialized
as a diagonal (3x3) matrix, whose diagonal elements
are the three values <b>ngkpt</b>(1:3). When
<a href="varbas.html#nshiftk">nshiftk</a> is greater than 1,
ABINIT will try to generate <a href="vargs.html#kptrlatt">kptrlatt</a>
on the basis of the primitive vectors of the k-lattice:
the number of shifts might be reduced, in which case
<a href="vargs.html#kptrlatt">kptrlatt</a> will not be diagonal
anymore.
<p>Monkhorst-Pack grids are usually the most efficient when
their defining integer numbers are even.
For a measure of the efficiency, see the input variable
<a href="vargs.html#kptrlen">kptrlen</a>.
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nkpt">nkpt</a></font>
<br><font id="definition">Mnemonics: Number of K - Points </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 if
<a href="varbas.html#kptopt">kptopt</a>/=0, and 1 if
<a href="varbas.html#kptopt">kptopt</a>==0.</font>
<br><br><font id="text">If non-zero,
<b>nkpt</b>
gives the number of k points in the k point array
<a href="varbas.html#kpt">kpt</a>. These points
are used either to sample the Brillouin zone, or to
build a band structure along specified lines.
<p>
If <b>nkpt</b> is zero, the code deduces from other input variables
(see the list in the description of <a href="varbas.html#kptopt">kptopt</a>)
the number of k points, which is possible only
when <a href="varbas.html#kptopt">kptopt</a>/=0.
If <a href="varbas.html#kptopt">kptopt</a>/=0 and
the input value of <a href="varbas.html#nkpt">nkpt</a>/=0,
then ABINIT will check that the number of k points
generated from the other input variables
is exactly the same than <b>nkpt</b>.

<p>If <a href="varbas.html#kptopt">kptopt</a> is positive,
<b>nkpt</b> must be coherent with the values
of <a href="vargs.html#kptrlatt">kptrlatt</a>,
<a href="varbas.html#nshiftk">nshiftk</a>
and <a href="varbas.html#shiftk">shiftk</a>.
<br>
For ground state calculations, one should select the
k point in the irreducible Brillouin Zone (obtained
by taking into account point symmetries and the time-reversal
symmetry).
<br>For response function calculations, one should
select k points in the full Brillouin zone, if the wavevector
of the perturbation does not vanish, or in a half of
the Brillouin Zone if q=0. The code will automatically decrease
the number of k points to the minimal set needed for
each particular perturbation.
<p>If <a href="varbas.html#kptopt">kptopt</a> is negative,
<b>nkpt</b> will be the sum of the number of points on
the different lines of the band structure.
For example,
if <a href="varbas.html#kptopt">kptopt</a>=-3, one
will have three segments; supposing
<a href="vargs.html#ndivk">ndivk</a> is 10 12 17,
the total number of k points of the circuit will be
10+12+17+1(for the final point)=40.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nshiftk">nshiftk</a></font>
<br><font id="definition">Mnemonics: Number of SHIFTs for K point grids </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">The Default is 1.</font>
<br><br><font id="text"> This parameter
gives the number of shifted grids
to be used concurrently to generate the full grid of k points.
It can be used with primitive grids defined either from
<a href="varbas.html#ngkpt">ngkpt</a>
or
<a href="vargs.html#kptrlatt">kptrlatt</a>.
The maximum allowed value of <b>nshiftk</b> is 8.
The values of the shifts are given by <a href="varbas.html#shiftk">shiftk</a>.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nsppol">nsppol</a></font>
<br><font id="definition">Mnemonics: Number of SPin POLarization </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">The Default is 1.</font>
<br><br><font id="text"> Give the number of INDEPENDENT
spin polarisations. Can take the values
1 or 2.
<p>If <b>nsppol</b>=1, one has an unpolarized calculation
(<a href="vargs.html#nspinor">nspinor</a>=1,
<a href="vargs.html#nspden">nspden</a>=1) or
an antiferromagnetic system
(<a href="vargs.html#nspinor">nspinor</a>=1,
<a href="vargs.html#nspden">nspden</a>=2), or
a calculation in which spin up and spin down cannot be disantengled
(<a href="vargs.html#nspinor">nspinor</a>=2), that is, either
 non-collinear magnetism or presence of spin-orbit coupling,
 for which one needs spinor wavefunctions.
<p>If <b>nsppol</b>=2, one has a spin-polarized (collinear) calculation
with separate and different wavefunctions for up and
down spin electrons for each band and k point.
Compatible only with <a href="vargs.html#nspinor">nspinor</a>=1,
<a href="vargs.html#nspden">nspden</a>=2.
<p>In the present status of development,
with <b>nsppol</b>=1,
all values of <a href="varbas.html#ixc">ixc</a> are allowed, while
with <b>nsppol</b>=2,
some values of <a href="varbas.html#ixc">ixc</a> might not be allowed (e.g. 2, 3, 4, 5, 6, 20, 21, 22 are not allowed).
<p>See also the input variable <a href="vargs.html#nspden">nspden</a>
for the components of the density matrix with respect to
the spin-polarization.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nstep">nstep</a></font>
<br><font id="definition">Mnemonics: Number of self-consistent field STEPS </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 30. (was 1 before v5.3)</font>
<br><br><font id="text"> Gives the maximum number of SCF cycles (or "iterations").
<br>Full convergence from random numbers if usually achieved in
12-20 SCF iterations.  Each can take from minutes to hours.
In certain difficult cases, usually related to a small or
zero bandgap, convergence performance may be much worse.
When the convergence tolerance <a href="varbas.html#tolwfr">tolwfr</a> on the wavefunctions
is satisfied, iterations will stop, so for well converged
calculations you should set <b>nstep</b> to a value larger than
you think will be needed for full convergence, e.g.
if 20 steps usually converges the system, set <b>nstep</b> to 30.
<p>NOTE that a choice of <b>nstep</b>=0 is permitted; this will
either read wavefunctions from disk (with <a href="varfil.html#irdwfk">irdwfk</a>=1
or  <a href="varfil.html#irdwfq">irdwfq</a>=1,
or non-zero <a href="varfil.html#getwfk">getwfk</a>
or <a href="varfil.html#getwfq">getwfq</a> in the case
of multi-dataset) and
compute the density, the total energy and stop, or else
(with all of the above vanishing) will initialize
randomly the wavefunctions and
compute the resulting density and total energy.
This is provided for testing purposes.
<br>Also NOTE that <b>nstep</b>=0
 with <a href="varfil.html#irdwfk">irdwfk</a>=1 will exactly give the same result as
 the previous run only if the later is done with <a href="varbas.html#iscf">iscf</a><10
 (potential mixing).
<br>One can output the density by using <a href="varfil.html#prtden">prtden</a>.
<br>The forces and stress tensor gets computed with <b>nstep</b>=0.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nsym">nsym</a></font>
<br><font id="definition">Mnemonics: Number of SYMmetry operations </font>
<br><font id="category">Characteristic: SYMMETRY FINDER </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Gives number of space group symmetries
to be applied in this problem.  Symmetries will be input in
array "<a href="varbas.html#symrel">symrel</a>" and (nonsymmorphic) translations vectors
will be input
in array "<a href="varbas.html#tnons">tnons</a>".  If there is no symmetry in the problem
then set <b>nsym</b> to 1, because the identity is still a symmetry.

<br>In case of a RF calculation, the code is able to use
the symmetries of the system to decrease the number of
perturbations to be calculated, and to decrease of the
number of special k points to be used for the sampling of
the Brillouin zone.
After the response to the perturbations have been calculated,
the symmetries are used to generate as many as
possible elements of the 2DTE from those already
computed.

<p>SYMMETRY FINDER mode (Default mode).
If <b>nsym</b> is 0, all the atomic coordinates must be
explicitely given (one cannot use the geometry builder
and the symmetrizer): the code will then find automatically
the symmetry operations that leave the lattice and each
atomic sublattice invariant. It also checks whether the
cell is primitive (see <a href="vargs.html#chkprim">chkprim</a>).
<br>Note that the tolerance on symmetric atomic positions and
lattice is rather stringent :
for a symmetry operation to be admitted,
the lattice and atomic positions must map on themselves
within 1.0e-8 .

<p>The user is allowed to set up systems with non-primitive unit cells (i.e.
conventional FCC or BCC cells, or supercells without any distortion).
In this case, pure translations will be identified as symmetries
of the system by the symmetry finder.
Then, the combined "pure translation + usual rotation and inversion" symmetry
operations can be very numerous. For example, a conventional FCC cell
has 192 symmetry operations, instead of the 48 ones of the primitive cell.
A maximum limit of 384 symmetry operations is hard-coded. This
corresponds to the maximum number of symmetry operations of a 2x2x2
undistorted supercell. Going beyond
that number will make the code stop very rapidly. If you want
nevertheless, for testing purposes, to treat a larger number of symmetries,
change the initialization of "msym" in the abinit.F90 main routine,
then recompile the code.

<p>For GW calculation, the user might want to select only the symmetry operations whose
non-symmorphic translation vector <a href="varbas.html#tnons">tnons</a>
is zero. This can be done with the help of the input variable
<a href="vargw.html#symmorphi">symmorphi</a>
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ntypat">ntypat</a></font>
<br><font id="definition">Mnemonics: Number of TYPEs of atoms </font>
<br><font id="category">Characteristic: NO MULTI </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 1.</font>
<br><br><font id="text">Gives the number of types of atoms.  E.g. for
a homopolar system (e.g. pure Si) <b>ntypat</b> is 1, while for BaTiO3,
<b>ntypat</b> is 3.
<br>Except when alchemical mixing of pseudopotentials is used, the number
of types of atoms will be equal to the number of pseudopotentials
<a href="vargs.html#npsp">npsp</a> to be provided by the user.
Thus, the code will try to read the same number of pseudopotential files,
whose names should have been given in the "files" file.
<br>The first pseudopotential will be assigned the type number 1, and so
on ...</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="occopt">occopt</a></font>
<br><font id="definition">Mnemonics: OCCupation OPTion </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer option parameter  </font>
<br><font id="default">The Default is <b>occopt</b>=1.</font>
<br><br><font id="text">Controls how input
parameters <a href="varbas.html#nband">nband</a>, <a href="vargs.html#occ">occ</a>,
and <a href="varbas.html#wtk">wtk</a> are handled.
<ul>
<li>              <b>occopt</b>=0:
<br>All k points have the same number of bands
and the same occupancies of bands.  <a href="varbas.html#nband">nband</a> is given as a
single number, and <a href="vargs.html#occ">occ</a>(<a href="varbas.html#nband">nband</a>)
is an array of <a href="varbas.html#nband">nband</a>
elements, read in by the code.  <br>
The k point weights in array <a href="varbas.html#wtk">wtk</a>(<a href="varbas.html#nkpt">nkpt</a>) are
automatically normalized by the code to add to 1.</li>
<li>              <b>occopt</b>=1:
<br>Same as <b>occopt</b>=0, except that the array <a href="vargs.html#occ">occ</a> is
automatically generated by the code, to give a semiconductor.
<br>An error occurs when filling cannot be done with
occupation numbers equal to 2 or 0 in each k-point (non-spin-polarized case),
or with occupation numbers equal to 1 or 0 in each k-point (spin-polarized case).</li>
<li>             <b>occopt</b>=2:
<br>k points may optionally have different numbers of
bands and different occupancies.  <a href="varbas.html#nband">nband</a>(<a href="varbas.html#nkpt">
nkpt</a>*<a href="varbas.html#nsppol">nsppol</a>) is given
explicitly as an array of <a href="varbas.html#nkpt">nkpt</a>*<a href="varbas.html#nsppol">nsppol</a> elements.
<a href="vargs.html#occ">occ</a>() is given explicitly for all bands at each k point,
and eventually for each spin --
the total number of elements is the sum of <a href="varbas.html#nband">nband</a>(ikpt)
over all k points and spins. The k point weights <a href="varbas.html#wtk">wtk</a>
(<a href="varbas.html#nkpt">nkpt</a>) are
NOT automatically normalized under this option.</li>
<li>             <b>occopt</b>=3, 4, 5, 6 and 7
<br>Metallic occupation of levels, using different occupation
schemes (see below). The corresponding thermal
broadening, or cold smearing, is defined by
the input variable <a href="vargs.html#tsmear">tsmear</a> (see below : the variable
xx is the energy in Ha, divided by <a href="vargs.html#tsmear">tsmear</a>)
<br>Like for <b>occopt</b>=1, the variable <a href="vargs.html#occ">occ</a> is not read
<br>All k points have the same number of bands,
<a href="varbas.html#nband">nband</a> is given as a single number, read by the code.
<br>The k point weights in array <a href="varbas.html#wtk">wtk</a>(<a href="varbas.html#nkpt">nkpt</a>) are
automatically normalized by the code to add to 1.</li>
<ul>
<li> <b>occopt</b>=3:
<br>Fermi-Dirac smearing (finite-temperature metal)
Smeared delta function : 0.25d0/(cosh(xx/2.0d0)**2)</li>
<li> <b>occopt</b>=4:
<br>"Cold smearing" of N. Marzari (see his thesis work),
with a=-.5634 (minimization of the bump)
<br>Smeared delta function :
<br>  exp(-xx<sup>2</sup>)/sqrt(pi) * (1.5d0+xx*(-a*1.5d0+xx*(-1.0d0+a*xx)))</li>
<li> <b>occopt</b>=5:
<br>"Cold smearing" of N. Marzari (see his thesis work),
with a=-.8165 (monotonic function in the tail)
<br>Same smeared delta function as <b>occopt</b>=4, with different a.</li>
<li> <b>occopt</b>=6:
<br>Smearing of Methfessel and Paxton (PRB40,3616(1989))
with Hermite polynomial of degree 2, corresponding
to "Cold smearing" of N. Marzari with a=0
(so, same smeared delta function as <b>occopt</b>=4, with different a).</li>
<li> <b>occopt</b>=7:
<br>Gaussian smearing, corresponding to the 0 order
Hermite polynomial of Methfessel and Paxton.
<br>Smeared delta function : 1.0d0*exp(-xx**2)/sqrt(pi)</li>
</ul>
</ul>

WARNING : one can use metallic occupation of levels in the
case of a molecule, in order to avoid any problem with
degenerate levels. However, it is advised NOT to use
<b>occopt</b>=6 (and to a lesser extent <b>occopt</b>=4 and 5),
since the associated number of electron
versus the Fermi energy is NOT guaranteed to be
a monotonic function. For true metals, AND a sufficiently
dense sampling of the Brillouin zone, this should not happen,
but be cautious ! As an indication of this problem,
a small variation of input parameters might lead to
a jump of total energy, because there might be two or even
three possible values of the Fermi energy, and the
bisection algorithm find one or the other. </font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="rprim">rprim</a></font>
<br><font id="definition">Mnemonics: Real space PRIMitive translations </font>
<br><font id="category">Characteristic: EVOLVING (if <a href="varrlx.html#ionmov">ionmov</a>==2 and
<a href="varrlx.html#optcell">optcell</a>/=0) </font>
<br><font id="vartype">Variable type: real array rprim(3,3) </font>
<br><font id="default">Default is 3x3 unity matrix.</font>
<br><br><font id="text">Give, in columnwise entry,
the three dimensionless primitive translations in real space.
<br>If the Default is used, that is, <b>rprim</b> is the unity matrix,
the three dimensionless primitive vectors are three
unit vectors in cartesian coordinates. Each will be multiplied
by the corresponding <a href="varbas.html#acell">acell</a> value to give the dimensional
primitive vectors, called <a href="varbas.html#rprimd">rprimd</a>.
<br>In the general case, the dimensional cartesian
coordinates of the crystal primitive translations R1p, R2p and R3p, see
<a href="varbas.html#rprimd">rprimd</a>, are
<ul>
<li>  R1p(i)=<b>rprim</b>(i,1)*<a href="varbas.html#acell">acell</a>(1) for i=1,2,3 (x,y,and z)</li>
<li>  R2p(i)=<b>rprim</b>(i,2)*<a href="varbas.html#acell">acell</a>(2) for i=1,2,3</li>
<li>  R3p(i)=<b>rprim</b>(i,3)*<a href="varbas.html#acell">acell</a>(3) for i=1,2,3.</li>
</ul>
The <b>rprim</b> variable is thus used to define directions
of the primitive vectors, that will be multiplied by
the appropriate length scale <a href="varbas.html#acell">acell</a>(1), <a href="varbas.html#acell">acell</a>(2),
or <a href="varbas.html#acell">acell</a>(3)
respectively to give the dimensional primitive translations
in real space in cartesian coordinates.
<br>Presently, it is requested that the mixed product
(R1xR2).R3 is positive. If this is not the case,
simply exchange a pair of vectors.
<br>
To be more specific, <b>rprim</b> 1 2 3 4 5 6 7 8 9 corresponds to input
of the three primitive translations R1=(1,2,3),
R2=(4,5,6), and R3=(7,8,9).
<br>
Note carefully that the first
three numbers input are the first column of <b>rprim</b>, the next
three are the second, and the final three are the third.
This corresponds with the usual Fortran order for arrays.
The matrix whose columns are the reciprocal space primitive
translations is the inverse transpose of the matrix whose
columns are the direct space primitive translations.
<p>Alternatively to <b>rprim</b>, directions of dimensionless primitive
vectors can be specified by using the input variable <a href="varbas.html#angdeg">angdeg</a>.
This is especially useful for hexagonal lattices (with 120 or 60 degrees angles).
Indeed, in order for symmetries to be recognized, rprim must be symmetric up to 10 digits,
inducing a specification such as
<pre>
rprim  0.86602540378  0.5  0.0
      -0.86602540378  0.5  0.0
       0.0            0.0  1.0
</pre>
that can be avoided thanks to <a href="varbas.html#angdeg">angdeg</a>:
<pre>
angdeg 90 90 120
</pre>
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="rprimd">rprimd</a></font>
<br><font id="definition">Mnemonics: Real space PRIMitive translations, Dimensional </font>
<br><font id="category">Characteristic: INTERNAL, EVOLVING
(if <a href="varrlx.html#ionmov">ionmov</a>==2 and
<a href="varrlx.html#optcell">optcell</a>/=0) </font>
<br><font id="vartype">Variable type: real array rprimd(3,3) </font>
<br><br><font id="text">
This internal variable gives the dimensional real space primitive
vectors, computed from <a href="varbas.html#acell">acell</a>
and <a href="varbas.html#rprim">rprim</a>.
<ul>
<li>  R1p(i)=<b>rprimd</b>(i,1)=<a href="varbas.html#rprim">rprim</a>(i,1)*<a href="varbas.html#acell">acell</a>(1) for i=1,2,3 (x,y,and z)</li>
<li>  R2p(i)=<b>rprimd</b>(i,2)=<a href="varbas.html#rprim">rprim</a>(i,2)*<a href="varbas.html#acell">acell</a>(2) for i=1,2,3</li>
<li>  R3p(i)=<b>rprimd</b>(i,3)=<a href="varbas.html#rprim">rprim</a>(i,3)*<a href="varbas.html#acell">acell</a>(3) for i=1,2,3</li>
</ul>
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="shiftk">shiftk</a></font>
<br><font id="definition">Mnemonics: SHIFT for K points </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type:
real array shift(3,<a href="varbas.html#nshiftk">nshiftk</a>)  </font>
<br><font id="default">Default is 0.5 0.5 0.5 ... 0.5  </font>
<br><br><font id="text">
It is used only when <a href="varbas.html#kptopt">kptopt</a>>=0,
and must be defined if <a href="varbas.html#nshiftk">nshiftk</a> is larger than 1.
<br><b>shiftk</b>(1:3,1:<a href="varbas.html#nshiftk">nshiftk</a>) defines
<a href="varbas.html#nshiftk">nshiftk</a> shifts
of the homogeneous grid of k points
based on <a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a>.
<br>The shifts induced by <b>shiftk</b> corresponds
to the reduced coordinates in the coordinate system
defining the k-point lattice. For example,
if the k point lattice is defined using <a href="varbas.html#ngkpt">ngkpt</a>,
the point whose reciprocal space reduced coordinates are
( <b>shiftk</b>(1,ii)/<a href="varbas.html#ngkpt">ngkpt</a>(1)
  <b>shiftk</b>(2,ii)/<a href="varbas.html#ngkpt">ngkpt</a>(2)
  <b>shiftk</b>(3,ii)/<a href="varbas.html#ngkpt">ngkpt</a>(3) )
belongs to the shifted grid number ii.

<p>The user might rely on ABINIT to suggest suitable and
efficient combinations of <a href="vargs.html#kptrlatt">kptrlatt</a>
and <a href="varbas.html#shiftk">shiftk</a>.
The procedure to be followed is described with the
input variables <a href="vargs.html#kptrlen">kptrlen</a>.
In what follows, we suggest some interesting values of the shifts,
to be used with even values of <a href="varbas.html#ngkpt">ngkpt</a>.
This list is much less exhaustive than the above-mentioned automatic
procedure.
<p>
1) When the primitive vectors of the lattice do NOT form
a FCC or a BCC lattice, the usual (shifted) Monkhorst-Pack
grids are formed by using
<a href="varbas.html#nshiftk">nshiftk</a>=1 and <b>shiftk</b> 0.5 0.5 0.5 .
This is often the preferred k point sampling.
For a non-shifted Monkhorst-Pack grid, use
<a href="varbas.html#nshiftk">nshiftk</a>=1 and <b>shiftk</b> 0.0 0.0 0.0 ,
but there is little reason to do that.
<p>The FCC k point sampling defined with
<a href="varbas.html#nshiftk">nshiftk</a>=4 and <b>shiftk</b>
<pre>
        0.5 0.5 0.5
        0.5 0.0 0.0
        0.0 0.5 0.0
        0.0 0.0 0.5
</pre>
is particularly efficient.
<p>
2) When the primitive vectors of the lattice form a FCC lattice,
with <a href="varbas.html#rprim">rprim</a>
<pre>
        0.0 0.5 0.5
        0.5 0.0 0.5
        0.5 0.5 0.0
</pre>
the usual Monkhorst-Pack sampling will be generated by using
<a href="varbas.html#nshiftk">nshiftk</a>= 4  and <b>shiftk</b>
<pre>
        0.5 0.5 0.5
        0.5 0.0 0.0
        0.0 0.5 0.0
        0.0 0.0 0.5
</pre>
<p>
3) When the primitive vectors of the lattice form a BCC lattice,
with <a href="varbas.html#rprim">rprim</a>
<pre>
       -0.5  0.5  0.5
        0.5 -0.5  0.5
        0.5  0.5 -0.5
</pre>
the usual Monkhorst-Pack sampling will be generated by using
<a href="varbas.html#nshiftk">nshiftk</a>= 2  and <b>shiftk</b>
<pre>
        0.25  0.25  0.25
       -0.25 -0.25 -0.25
</pre>
However, the simple sampling
<a href="varbas.html#nshiftk">nshiftk</a>=1 and <b>shiftk</b> 0.5 0.5 0.5
is excellent.
<p>
4) For hexagonal lattices, one can use
<a href="varbas.html#nshiftk">nshiftk</a>= 1  and <b>shiftk</b>  0.0 0.0 0.5
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="symrel">symrel</a></font>
<br><font id="definition">Mnemonics:SYMmetry in REaL space  </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array symrel(3,3,<a href="varbas.html#nsym">nsym</a>)  </font>
<br><font id="default">Default is the identity matrix for one symmetry.</font>
<br><br><font id="text">Gives "<a href="varbas.html#nsym">nsym</a>" 3x3 matrices
expressing space group symmetries in terms of their action
on the direct (or real) space primitive translations.
<br>It turns out that these can always be expressed as integers.
<br>Always give the identity matrix even if no other symmetries
hold, e.g.
<b>symrel</b> 1 0 0 0 1 0 0 0 1
<br>Also note that for this array as for all others the array
elements are filled in a columnwise order as is usual for
Fortran.
<br>The relation between the above symmetry matrices <b>symrel</b>,
expressed in the basis of primitive translations, and
the same symmetry matrices expressed in cartesian coordinates,
is as follows.  Denote the matrix whose columns are the
primitive translations as R, and denote the cartesian
symmetry matrix as S.  Then <br>
    <b>symrel</b> = R(inverse) * S * R <br>
where matrix multiplication is implied.
<br>When the symmetry finder is used (see <a href="varbas.html#nsym">nsym</a>), <b>symrel</b>
will be computed automatically.</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="tnons">tnons</a></font>
<br><font id="definition">Mnemonics: Translation NON-Symmorphic vectors </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type:
 real array tnons(3,<a href="varbas.html#nsym">nsym</a>)  </font>
<br><br><font id="text">Gives the (nonsymmorphic) translation
vectors associated with the symmetries expressed
in "<a href="varbas.html#symrel">symrel</a>".
<br>These may all be 0, or may be fractional (nonprimitive)
translations expressed relative to the real space
primitive translations (so, using the "reduced" system
of coordinates, see "<a href="varbas.html#xred">xred</a>").
If all elements of the space
group leave 0 0 0 invariant, then these are all 0.
<br>When the symmetry finder is used (see <a href="varbas.html#nsym">nsym</a>), <b>tnons</b>
is computed automatically.</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="toldfe">toldfe</a></font>
<br><font id="definition">Mnemonics: TOLerance on the DiFference of total Energy </font>
<br><font id="category">Characteristic: ENERGY  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0.0 (stopping condition ignored)</font>
<br><br><font id="text">Sets a tolerance for absolute differences
of total energy that, reached TWICE successively,
will cause one SCF cycle to stop (and ions to be moved).
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>toldfe</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
(1 Ha=27.2113845 eV)
<br>If set to zero, this stopping condition is ignored.
<br>Effective only when SCF cycles are done (<a href="varbas.html#iscf">iscf</a>>0).
In this case, since <b>toldfe</b>, <a href="varbas.html#toldff">toldff</a>,
<a href="varbas.html#tolrff">tolrff</a>,
<a href="varbas.html#tolvrs">tolvrs</a> and <a href="varbas.html#tolwfr">tolwfr</a>
are aimed at the same goal (causing the SCF cycle to stop),
one and only one of these must be specified.
<br>Because of machine precision, it is not worth to try
to obtain differences in energy that are smaller
than about 1.0d-12 of the total energy.
To get accurate stresses may be quite demanding.
<br>When the geometry is optimized (relaxation of atomic positions or primitive vectors), the use of
<b>toldfe</b> is to be avoided. The use of <a href="varbas.html#toldff">toldff</a> or 
<a href="varbas.html#tolrff">tolrff</a> is by far preferable, in order to have a handle on the
geometry characteristics. When all forces vanish by symmetry (e.g. optimization of the lattice parameters
of a high-symmetry crystal), then place <b>toldfe</b> to 1.0d-12, or use (better) <a href="varbas.html#tolvrs">tolvrs</a>.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="toldff">toldff</a></font>
<br><font id="definition">Mnemonics: TOLerance on the DiFference of Forces </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0.0 (stopping condition ignored)</font>
<br><br><font id="text">Sets a tolerance for differences of forces
(in hartree/Bohr) that, reached TWICE successively,
will cause one SCF cycle to stop (and ions to be moved).
<br>If set to zero, this stopping condition is ignored.
<br>Effective only when SCF cycles are done (<a href="varbas.html#iscf">iscf</a>>0).
In this case, since <a href="varbas.html#toldfe">toldfe</a>, <b>toldff</b>,
<a href="varbas.html#tolrff">tolrff</a>,
<a href="varbas.html#tolvrs">tolvrs</a> and <a href="varbas.html#tolwfr">tolwfr</a>
are aimed at the same goal (causing the SCF cycle to stop),
one and only one of these must be specified.
This tolerance applies to any particular cartesian
component of any atom, INCLUDING fixed ones.
This is to be used when trying to equilibrate a
structure to its lowest energy configuration (<a href="varrlx.html#ionmov">ionmov</a>=2),
or in case of molecular dynamics (<a href="varrlx.html#ionmov">ionmov</a>=1)
<br>A value ten times smaller
than <a href="varrlx.html#tolmxf">tolmxf</a> is suggested (for example 5.0d-6 hartree/Bohr).
<br>This stopping criterion is not allowed for RF calculations.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="tolrff">tolrff</a></font>
<br><font id="definition">Mnemonics: TOLerance on the Relative diFference of Forces </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0.0 (stopping condition ignored)</font>
<br><br><font id="text">Sets a tolerance for the ratio of differences of forces
(in hartree/Bohr) to maximum force, that, reached TWICE successively,
will cause one SCF cycle to stop (and ions to be moved) : diffor < tolrff * maxfor.
<br>If set to zero, this stopping condition is ignored.
<br>Effective only when SCF cycles are done (<a href="varbas.html#iscf">iscf</a>>0).
In this case, since <a href="varbas.html#toldfe">toldfe</a>,
<a href="varbas.html#toldff">toldff</a>, <b>tolrff</b>,
<a href="varbas.html#tolvrs">tolvrs</a> and <a href="varbas.html#tolwfr">tolwfr</a>
are aimed at the same goal (causing the SCF cycle to stop),
one and only one of these must be specified.
This tolerance applies to any particular cartesian
component of any atom, INCLUDING fixed ones.
This is to be used when trying to equilibrate a
structure to its lowest energy configuration (<a href="varrlx.html#ionmov">ionmov</a>=2),
or in case of molecular dynamics (<a href="varrlx.html#ionmov">ionmov</a>=1)
<br>A value of 0.02 is suggested.
<br>This stopping criterion is not allowed for RF calculations.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="tolvrs">tolvrs</a></font>
<br><font id="definition">Mnemonics: TOLerance on the potential V(r) ReSidual </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0.0 (stopping condition ignored)</font>
<br><br><font id="text">Sets a tolerance for potential
residual that, when reached, will cause one SCF cycle
to stop (and ions to be moved).
<br>If set to zero, this stopping condition is ignored.
<br>Effective only when SCF cycles are done (<a href="varbas.html#iscf">iscf</a>>0).
In this case, since <a href="varbas.html#toldfe">toldfe</a>, <a href="varbas.html#toldff">toldff</a>,
<a href="varbas.html#tolrff">tolrff</a>,
<b>tolvrs</b> and <a href="varbas.html#tolwfr">tolwfr</a>
are aimed at the same goal (causing the SCF cycle to stop),
one and only one of these must be specified.
<br>To get accurate stresses may be quite demanding.
<p>Additional explanation : the residual of the potential is the difference between the
input potential and the output potential, when the latter is obtained from the density
determined from the eigenfunctions of the input potential. When the self-consistency
loop is achieved, both input and output potentials must be equal, and the residual
of the potential must be zero. The tolerance on the
potential residual is imposed by first subtracting the mean of the residual of the potential
(or the trace of the potential matrix, if the system is spin-polarized),
then summing the square of this function over all FFT grid points. The result should be
lower than <b>tolvrs</b>.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="tolwfr">tolwfr</a></font>
<br><font id="definition">Mnemonics: TOLerance on WaveFunction squared Residual </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 0.0d0 (stopping criterion ignored)</font>
<br><br><font id="text">The signification of this tolerance depends on
      the basis set. In plane waves, it gives a convergence tolerance for the
largest squared "residual" (defined below) for any
given band.  The squared residual is:<br>
<pre>
  &lt; nk|(H-E)<sup>2</sup>|nk &gt;,    E = &lt; nk|H|nk &gt;
</pre>
<br>which clearly is nonnegative and goes to 0 as
the iterations converge to an eigenstate.
With the squared residual expressed in
Hartrees<sup>2</sup> (Hartrees squared), the largest squared
residual (called residm) encountered over all bands
and k points must be less than <b>tolwfr</b> for iterations
to halt due to successful convergence.
<br>Note that if <a href="varbas.html#iscf">iscf</a>>0, this criterion should be replaced
by those based on <a href="varbas.html#toldfe">toldfe</a> (preferred for <a href="varrlx.html#ionmov">ionmov</a>==0),
<a href="varbas.html#toldff">toldff</a>
<a href="varbas.html#tolrff">tolrff</a> (preferred for <a href="varrlx.html#ionmov">ionmov</a>/=0), or
<a href="varbas.html#tolvrs">tolvrs</a> (preferred for theoretical reasons!).
<br>When <b>tolwfr</b> is 0.0, this criterion is ignored,
and a finite value of <a href="varbas.html#toldfe">toldfe</a>, <a href="varbas.html#toldff">toldff</a>
or <a href="varbas.html#tolvrs">tolvrs</a> must be specified.
This also imposes a restriction
on taking an ion step; ion steps are not permitted
unless the largest squared residual is less than
<b>tolwfr</b>, ensuring accurate forces.
<br>To get accurate stresses may be quite demanding.
<br>
Note that the preparatory GS calculations
before a RF calculations must be highly converged.
<br>Typical values for these preparatory runs are <b>tolwfr</b>
between 1.0d-16 and 1.0d-22.
<p> Note that <b>tolwfr</b> is often used in the test cases, but this is
<em>tolwfr</em> purely for historical reasons :
except when <a href="varbas.html#iscf">iscf</a>&lt;0, other critera
	should be used.</p>
<p>In the wavelet case (see <a href="varbas.html#usewvl">usewvl</a> =
	1), this criterion is the favoured one. It is based on the
	norm 2 of the gradient of the wavefunctions. Typical values
	range from 5*10<sup>-4</sup> to 5*10<sup>-5</sup>.</p>
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="typat">typat</a></font>
<br><font id="definition">Mnemonics: TYPE of atoms </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array typat(<a href="varbas.html#natom">natom</a>)
(or : typat(<a href="vargeo.html#natrd">natrd</a>) ,
if the geometry builder is used)
 </font>
<br><font id="default">Default is 1 (for <a href="varbas.html#natom">natom</a>=1)</font>
<br><br><font id="text">Array giving an integer label to every atom in the unit
cell to denote its type. <br>The different types of atoms
are constructed from the pseudopotential files.
There are at most <a href="varbas.html#ntypat">ntypat</a> types of atoms.
<br> As an example, for BaTiO3, where the pseudopotential for Ba is number 1,
the one of Ti is number 2, and the one of O is number 3, the actual
value of the <b>typat</b> array might be :
<pre>
  typat 1 2 3 3 3
</pre>
<br>The array <b>typat</b> has to agree with the actual locations
of atoms given in <a href="varbas.html#xred">xred</a> , <a href="varbas.html#xcart">xcart</a> or
<a href="varbas.html#xangst">xangst</a>, and the input
of pseudopotentials has to be ordered to agree with the
atoms identified in <b>typat</b>.
<br>The nuclear charge of the
elements, given by the array <a href="varbas.html#znucl">znucl</a>, also must agree with
the type of atoms designated in "<b>typat</b>".
<br>The array <b>typat</b> is
not constrained to be increasing. An
internal representation of the list of atoms,
deep in the code (array atindx), groups the atoms of same type
together. This should be transparent to the
user, while keeping efficiency.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="udtset">udtset</a></font>
<br><font id="definition">Mnemonics: Upper limit on DaTa SETs </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array udtset(2)</font>
<br><font id="default">Default is No Default (since it is not used when it is not defined).</font>
<br><br><font id="text">Used to define the set of indices in the multi-data set
mode, when a double loop is needed (see later).
<br>The values of <b>udtset</b> must be between 1 and 9, and their
product must be equal to <a href="varbas.html#ndtset">ndtset</a>.
<br>If <b>udtset</b> is used, the input variable <a href="varbas.html#jdtset">jdtset</a> cannot be used.</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="usewvl">usewvl</a></font>
<br><font id="definition">Mnemonics: Use WaVeLet basis set </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer (0 or 1)</font>
<br><font id="default">Default is 0 (use plane-wave basis set).</font>
<br><br><font id="text">Used to define if the calculation is done on a
      wavelet basis set or not.
<br>The values of <b>usewvl</b> must be 0 or 1. Putting <b>usewvl</b>
      to 1, makes <a href="vargs.html#icoulomb">icoulomb</a>
      mandatory to 1. The number of band (<a
	href="varbas.html#nband">nband</a>) must be set manually to
      the strict number need for an isolator system (<i>i.e.</i>
      number of electron over two). The cut-off is not relevant in the
      wavelet case, use <a href="varbas.html#wvl_hgrid">wvl_hgrid</a>
      instead.
<br>In wavelet case, the system must be isolated systems (molecules or
      clusters). All geometry optimization are available (see <a
	href="varbas.html#ionmov">ionmov</a>, especially the geometry
      optimisation and the molecular dynamics.
<br>The spin computation is not currently possible with wavelets and
      metalic systems may be slow to converge.
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="wtk">wtk</a></font>
<br><font id="definition">Mnemonics: WeighTs for K points </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real array wtk(<a href="varbas.html#nkpt">nkpt</a>)  </font>
<br><font id="default">Default is <a href="varbas.html#nkpt">nkpt</a>*1.0d0 .</font>
<br><br><font id="text">Gives the k point weights.  <br>The
k point weights will have their sum normalized to 1
(unless <a href="varbas.html#occopt">occopt</a>=2; see description of <a href="varbas.html#occopt">occopt</a>)
within the program and therefore may be input with any
arbitrary normalization.  This feature helps avoid the
need for many digits in representing fractional weights
such as 1/3.
<br><b>wtk</b> is ignored if <a href="varbas.html#iscf">iscf</a> is not positive,
except if <a href="varbas.html#iscf">iscf</a>=-3.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="wvl_hgrid">wvl_hgrid</a></font>
<br><font id="definition">Mnemonics: WaVeLet H step GRID </font>
<br><font id="category">Characteristic: LENGTH  </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.5d0 .</font>
<br><br><font id="text">It gives the step size in real space for the
      grid resolution in the wavelet basis set. This value is highly
      responsible for the memory occupation in the wavelet
      computation. The value is a length in atomic units.
</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="xangst">xangst</a></font>
<br><font id="definition">Mnemonics: vectors (X) of atom positions
   in cartesian coordinates -length in ANGSTrom-  </font>
<br><font id="category">Characteristic: NOT INTERNAL </font>
<br><font id="vartype">Variable type: real array xangst(3,<a href="varbas.html#natom">natom</a>)
(or xangst(3,<a href="vargeo.html#natrd">natrd</a>) if the geometry builder is used)
 </font>
<br><br><font id="text">
Gives the cartesian coordinates
of atoms within unit cell, in angstrom.  This information is
redundant with that supplied by array <a href="varbas.html#xred">xred</a> or <a href="varbas.html#xcart">xcart</a>.
<br>If <a href="varbas.html#xred">xred</a> and <b>xangst</b> are ABSENT from the input file and
<a href="varbas.html#xcart">xcart</a> is
provided, then the values of <a href="varbas.html#xred">xred</a> will be computed from
the provided <a href="varbas.html#xcart">xcart</a> (i.e. the user may use xangst instead
of <a href="varbas.html#xred">xred</a> or <a href="varbas.html#xcart">xcart</a> to provide starting coordinates).
<br>One and only one of <a href="varbas.html#xred">xred</a>, <a href="varbas.html#xcart">xcart</a>
and <b>xangst</b> must be provided.
<br>The conversion factor between Bohr and Angstrom
is 1 Bohr=0.5291772108 Angstrom, see the <a href="http://physics.nist.gov/cuu/Constants/index.html">NIST site</a>.
<br>Atomic positions evolve if <a href="varrlx.html#ionmov">ionmov</a>/=0 .
In constrast with <a href="varbas.html#xred">xred</a> and
<a href="varbas.html#xcart">xcart</a>, <b>xangst</b> is not internal.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="xcart">xcart</a></font>
<br><font id="definition">Mnemonics: vectors (X) of atom positions in CARTesian coordinates  </font>
<br><font id="category">Characteristic: EVOLVING, LENGTH </font>
<br><font id="vartype">Variable type: real array xcart(3,<a href="varbas.html#natom">natom</a>)
(or xcart(3,<a href="vargeo.html#natrd">natrd</a>) if the geometry builder is used)
 </font>
<br><br><font id="text">Gives the cartesian coordinates
of atoms within unit cell.  This information is
redundant with that supplied by array <a href="varbas.html#xred">xred</a> or <a href="varbas.html#xangst">xangst</a>.
By default, <b>xcart</b> is given in Bohr atomic units
(1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
if preferred, since <b>xcart</b> has the
'<a href="../users/abinis_help.html#dimensions">LENGTH</a>' characteristics.
<br>If <a href="varbas.html#xred">xred</a> and <a href="varbas.html#xangst">xangst</a> are
ABSENT from the input file and <b>xcart</b> is
provided, then the values of <a href="varbas.html#xred">xred</a> will be computed from
the provided <b>xcart</b> (i.e. the user may use <b>xcart</b> instead
of <a href="varbas.html#xred">xred</a> or <a href="varbas.html#xangst">xangst</a> to provide starting coordinates).
<br>One and only one of <a href="varbas.html#xred">xred</a>, <a href="varbas.html#xcart">xcart</a>
and <b>xangst</b> must be provided.
<br>Atomic positions evolve if <a href="varrlx.html#ionmov">ionmov</a>/=0 .</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="xred">xred</a></font>
<br><font id="definition">Mnemonics: vectors (X) of atom positions in REDuced coordinates  </font>
<br><font id="category">Characteristic: EVOLVING </font>
<br><font id="vartype">Variable type: real array xred(3,<a href="varbas.html#natom">natom</a>)
(or xred(3,<a href="vargeo.html#natrd">natrd</a>) if the geometry builder is used)
 </font>
<br><font id="default">Default is all 0.0d0</font>
<br><br><font id="text">
Gives the atomic locations within
unit cell in coordinates relative to real space primitive
translations (NOT in cartesian coordinates).  Thus these
are fractional numbers typically between 0 and 1 and
are dimensionless.  The cartesian coordinates of atoms
are given by:<br>
<tele>  t_cartesian = t1*r1*a1+t2*r2*a2+t3*r3*a3</tele><br>
where (t1,t2,t3) are the "reduced coordinates" given in
columns of "<b>xred</b>", (r1,r2,r3) are the columns of
dimensionless array "<a href="varbas.html#rprim">rprim</a>", and (a1,a2,a3) are the
elements of the array "<a href="varbas.html#acell">acell</a>" giving length scales in Bohr.
<br>If you prefer to work only with cartesian coordinates, you
may work entirely with "<a href="varbas.html#xcart">xcart</a>" or "<a href="varbas.html#xangst">xangst</a>" and ignore <b>xred</b>, in
which case <b>xred</b> must be absent from the input file.
<br>One and only one of <a href="varbas.html#xred">xred</a>, <a href="varbas.html#xcart">xcart</a>
and <b>xangst</b> must be provided.
<br>Atomic positions evolve if <a href="varrlx.html#ionmov">ionmov</a>/=0 .</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="znucl">znucl</a></font>
<br><font id="definition">Mnemonics: charge -Z- of the NUCLeus </font>
<br><font id="category">Characteristic: NO MULTI  </font>
<br><font id="vartype">Variable type: real array znucl(<a href="vargs.html#npsp">npsp</a>)  </font>
<br><br><font id="text">Gives nuclear charge for each
type of pseudopotential, in order.
<br>If <b>znucl</b> does not agree with nuclear charge,
as given in pseudopotential files, the program writes
an error message and stops.
<p>N.B. : In the pseudopotential files, <b>znucl</b> is called "zatom".
<p>For a "dummy" atom, with znucl=0 , as used in the case of calculations 
with only a jellium surface, ABINIT sets arbitrarily the covalent radius to one.
</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

Goto :
<A href="http://www.abinit.org"><B>ABINIT home Page</B></A>
<B> | </B>
<A href="../users/acknowledgments.html"><B>Suggested acknowledgments</B></A>
<B> | </B>
<A href="keyhr.html"><B>List of input variables</B></A>
<B> | </B>
<A href="../tutorial/welcome.html"><B>Tutorial home page</B></A>
<B> | </B>
<A href="../users/bibliography.html"><B>Bibliography</B></A>
<HR ALIGN=left>
Help files :
<A href="../users/new_user_guide.html"><B>New user's guide</B></A>
<B> | </B>
<A href="../users/abinis_help.html"><B>Abinis (main)</B></A>
<B> | </B>
<A href="../users/respfn_help.html"><B>Abinis (respfn)</B></A>
<B> | </B>
<A href="../users/mrgddb_help.html"><B>Mrgddb</B></A>
<B> | </B>
<A href="../users/anaddb_help.html"><B>Anaddb</B></A>
<B> | </B>
<A href="../users/aim_help.html"><B>AIM (Bader)</B></A>
<B> | </B>
<A href="../users/cut3d_help.html"><B>Cut3D</B></A>
<B> | </B>
<A href="../users/optic_help.html"><B>Optic</B></A>
<B> | </B>
<A href="../users/mrgscr_help.html"><B>Mrgscr</B></A>
<HR ALIGN=left>

</body>
</html>

