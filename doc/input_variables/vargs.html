<html>
<head><title>ABINIT : GROUND-STATE CALCULATION input variables.</title>
<link rel=stylesheet type="text/css" href="formabinit.css">
</head>
<body bgcolor="#ffffff">

<hr>
<a name="top"></a>

<h1>ABINIT, ground-state calculation variables:</h1>
<h2>List and description.</h2>

<hr>

<p>This document lists and provides the description
of the name (keywords) of all files handling input
variables to be used in the main input file of the abinis code.

<p>The new user is advised to read first the
  <a href="../users/new_user_guide.html">new user's guide</a>,
  before reading the present file. It will be easier to discover the
  present file with the help of the <a href="../tutorial/welcome.html">tutorial</a>.

<p>When the user is sufficiently familiarized with ABINIT, the reading of the
  ~abinit/doc/users/tuning file might be useful. For response-function calculations using
  abinis, please read <a href="../users/respfn_help.html">the response function help file</a>

<h5>Copyright (C) 1998-2008 ABINIT group (DCA, XG, RC)
<br> This file is distributed under the terms of the GNU General Public License, see
~abinit/COPYING or <a href="http://www.gnu.org/copyleft/gpl.txt">
http://www.gnu.org/copyleft/gpl.txt </a>.
<br> For the initials of contributors, see ~abinit/doc/developers/contributors.txt .
</h5>

<HR ALIGN=left>
Goto :
<A href="http://www.abinit.org"><B>ABINIT home Page</B></A>
<B> | </B>
<A href="../users/acknowledgments.html"><B>Suggested acknowledgments</B></A>
<B> | </B>
<A href="keyhr.html"><B>List of input variables</B></A>
<B> | </B>
<A href="../tutorial/welcome.html"><B>Tutorial home page</B></A>
<B> | </B>
<A href="../users/bibliography.html"><B>Bibliography</B></A>
<HR ALIGN=left>
Help files :
<A href="../users/new_user_guide.html"><B>New user's guide</B></A>
<B> | </B>
<A href="../users/abinis_help.html"><B>Abinis (main)</B></A>
<B> | </B>
<A href="../users/respfn_help.html"><B>Abinis (respfn)</B></A>
<B> | </B>
<A href="../users/mrgddb_help.html"><B>Mrgddb</B></A>
<B> | </B>
<A href="../users/anaddb_help.html"><B>Anaddb</B></A>
<B> | </B>
<A href="../users/aim_help.html"><B>AIM (Bader)</B></A>
<B> | </B>
<A href="../users/cut3d_help.html"><B>Cut3D</B></A>
<B> | </B>
<A href="../users/optic_help.html"><B>Optic</B></A>
<B> | </B>
<A href="../users/mrgscr_help.html"><B>Mrgscr</B></A>
<HR ALIGN=left>


Files that describe other input variables:<br>
<ul>
<li> Basic variables, <A href="varbas.html">VARBAS</a></li>
<li> Developper variables, <A href="vardev.html">VARDEV</a></li>
<li> Files handling variables, <A href="varfil.html">VARFIL</a></li>
<li> Geometry builder + symmetry related variables, <A href="vargeo.html">VARGEO</a></li>
<li> GW variables, <A href="vargw.html">VARGW</a></li>
<li> Internal variables, <A href="varint.html">VARINT</a></li>
<li> Parallelisation variables, <A href="varpar.html">VARPAR</a></li>
<li> Projector-Augmented Wave variables, <A href="varpaw.html">VARPAW</a></li>
<li> Response Function variables, <A href="varrf.html">VARRF</a></li>
<li> Structure optimization variables, <A href="varrlx.html">VARRLX</a></li>
<li> Wannier90 interface variables, <A href="varw90.html">VARW90</a></li>
</ul>
<hr>

<h3><b> Content of the file : alphabetical list of variables.</b></h3>
 <br>A.
 <a href="vargs.html#algalch">algalch</a>&nbsp;&nbsp;
 <br>B.
 <a href="vargs.html#bdberry">bdberry</a>&nbsp;&nbsp;
 <a href="vargs.html#berryopt">berryopt</a>&nbsp;&nbsp;
 <a href="vargs.html#boxcenter">boxcenter</a>&nbsp;&nbsp;
 <a href="vargs.html#boxcutmin">boxcutmin</a>&nbsp;&nbsp;
 <br>C.
 <a href="vargs.html#chkexit">chkexit</a>&nbsp;&nbsp;
 <a href="vargs.html#chkprim">chkprim</a>&nbsp;&nbsp;
 <a href="vargs.html#cpu">cpus, cpum, cpuh</a>&nbsp;&nbsp;
 <br>D.
 <a href="vargs.html#diecut">diecut</a>&nbsp;&nbsp;
 <a href="vargs.html#diegap">diegap</a>&nbsp;&nbsp;
 <a href="vargs.html#dielam">dielam</a>&nbsp;&nbsp;
 <a href="vargs.html#dielng">dielng</a>&nbsp;&nbsp;
 <a href="vargs.html#diemac">diemac</a>&nbsp;&nbsp;
 <a href="vargs.html#diemix">diemix</a>&nbsp;&nbsp;
 <a href="vargs.html#dosdeltae">dosdeltae</a>&nbsp;&nbsp;
 <br>E.
 <a href="vargs.html#efield">efield</a>&nbsp;&nbsp;
 <a href="vargs.html#enunit">enunit</a>&nbsp;&nbsp;
 <br>F.
 <a href="vargs.html#fband">fband</a>&nbsp;&nbsp;
 <a href="vargs.html#fixmom">fixmom</a>&nbsp;&nbsp;
 <br>G.
 <br>H.
 <br>I.
 <a href="vargs.html#iatsph">iatsph</a>&nbsp;&nbsp;
 <a href="vargs.html#icoulomb">icoulomb</a>&nbsp;&nbsp;
 <a href="vargs.html#iprcel">iprcel</a>&nbsp;&nbsp;
 <a href="vargs.html#iprctfvw">iprctfvw</a>&nbsp;&nbsp;
 <a href="vargs.html#ixcpositron">ixcpositron</a>&nbsp;&nbsp;
 <br>J.
 <a href="vargs.html#jellslab">jellslab</a>&nbsp;&nbsp;
 <br>K.
 <a href="vargs.html#kberry">kberry</a>&nbsp;&nbsp;
 <a href="vargs.html#kptbounds">kptbounds</a>&nbsp;&nbsp;
 <a href="vargs.html#kptrlatt">kptrlatt</a>&nbsp;&nbsp;
 <a href="vargs.html#kptrlen">kptrlen</a>&nbsp;&nbsp;
 <br>L.
 <br>M.
 <a href="vargs.html#mixalch">mixalch</a>&nbsp;&nbsp;
 <br>N.
 <a href="vargs.html#natsph">natsph</a>&nbsp;&nbsp;
 <a href="vargs.html#nberry">nberry</a>&nbsp;&nbsp;
 <a href="vargs.html#nbdbuf">nbdbuf</a>&nbsp;&nbsp;
 <a href="vargs.html#ndivk">ndivk</a>&nbsp;&nbsp;
 <a href="vargs.html#ndivsm">ndism</a>&nbsp;&nbsp;
 <a href="vargs.html#ngfft">ngfft</a>&nbsp;&nbsp;
 <a href="vargs.html#nline">nline</a>&nbsp;&nbsp;
 <a href="vargs.html#npsp">npsp</a>&nbsp;&nbsp;
 %<a href="vargs.html#npspalch">npspalch</a>&nbsp;&nbsp;
 <a href="vargs.html#nqpt">nqpt</a>&nbsp;&nbsp;
 <a href="vargs.html#nspden">nspden</a>&nbsp;&nbsp;
 <a href="vargs.html#nspinor">nspinor</a>&nbsp;&nbsp;
 <a href="vargs.html#ntypalch">ntypalch</a>&nbsp;&nbsp;
 %<a href="vargs.html#ntyppure">ntyppure</a>&nbsp;&nbsp;
 <a href="vargs.html#nwfshist">nwfshist</a>&nbsp;&nbsp;
 <br>O.
 <a href="vargs.html#occ">occ</a>&nbsp;&nbsp;
 <a href="vargs.html#optdriver">optdriver</a>&nbsp;&nbsp;
 <a href="vargs.html#optstress">optstress</a>&nbsp;&nbsp;
 <br>P.
 <a href="vargs.html#prtdensph">prtdensph</a>&nbsp;&nbsp;
 <a href="vargs.html#positron">positron</a>&nbsp;&nbsp;
 <br>Q.
 <a href="vargs.html#qpt">qpt</a>&nbsp;&nbsp;
 <a href="vargs.html#qptnrm">qptnrm</a>&nbsp;&nbsp;
 <br>R.
 <a href="vargs.html#ratsph">ratsph</a>&nbsp;&nbsp;
 <br>S.
 <a href="vargs.html#slabwsrad">slabwsrad</a>&nbsp;&nbsp;
 <a href="vargs.html#slabzbeg">slabzbeg</a>&nbsp;&nbsp;
 <a href="vargs.html#slabzend">slabzend</a>&nbsp;&nbsp;
 <a href="vargs.html#so_psp">so_psp</a>&nbsp;&nbsp;
 <a href="vargs.html#spinat">spinat</a>&nbsp;&nbsp;
 <a href="vargs.html#stmbias">stmbias</a>&nbsp;&nbsp;
 <a href="vargs.html#symafm">symafm</a>&nbsp;&nbsp;
 <br>T.
 <a href="vargs.html#timopt">timopt</a>&nbsp;&nbsp;
 <a href="vargs.html#tl_radius">tl_radius</a>&nbsp;&nbsp;
 <a href="vargs.html#tl_nprccg">tl_nprccg</a>&nbsp;&nbsp;
 <a href="vargs.html#tphysel">tphysel</a>&nbsp;&nbsp;
 <a href="vargs.html#tsmear">tsmear</a>&nbsp;&nbsp;
 <br>U.
 <br>V.
 <a href="vargs.html#vacuum">vacuum</a>&nbsp;&nbsp;
 <a href="vargs.html#vacwidth">vacwidth</a>&nbsp;&nbsp;
 <br>W.
 <a href="vargs.html#wvl_crmult">wvl_crmult</a>&nbsp;&nbsp;
 <a href="vargs.html#wvl_cpmult">wvl_cpmult</a>&nbsp;&nbsp;
 <a href="vargs.html#wvl_frmult">wvl_frmult</a>&nbsp;&nbsp;
 <a href="vargs.html#wvl_fpmult">wvl_fpmult</a>&nbsp;&nbsp;
 <a href="vargs.html#wvl_nprccg">wvl_nprccg</a>&nbsp;&nbsp;
 <br>X.
 %<a href="vargs.html#xclevel">xclevel</a>&nbsp;&nbsp;
 <br>Y.
 <br>Z.

<br><br><br><br><hr>

<font id="title"><a name="algalch">algalch</a></font>
<br><font id="definition">Mnemonics: ALGorithm for generating ALCHemical pseudopotentials</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array
 algalch(<a href="vargs.html#ntypalch">ntypalch</a>)  </font>
<br><font id="default">Default is 1 for all indices</font>
<br><br><font id="text">
<p> Used for the generation of alchemical pseudopotentials, that is,
when <a href="vargs.html#ntypalch">ntypalch</a> is non-zero.
<p>Give the algorithm to be used to
generate the <a href="vargs.html#ntypalch">ntypalch</a> alchemical potentials
from the different <a href="vargs.html#npspalch">npspalch</a> pseudopotentials
dedicated to this use.
<p> Presently, <b>algalch</b> can only have the value 1, that is :
<ul>
 <li>the local potentials are mixed, thanks to the <a href="vargs.html#mixalch">mixalch</a>
   mixing coefficients</li>
 <li>the form factors of the non-local projectors are all preserved, and all considered
   to generate the alchemical potential</li>
 <li>the scalar coefficients of the non-local projectors are multiplied by the proportion
   of the corresponding type of atom that is present in <a href="vargs.html#mixalch">mixalch</a></li>
 <li>the characteristic radius for the core charge is a
    linear combination of the characteristic radii of the core charges,
    build with the <a href="vargs.html#mixalch">mixalch</a> mixing
    coefficients</li>
 <li>the core charge function f(r/rc) is a linear combination
    of the core charge functions, build with the <a href="vargs.html#mixalch">mixalch</a>
    mixing coefficients</li>
</ul>
Later, other algorithms for the mixing might be included.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="bdberry">bdberry</a></font>
<br><font id="definition">Mnemonics: BanD limits for BERRY phase </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array bdberry(4)  </font>
<br><font id="default">Default is 4*0.</font>
<br><br><font id="text">
<p> Used for non-zero values of <a href="vargs.html#berryopt">berryopt</a>.
<p>Give the lower band and the upper band of the set of bands
for which the Berry phase must be computed.
Irrelevant if <a href="vargs.html#nberry">nberry</a> is not positive.
When <a href="varbas.html#nsppol">nsppol</a> is 1 (no spin-polarisation),
only the two first numbers, giving the lower and highest
bands, are significant. Their occupation number is assumed to be 2.
When <a href="varbas.html#nsppol">nsppol</a> is 2 (spin-polarized calculation),
the two first numbers give the lowest and highest
bands for spin up, and the third and fourth numbers
give the lowest and highest bands for spin down.
Their occupation number is assumed to be 1 .
<p> Presently, <b>bdband</b> MUST be initialized by the user
in case of Berry phase calculation: the above-mentioned
default will cause an early exit.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="berryopt">berryopt</a></font>
<br><font id="definition">Mnemonics: BERRY phase options </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer berryopt </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
Specifies the use of Berry phase for the computation
of either the Polarization, the derivatives with respect to the
wavevector, or finite electric field calculations.
<ul>
<li>0 => no computation of expressions relying on a Berry phase (default)</li>
<li>1 => the computation of Berry phases is activated (berryphase routine)</li>
<li>2 => the computation of derivatives with respect to the wavevector,
 thanks to the Berry phase finite-difference formula, is activated (uderiv routine)</li>
<li>3 => same as option 1 and 2 together </li>
<li>4 => finite electric field calculation (Ground state as well as phonon)</li>
<li>-1 => alternative computation of Berry phases (berryphase_new routine)</li>
<li>-2 => alternative computation of derivatives with respect to the wavevector,
 thanks to the Berry phase finite-difference formula (berryphase_new routine)</li>
<li>-3 => same as option -1 and -2 together </li>
</ul>
<p>
The other related input variables are :
<ul>
<li>in case of <b>berryopt</b>=1,2, or 3 : <a href="vargs.html#bdberry">bdberry</a>
and <a href="vargs.html#kberry">kberry</a>; also, <a href="vargs.html#nberry">nberry</a>
must be larger than 0;</li>
<li>in case of <b>berryopt</b>=-1,-2, or -3 : the variable
  <a href="varrf.html#rfdir">rfdir</a> must be used to specify the primitive
  vector along which the projection of the polarization or the ddk will be computed.
  For example if <b>berryopt</b>=1 and <a href="varrf.html#rfdir">rfdir</a>=1 0 0,
  the projection of the polarization along the reciprocal lattice vector
  G_1 is computed. In case <a href="varrf.html#rfdir">rfdir</a>=1 1 1,
  ABINIT computes the projection of P along G_1, G_2 and G_3 and transforms the results
  to cartesian coordinates;</li>
<li><a href="vargs.html#efield">efield</a>,
    <a href="varrf.html#rfdir">rfdir</a> in case of <b>berryopt</b>=4 ;</li>
</ul>
<p>
The cases <b>berryopt</b>=-1,-2,-3 and 4 have to be used with
<a href="varbas.html#nsppol">nsppol</a>=1,
<a href="vargs.html#nspinor">nspinor</a>=1, and
<a href="varbas.html#occopt">occopt</a>=1.
<p>
For a phonon calculation under a finite electric field, respect the following procedure.
<ul>
 <li>1. Run a scf ground-state calculation at zero electric field
       to get wavefunctions to initialize the ground-state calculation in finite electric fields.</li>
 <li>2. Run a scf ground-state calculation in finite electric field. The
       electric field is controlled by the input variable <a href="vargs.html#efield">efield</a>.
       <b>berryopt</b> should be 4.
       The input variable <a href="varbas.html#kptopt">kptopt</a> should be set to be 2.</li>
 <li>3. Based on the wave functions obtained in step (2), perform phonon
       calculation by setting <b>berryopt</b>=4, <a href="varbas.html#kptopt">kptopt</a>=3 and
       The same value of <a href="vargs.html#efield">efield</a> than in step 2.
       <a href="varbas.html#nsym">nsym</a> should be set to 1 currently but this restriction may be
       removed later . The other
       parameters are the same as phonon calculation at zero electric field.</li>
  <li>Note : the choice of k-point sampling N x N x N should be the same in the three runs
       and N should be an even number.
</ul>
<p>
At present, note that <b>berryopt</b>=4 is not compatible with non-zero <a href="varrlx.html#optcell">optcell</a>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="boxcenter">boxcenter</a></font><br>
<br><font id="definition">Mnemonics: BOX CENTER </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real array <b>boxcenter</b>(3) </font>
<br><font id="default">Default is 0.5 0.5 0.5 .</font>
<br><br><font id="text">
Defines the center of the box, in reduced coordinates.
At present, this information is only used in the case of
Time-Dependent DFT computation of the oscillator strength.
One must take boxcenter such as to be roughly the center of
the cluster or molecule. The default is sensible when
the vacuum surrounding the cluster or molecule has xred 0 or 1.
On the contrary, when the cluster or molecule is close to
the origin, it is better to take <b>boxcenter</b>=(0 0 0).
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="boxcutmin">boxcutmin</a></font><br>
<br><font id="definition">Mnemonics: BOX CUT-off MINimum </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real </font>
<br><font id="default">Default is 2.0 .</font>
<br><br><font id="text">
The box cut-off ratio is the ratio between the wavefunction plane wave sphere
radius, and the radius of the sphere that can be inserted in the
FFT box, in reciprocal space. In order for the density to be exact
(in the case of plane wave, not PAW), this ratio should be at least two.
If one uses a smaller ratio, one will gain speed, at the expense of accuracy.
In case of pure ground state calculation (e.g. for the determination
of geometries), this is sensible. However,
the wavefunctions that are obtained CANNOT be used for starting response function
calculation.
</font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="charge">charge</a></font>
<br><font id="definition">Mnemonics: CHARGE </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real number  </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Used to establish charge balance between
the number of electrons filling the bands and the
nominal <b>charge</b> associated with the atomic cores.
<br>The code adds up the number of valence electrons
provided by the pseudopotentials of each type
(call this "zval"), then add <b>charge</b>, to get the
number of electrons per unit cell,
<a href="varint.html#nelect">nelect</a>.
<br>
Then, if <a href="varbas.html#iscf">iscf</a> is positive,
the code adds up the band occupancies (given in
array <a href="vargs.html#occ">occ</a>) for all bands at each k point,
then multiplies
by the k point weight <a href="varbas.html#wtk">wtk</a> at each k point.
Call this sum "nelect_occ" (for the number of electrons
from occupation numbers).  It is then
required that:
<br>nelect_occ = nelect
<br>
To treat a neutral
system, which is desired in nearly all cases, one must
use <b>charge</b>=0.  To treat a system missing one electron
per unit cell, set <b>charge</b>=+1.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="chkexit">chkexit</a></font>
<br><font id="definition">Mnemonics: CHecK whether the user want to EXIT </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0 (before v5.3, it was 2 for sequential version of ABINIT,
1 for parallel version of ABINIT.)</font>
<br><br><font id="text">If <b>chkexit</b> is 1 or 2, ABINIT
will check whether the user wants to interrupt the run (using the keyword
"exit" on the top of the input file or creating a file
named "abinit.exit": see the
<a href="../users/abinis_help.html#chkexit">end of section 3.2</a> of abinis_help).
<p>
If <b>chkexit</b>=0, the check is not performed at all
<p>
If <b>chkexit</b>=1, the check is not performed frequently (after each SCF step)
<p>
If <b>chkexit</b>=2, the check is performed frequently
(after a few bands, at each k point)
<p>In all cases, the check is performed at most every 2 seconds of CPU time.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="chkprim">chkprim</a></font>
<br><font id="definition">Mnemonics: CHecK whether the cell is PRIMitive </font>
<br><font id="category">Characteristic: SYMMETRY FINDER </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 1.</font>
<br><br><font id="text">If the symmetry finder is used
(see <a href="varbas.html#nsym">nsym</a>), a non-zero
value of <b>chkprim</b> will make the code stop if a non-primitive
cell is used. If <b>chkprim</b>=0, a warning is issued, but the run
does not stop.
<p>If you are generating the atomic and cell geometry using
<a href="vargeo.html#spgroup">spgroup</a>, you might
generate a PRIMITIVE cell using
<a href="vargs.html#brvltt">brvltt</a>=-1 .
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="cpu">cpus, cpum, cpuh</a></font><br>
<br><font id="definition">Mnemonics: CPU time limit in: Seconds, Minutes, Hours   </font>
<br><font id="category">Characteristic: NO MULTI ; for cpum and cpuh : NO INTERNAL </font>
<br><font id="vartype">Variable type: real parameters  </font>
<br><font id="default">Default is 0.0d0.</font>
<br><br><font id="text">
One of these three real parameters can be
defined in the input file, to set up a CPU time limit.
When the job reaches that limit, it will try to end smoothly.
However, note that this might still take some time.
If the user want a firm CPU time limit, the present
parameter must be reduced sufficiently. Intuition
about the actual margin to be taken into account
should come with experience ...
<br>Note that only one of these three parameters can be defined
in a single input file.
A zero value has no action of the job.
<br>Internally, only <b>cpus</b> is used in the dtset array: adequate
conversion factors are used to generate it from <b>cpum</b> or
<b>cpuh</b>.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="diecut">diecut</a></font>
<br><font id="definition">Mnemonics: DIElectric matrix Energy CUToff </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 2.2d0 Ha.</font>
<br><br><font id="text">
Kinetic energy cutoff that controls the number
of planewaves used to represent the dielectric matrix:
<br>(1/2)[(2 Pi)*(Gmax)]<sup>2</sup>=<a href="varbas.html#ecut">ecut</a> for Gmax.
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>ecut</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
(1 Ha=27.2113845 eV)
<br>All planewaves inside this "basis sphere" centered
at G=0 are included in the basis.
This is useful only when <a href="vargs.html#iprcel">iprcel</a>>=21, which means that
a preconditioning scheme based on the dielectric matrix
is used.
<br>NOTE : a negative <b>diecut</b> will define the same dielectric
basis sphere as the corresponding positive value,
but the FFT grid will be identical to the one used
for the wavefunctions.
The much smaller FFT grid, used when <b>diecut</b> is positive,
gives exactly the same results.
<br>No meaning for RF calculations yet.</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="diegap">diegap</a></font><br>
<br><font id="definition">Mnemonics: DIElectric matrix GAP </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.1 Ha.</font>
<br><br><font id="text">
Gives a rough estimation of the dielectric gap
between the highest energy level computed in the run,
and the set of bands not represented.
Used to extrapolate dielectric matrix when <a href="vargs.html#iprcel">iprcel</a> >= 21.
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>ecut</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
(1 Ha=27.2113845 eV)
<br>No meaning for RF calculations yet.</font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="dielam">dielam</a></font><br>
<br><font id="definition">Mnemonics: DIElectric matrix LAMbda </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real parameter between 0 and 1 </font>
<br><font id="default">Default is 0.5 .</font>
<br><br><font id="text">
Gives the amount of occupied states with mean energy given by the
highest level computed in the run, included
in the extrapolation of the dielectric matrix.
Used when <a href="vargs.html#iprcel">iprcel</a> >= 21.
<br>No meaning for RF calculations yet.</font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="dielng">dielng</a></font>
<br><font id="definition">Mnemonics: model DIElectric screening LeNGth </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 1.0774841d0 (Bohr), for historical reasons.</font>
<br><br><font id="text">Used for screening length (in Bohr) of the model
dielectric function, diagonal in reciprocal space.
By default, given in Bohr atomic units
(1 Bohr=0.5291772108 Angstrom), although Angstrom can be specified,
if preferred, since <b>dielng</b> has the
'<a href="../users/abinis_help.html#dimensions">LENGTH</a>' characteristics.
<br>
This model dielectric function is as follows :
<pre>
             (     1        + <b>dielng</b><sup>2</sup> * K<sup>2</sup> )
diel(K)= --------------------------------------------
             ( 1/<a href="vargs.html#diemac">diemac</a> + <b>dielng</b><sup>2</sup> * K<sup>2</sup> ) * <a href="vargs.html#diemix">diemix</a>
</pre>
The inverse of this model dielectric function will be
applied to the residual, to give the preconditioned
change of potential. Right at K=0, diel(K) is imposed to be 1.
<p>If the preconditioning were perfect,
the change of potential would lead to an exceedingly fast solution
of the self-consistency problem (two or three steps).
The present model dielectric function is excellent for
rather homogeneous unit cells.
<br>When K->0 , it tends to the macroscopic dielectric
constant, eventually divided by the mixing factor <a href="vargs.html#diemix">diemix</a>.
<br>For metals, simply put <a href="vargs.html#diemac">diemac</a> to a very large value (10^6 is OK)
<br>The screening length <b>dielng</b> governs the length scale
to go from the macroscopic regime to the microscopic
regime, where it is known that the dielectric function
should tend to 1. It is on the order of 1 Bohr for
metals with medium density of states at the Fermi level,
like Molybdenum, and for Silicon. For metals with a
larger DOS at the Fermi level (like Iron),
the screening will be more effective, so that <b>dielng</b>
has to be decreased by a factor of 2-4.
<br>This works for GS and RF calculations. </font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="diemac">diemac</a></font>
<br><font id="definition">Mnemonics: model DIElectric MACroscopic constant </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 10<sup>6</sup> (metallic damping). </font>
<br><br><font id="text">
A rough knowledge of the macroscopic dielectric constant <b>diemac</b>
of the system is a useful help to speed-up the SCF procedure:
a model dielectric function,
see the keyword <a href="vargs.html#dielng">dielng</a>, is used for that
purpose.  It is especially
useful for speeding up the treatment of rather homogeneous unit cells.
<p>Some hint :
<br>The value of <b>diemac</b> should usually be bigger than 1.0d0,
on physical grounds.
<br>For metals, simply put <b>diemac</b> to a very large value (the default 10<sup>6</sup> is OK)
<br>For silicon, use 12.0 . A similar value is likely to work well for
 other semiconductors
<br>For wider gap insulators, use 2.0 ... 4.0
<br>For molecules in an otherwise empty big box, try 1.5 ... 3.0
<br>Systems that combine a highly polarisable part and some vacuum are rather
badly treated by the model dielectric function. One has to use the
"extrapolar" technique, activated by the  input variable
<a href="vargs.html#iprcel">iprcel</a>.
<br>In sufficiently homogeneous systems, you might have to experiment
a bit to find the best <b>diemac</b>. If you let <b>diemac</b>
to its default value, you might even never obtain the self-consistent convergence !
<br>For response function calculations, use the same
values as for GS. The improvement in speed can be considerable
for small (but non-zero) values of the wavevector.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="diemix">diemix</a></font>
<br><font id="definition">Mnemonics: model DIElectric MIXing factor </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 1.0 (norm-conserving psps) or 0.7 (PAW).</font>
<br><br><font id="text">Gives overall factor of the preconditioned
residual potential to be transferred in the SCF cycle.
<br>It should be between 0.0 and 1.0 .
<br>If the model dielectric function were perfect, <b>diemix</b>
should be 1.0 . By contrast, if the model dielectric function
does nothing (when <a href="vargs.html#diemac">diemac</a>=1.0d0 or <a href="vargs.html#dielng">dielng</a>
is larger than the
size of the cell), <b>diemix</b> can be used
to damp the amplifying factor inherent to the SCF loop.
<br>For molecules, a value on the order 0.5 or 0.33 is rather usual.
<br>When <a href="varbas.html#iscf">iscf</a>=3 or <a href="varbas.html#iscf">iscf</a>=5, <b>diemix</b>
is only important at the
few first iterations when anharmonic effects are important,
since these schemes compute their own mixing factor
for self-consistency.</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="dosdeltae">dosdeltae</a></font>
<br><font id="definition">Mnemonics: DOS Delta in Energy </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.0 .</font>
<br><br><font id="text">Defines the linear grid resolution (energy increment) to be used for the
computation of the Density-Of-States, when <a href="varfil.html#prtdos">prtdos</a>
is non-zero.
<br>If <b>dosdeltae</b> is set to zero (the default value), the actual
increment is 0.001 Ha if <a href="varfil.html#prtdos">prtdos</a>=1, and
the much smaller value 0.00005 Ha if <a href="varfil.html#prtdos">prtdos</a>=2.
This different default value arises because the <a href="varfil.html#prtdos">prtdos</a>=1 case,
based on a smearing technique, gives a quite smooth DOS, while the DOS from the
tetrahedron method, <a href="varfil.html#prtdos">prtdos</a>=2, is rapidly varying.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="efield">efield</a></font>
<br><font id="definition">Mnemonics: Electric FIELD </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real array efield(3)  </font>
<br><font id="default">Default is 3*0.0 .</font>
<br><br><font id="text">In case <a href="vargs.html#berryopt">berryopt</a>=4,
a finite electric field calculation is performed. The value
of this electric field, and its direction is determined by <b>efield</b>.
It must be given in atomic units (1 a.u. of electric field= 514220624373.482 V/m, see note below),
in cartesian coordinates.
<p>
References for the calculation under electric field (based on multi k point Berry phase) :
<ul>
 <li> Nunes and Vanderbilt, PRL 73, 712 (1994) : real-space version of the finite-field Hamiltonian </li>
 <li> Nunes and Gonze, PRB 63, 155107 (2001) : reciprocal-space version of the finite-field Hamiltonian
     (the one presently implemented), and extensive theoretical analysis </li>
 <li> Souza, Iniguez and Vanderbilt, PRL 89, 117602 (2003) : implementation of the finite-field Hamiltonian
      (reciprocal-space version)</li>
</ul>
See also Umari, Pasquarello, PRL 90, 027401 (2003).
<p>
The atomic unit of electric field strength is :
e_Cb/(4 pi eps0 a0**2), where e_Cb is the electronic charge in Coulomb (1.60217653e-19),
eps0 is the electric constant (8.854187817d-12 F/m), and a0 is the Bohr radius
in meter (0.5291772108e-10).
</font>

<br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="enunit">enunit</a></font>
<br><font id="definition">Mnemonics: ENergy UNITs </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0 (eigenvalues in hartree and phonon frequencies
in hartree and cm-1).</font>
<br><br><font id="text">Governs the units to be used for
output of eigenvalues (and eventual phonon frequencies)
<ul>
<li>0=>print eigenvalues in hartree;</li>
<li>1=>print eigenvalues in eV; </li>
<li>2=>print eigenvalues in both hartree and eV.  </li>
</ul>
If phonon frequencies are to be computed :
<ul>
<li>0=> phonon frequencies in Hartree and cm-1; </li>
<li>1=> phonon frequencies in eV and THz; </li>
<li>2=> phonon frequencies in hartree, eV, cm-1, Thz and Kelvin.</li>
</ul></font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="fband">fband</a></font>
<br><font id="definition">Mnemonics: Factor for the number of BANDs </font>
<br><font id="category">Characteristic: NO INTERNAL </font>
<br><font id="vartype">Variable type: real parameter, positive or zero  </font>
<br><font id="default">Default is 0.125 in case <a href="varbas.html#occopt">occopt</a>==1 (insulating case),
           0.500 for other values of <a
	href="varbas.html#occopt">occopt</a> (metallic case) and 0. in
      wavelet case. Not used
           in case <a href="varbas.html#occopt">occopt</a>==0 or 2.</font>
<br><br><font id="text">Governs the number of bands to be used in the code in the case
the parameter <a href="varbas.html#nband">nband</a> is not defined in the input file
(which means that <a href="varbas.html#occopt">occopt</a> is not equal to 0 or 2).
<p>In case <b>fband</b> is 0.0d0, the code computes from
the pseudopotential files and the geometry data
contained in the input file, the number of electrons
present in the system. Then, it computes the minimum
number of bands that can accomodate them, and use
that value for <a href="varbas.html#nband">nband</a>.
<br>In case <b>fband</b> differs from
zero, other bands will be added, just
larger than <b>fband</b> times the number of atoms.
This parameter is not echoed in the top of the main
output file, but only the parameter <a href="varbas.html#nband">nband</a> that it allowed
to compute. It is also not present in the dtset array (no internal).
<br>The default values are chosen such as to give naturally some
conduction bands. This improves the robustness of the code,
since this allows to identify lack of convergence coming from
(near-)degeneracies at the Fermi level. In the metallic
case, the number of bands generated might be too small
if the smearing factor is large. The occupation numbers
of the higher bands should be small enough such as to
neglect higher bands. It is difficult to automate
this, so a fixed default value has been chosen.</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="fixmom">fixmom</a></font>
<br><font id="definition">Mnemonics: FIX the magnetic MOMent </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is -99.99d0</font>
<br><br><font id="text">
This input variable is active only in the
<a href="varbas.html#nsppol">nsppol</a>=2 case.
If <b>fixmom</b> is not the "magic" value of -99.99d0, the
magnetic moment of the system will be fixed
to the value of <b>fixmom</b>.
Otherwise, the magnetic moment will be determined
self-consistently, by having the same spin up and spin down
Fermi energy.
<p>
Note : for the time being, only the spin down Fermi energy
is written out in the main output file. In the fixed
magnetic moment case, it differs from the
spin up Fermi energy.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="iatsph">iatsph</a></font>
<br><font id="definition">Mnemonics: Index for the ATomic SPHeres of the atom-projected density-of-states</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array iatsph(1:<a href="vargs.html#natsph">natsph</a>)  </font>
<br><font id="default">Default is 1, 2, ... <a href="vargs.html#natsph">natsph</a> </font>
<br><br><font id="text">
This input variable is active only in the
<a href="varfil.html#prtdos">prtdos</a>=3 case.
<br>It gives the number of the <a href="vargs.html#natsph">natsph</a> atoms around which the sphere
for atom-projected density-of-states will be build,
in the <a href="varfil.html#prtdos">prtdos</a>=3 case.
The radius of these spheres is given by <a href="vargs.html#ratsph">ratsph</a>.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="icoulomb">icoulomb</a></font>
<br><font id="definition">Mnemonics: Coulomb TReaTMenT</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
<p>Defines the type of computation used for Hartree potential, local part of pseudo-potential and ion-ion interaction:</p>
<ul>
 <li><b>icoulomb</b>=0 : usual reciprocal space computation, using 1 / g^2 for the Hartree potential and using Ewald correction. </li>
 <li><b>icoulomb</b>=1 : free boundary conditions are used when the Hartree potential is computed, real space expressions of pseudo-potentials are involved (restricted to GTH pseudo-potentials) and simple coulombian interaction gives the ion-ion energy. </li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="iprcel">iprcel</a></font>
<br><font id="definition">Mnemonics: Integer for PReConditioning of ELectron response </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Used when <a href="varbas.html#iscf">iscf</a>>0, to define the SCF preconditioning scheme.
Potential-based preconditioning schemes for the SCF loop
(electronic part) are still a subject of active research.
The present parameter (electronic part) describes the way the
change of potential is derived from the residual.
<br>The possible values of <b>iprcel</b> correspond to :
<ul>
<li>0 => model dielectric function described by <a href="vargs.html#diemac">diemac</a>,
<a href="vargs.html#dielng">dielng</a>
       and <a href="vargs.html#diemix">diemix</a>.</li>
<li>larger or equal to 21 => will compute the dielectric matrix
   according to <a href="vargs.html#diecut">diecut</a>, <a href="vargs.html#dielam">dielam</a>,
<a href="vargs.html#diegap">diegap</a>. This methodology is described in
P.-M. Anglade, X. Gonze, Phys. Rev. B 78, 045126 (2008).</li>
<li>Between 21 and 29 => for the first few steps
 uses the same as option 0 then compute RPA dielectric function,
 and use it as such.</li>
<li>Between 31 and 39 => for the first few steps
 uses the same as option 0 then compute RPA dielectric function,
 and use it, with the mixing factor <a href="vargs.html#diemix">diemix</a>.</li>
<li>Between 41 and 49 => compute the RPA dielectric matrix
 at the first step, and recompute it at a later step,
 and take into account the mixing factor <a href="vargs.html#diemix">diemix</a>.</li>
<li>Between 51 and 59 => same as between 41 and 49, but compute
 the RPA dielectric matrix by another mean</li>
<li>Between 61 and 69 => same as between 41 and 49, but compute
 the electronic dielectric matrix instead of the RPA one.</li>
<li>Between 71 and 78 => STILL UNDER DEVELOPMENT -- NOT USABLE ; Use the modified Kerker preconditioner with a real-space formulation (basic formulation is shown at <a href="vargs.html#dielng">dielng</a>). The dielectric matrix is approximated thanks to  <a href="vargs.html#diemac">diemac</a> and <a href="vargs.html#dielng">dielng</a>.  Note that <a href="vargs.html#diemix">diemix</a> is also used.  </li>
<li> 79 => STILL UNDER DEVELOPMENT -- NOT USABLE ; same as previous but with an alternate algorithm. </li>
<li> 141 to 169 => same as Between 41 and 69 (but, the dielectric matrix is also recomputed every iprcel modulo 10 step). </li>
</ul>
<br>

The computation of the dielectric matrix (for 0 [100]< <b>iprcel</b> < 70 [100]) is based on the  <b>extrapolar</b> approximation. This approximation can be tuned with <a href="vargs.html#diecut">diecut</a>, <a href="vargs.html#dielam">dielam</a>,
and <a href="vargs.html#diegap">diegap</a>. Yet its accuracy mainly depends on the number of conduction bands included in the system. Having 2 to 10 empty bands in the calculation is
usually enough (use <a href="varbas.html#nband">nband</a>).
<br>
<br>
NOTES:
<ul>

<li>The step at which the dielectric matrix is computed or
 recomputed is determined by modulo(<b>iprcel</b>,10). The recomputation happens
 just once in the calculation for <b>iprcel</b> < 100.
<li>For non-homogeneous relatively large cells <b>iprcel</b>=45
will likely give a large improvement over <b>iprcel</b>=0.
<li> For extremely large inhomogeneous cells where computation of the full dielectric matrix takes too many weeks, 70 < <b>iprcel</b> < 80 is advised.
<li>For <a href="varbas.html#nsppol">nsppol</a>=2 with metallic <a href="varbas.html#occopt">occopt</a>,
only <b>iprcel</b>=0 is allowed.
<li>No meaning for RF calculations yet.
<li> The exchange term in the full dielectric matrix diverges for vanishing densities.
Therefore the values of <b>iprcel</b> beyond 60 must not be used for cells containing vacuum,
unless ones computes this matrix for every step (<b>iprcel</b>=161).
</ul>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="iprctfvw">iprctfvw</a></font>
<br><font id="definition">Mnemonics: Integer for PReConditioning (of electron response) based on Thomas - Fermi - von Weizs&auml;cker approximations of the kinetic energy </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Used when <a href="varbas.html#iscf">iscf</a>>0, to use the TFvW preconditioner. This is still in an early DEVELOPMENT stage and is not usable as is.

<ul>
<li>0 => not TFvW preconditioning applied ; </li>
<li>1 => TFvW prc. is applied on the residuals left by other preconditioners ;</li>
<li>2 => Same as previously but with a linear response formulation of TFvW ; </li>
<li>3 => (starting at abinit 5.3.?) TFvW prc. is applied before any other preconditioner.</li>
</ul>

<br>For <a href="varbas.html#nsppol">nsppol</a> >=  2 only <b>iprcel</b>=0 is allowed.
<br>No meaning for RF calculations yet.
<br>Compatible only with potential mixing : <a href="varbas.html#iscf">iscf</a><10.

<p>
<br>References:
<ul>
 <li> D. Raczkowski, A Canning and L.W. Wang PRB 64 121101 (2001)</li>
</ul>
</p>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="ixcpositron">ixcpositron</a></font>
<br><font id="definition">Mnemonics: eXchange-Correlation for the electron-POSITRON interaction</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
Define the type of electron-positron correlation that is used in case
of a positron calculation (with non-zero value of <a href="vargs.html#positron">positron</a>).
<p>
<ul>
 <li><b>ixcpositron</b>=1 : Boronski and Nieminen parameterization of Arponen and Pajanne
electron-positron  gas energy data </li>
 <li><b>ixcpositron</b>=2 : Puska, Seitsonen and Nieminen parameterization of Arponen and Pajanne
electron-positron  gas energy data </li>
</ul>
<p>
References:
<ul>
 <li>J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).</li>
 <li>E. Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).</li>
 <li>M.J. Puska, A.P. Seitsonen, and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="jellslab">jellslab</a></font>
<br><font id="definition">Mnemonics: include a JELLium SLAB in the cell</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter   </font>
<br><font id="default">Default is 0 (no jellium slab).</font>
<br><br><font id="text">If set to 1, a slab of uniform positive background charge density,
that is, a jellium slab, is included in the calculation cell.
A portion of the unit cell is filled with such positive charge density distribution
which is equal to a bulk-mean value n<sub>bulk</sub> between two edges
and zero in the vacuum region if present.
<br>
For the sake of convenience the unit cell is supposed
to have the third crystal primitive lattice vector orthogonal
to the other ones so that the portion of the cell filled by the jellium slab can be defined through its edges along z.
<br>
The bulk-mean positive charge density is fixed by the input variable <a href="vargs.html#slabwsrad">slabwsrad</a>,
while the position of the slab edges along z is defined through
the input variables <a href="vargs.html#slabzbeg">slabzbeg</a> and <a href="vargs.html#slabzend">slabzend</a>.</font>


<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="kberry">kberry</a></font>
<br><font id="definition">Mnemonics: K wavevectors for BERRY phase computation </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array
 kberry(3,<a href="vargs.html#nberry">nberry</a>)  </font>
<br><font id="default">Default is an array of 0</font>
<br><br><font id="text">
<p>Used for non-zero values of <a href="vargs.html#berryopt">berryopt</a>.
<p>This array defines, for each Berry phase calculation
(the number of such calculations is defined by
<a href="vargs.html#nberry">nberry</a>), the
difference of wavevector between k points for which
the overlap matrix must be computed.
The polarisation vector will be projected
on the direction of that wavevector,
and the result of the computation will be the magnitude of this
projection.
Doing more than one wavevector, with different independent
direction, allows to find the full polarisation vector.
However, note that converged results need oriented grids,
denser along the difference wavevector than usual Monkhorst-Pack
grids.
<p> The difference of wavevector is computed in the coordinate
system defined by the k-points grid
(see <a href="varbas.html#ngkpt">ngkpt</a>
and <a href="vargs.html#kptrlatt">kptrlatt</a>), so that
the values of <b>kberry</b> are integers.
Of course, such a k point grid must exist, and all the
corresponding wavefunctions must be available, so that the
computation is allowed only when <a href="varbas.html#kptopt">kptopt</a>
is equal to 3. In order to save computing time, it is suggested
to make a preliminary calculation of the wavefunctions on the
irreducible part of the grid, with <a href="varbas.html#kptopt">kptopt</a>
equal to 1, and then use these converged wavefunctions
in the entire Brillouin zone, by reading them to initialize
the <a href="varbas.html#kptopt">kptopt</a>=3 computation.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="kptbounds">kptbounds</a></font>
<br><font id="definition">Mnemonics: K PoinTs BOUNDarieS </font>
<br><font id="category">Characteristic: NOT INTERNAL </font>
<br><font id="vartype">Variable type: real array
 kptbounds(3,abs(<a href="varbas.html#kptopt">kptopt</a>)+1)  </font>
<br><font id="default">Default is No Default</font>
<br><br><font id="text">
It is used to generate the circuit to be followed by the band structure,
when <a href="varbas.html#kptopt">kptopt</a> is negative (it is
not read if <a href="varbas.html#kptopt">kptopt</a> is zero or positive).

<p>There are abs(<a href="varbas.html#kptopt">kptopt</a>)
segments to be defined, each of which wich start from
the end point of the preceeding one. Thus,
the number of points to be input is
abs(<a href="varbas.html#kptopt">kptopt</a>)+1.
They form a circuit starting
at <b>kptbounds</b>(1:3,1)/<a href="varbas.html#kptnrm">kptnrm</a>
and ending at
<b>kptbounds</b>(1:3,abs(<a href="varbas.html#kptopt">kptopt</a>)+1)/<a href="varbas.html#kptnrm">kptnrm</a>.
The number of divisions of each segment can be defined either using the array <a href="vargs.html#ndivk">ndivk</a>
or the variable <a href="vargs.html#ndivsm">ndivsm</a> that just defines the number of divisions for the smallest segment
<p>As for <a href="varbas.html#kpt">kpt</a>, <b>kptbounds</b> is specified
using the primitive vectors in reciprocal space. If your Bravais lattice is simple,
then it should be quite easy to find the coordinates of the end points of the end points.
On the other hand, for centered, body-centered, face-centered, hexagonal, and rhombohedral
Bravais lattice,
the conversion might be more difficult. See the description of <a href="varbas.html#kpt">kpt</a>
for an explanation of how to convert data from the "conventional" cartesian coordinates to
the primitive vectors in the reciprocal space. In order to help a bit, we list below a series
of typical values, for the FCC, BCC, hexagonal and rhombohedral Bravais lattices. Note : all the data below
are given in dimensionless units ; they have to be rescaled by the actual lengths defined by the
<a href="varbas.html#acell">acell</a> values. However, <b>kptbounds</b> values can be used as such,
if the values of <a href="varbas.html#rprim">rprim</a> given below are adopted.

<p>A. <b>FCC lattice</b>
<p>Suppose the primitive vectors in real space are given by
<br><pre>
rprim   0 1 1    1 0 1    1 1 0
</pre>
or
<pre>
rprim   0 1/2 1/2    1/2 0 1/2    1/2 1/2 0
</pre>
(these two possibilities only differ by a scaling factor, irrelevant for the definition
 of the k points in the primitive vectors in reciprocal space).

Then, the reciprocal primitive vectors (in conventional cartesian coordinates) are
<pre>
(-1/2 1/2 1/2), (1/2 -1/2 1/2), (1/2 1/2 -1/2)
</pre>
or
<pre>
(-1/2 1/2 1/2), (1/2 -1/2 1/2), (1/2 1/2 -1/2)
</pre>
and, in both cases, the coordinates of several special points with respect to primitive vectors in reciprocal space are
<pre>
X (0   1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
X'(1/2 1/2 1  )   (conventional cartesian coordinate 1/2 1/2 0)  (an other instance of X, in another Brillouin zone)
L (1/2 0   0  )   (conventional cartesian coordinate 1/4 1/4 1/4)
W (1/4 1/2 3/4)   (conventional cartesian coordinate 1/2 1/4 0)
U (1/4 5/8 5/8)   (conventional cartesian coordinate 1/2 1/8 1/8)
K (3/8 3/8 3/4)   (conventional cartesian coordinate 3/8 3/8 0)
</pre>
Note that K is actually equivalent to U, by spatial and translational symmetry.
So, if you want to specify a typical circuit, the following might do the work :
L-Gamma-X-W-K,U-L-W-X-K,U-Gamma with
<br>
<pre>kptbounds  1/2 0 0  0 0 0  0 1/2 1/2  1/4 1/2 3/4  3/8 3/8 3/4  1/2 0 0   1/4 1/2 3/4  1/2 1/2 1  3/8 3/8 3/4  0 0 0</pre>
<p>
The lengths of segments (this information is useful to draw the band structure, with the correct relative
scale between special points)
can be found using
the conventional cartesian coordinates :
l(L-Gamma)=sqrt(3)/4=0.433... ;
l(Gamma-X)=1/2=0.5 ;
l(X-W)=1/4=0.25 ;
l(W-K)=sqrt(2)/8=0.177... ;
l(K-L)=sqrt(6)/8=0.306... ;
l(L-W)=sqrt(2)/4=0.354... ;
l(W-X)=1/4=0.25 ;
l(X-K)=sqrt(2)/8=0.177... ;
l(K-Gamma)=sqrt(2)/4=0.354...
<p>

<p>B. <b>BCC lattice</b>
<p>Suppose the primitive vectors in real space are given by
<br><pre>
rprim  -1 1 1    1 -1 1    1 1 -1
</pre>
(as for the FCC lattice, there is a scale invariance).
Then, the reciprocal primitive vectors (in conventional cartesian coordinates) are
(0 1/2 1/2), (1/2 0 1/2), and (1/2 1/2 0)
and the coordinates of several special points with respect to primitive vectors in reciprocal space are
<pre>
H (-1/2 1/2 1/2)   (conventional cartesian coordinate 1/2 0 0)
N ( 0   0   1/2)   (conventional cartesian coordinate 1/4 1/4 0)
P ( 1/4 1/4 1/4)   (conventional cartesian coordinate 1/4 1/4 1/4)
</pre>
So, if you want to specify a typical circuit, the following might do the work :
Gamma-H-N-Gamma-P-N-P-H
<br>
<pre>kptbounds  0 0 0  -1/2 1/2 1/2  0 0 1/2  0 0 0   1/4 1/4 1/4  0 0 1/2  1/4 1/4 1/4  -1/2 1/2 1/2 </pre>
<p>
The lengths of segments (this information is useful to draw the band structure, with the correct relative scale between special points)
can be found using the conventional cartesian coordinates :
l(Gamma-H)=1/2=0.5 ;
l(H-N)=sqrt(2)/4=0.354... ;
l(N-Gamma)=sqrt(2)/4=0.354... ;
l(Gamma-P)=sqrt(3)/4=0.433... ;
l(P-N)=1/4=0.25 ;
l(N-P)=1/4=0.25 ;
l(P-H)=sqrt(3)/4=0.433...
<p>

<p>C. <b>Hexagonal lattices</b>
<p>Suppose the primitive vectors in real space are given by
<br><pre>
rprim  1 0 0    -1/2 sqrt(0.75) 0    0 0 1
</pre>
The coordinates of several special points with respect to primitive vectors in reciprocal space are
<pre>
M (1/2 0 0) or (0 1/2 0) or (-1/2 1/2 0)
L (1/2 0 1/2) or (0 1/2 1/2) or (-1/2 1/2 1/2)
K (1/3 1/3 0) or (2/3 -1/3 0) or (-1/3 2/3 0)
H (1/3 1/3 1/2) or (2/3 -1/3 1/2) or (-1/3 2/3 1/2)
A (0 0 1/2)
</pre>
So, if you want to specify a typical circuit, the following might do the work :
K-Gamma-M-K-H-A-L-H-L-M-Gamma-A
<br>
<pre>kptbounds  1/3 1/3 0  0 0 0  1/2 0 0  1/3 1/3 0  1/3 1/3 1/2  0 0 1/2  1/2 0 1/2  1/3 1/3 1/2  1/2 0 1/2  1/2 0 0  0 0 0  0 0 1/2 </pre>
<p>
In order to find the lengths of segments
(this information is useful to draw the band structure,
with the correct relative scale between special points)
one needs to know the a and c lattice parameters. Also, in what follows, we omit the 2*pi factor sometimes
present in the definition of the reciprocal space vectors.
The reciprocal vectors are (1/a 1/(sqrt(3)*a) 0) , (0 2/(sqrt(3)*a) 0), (0 0 1/c). The lengths of
the above-mentioned segments can be computed as :
l(K-Gamma)=2/(3*a)=0.666.../a ;
l(Gamma-M)=1/(sqrt(3)*a)=0.577.../a ;
l(M-K)=1/(3*a)=0.333.../a ;
l(K-H)=1/(2*c)=0.5.../c ;
l(H-A)=2/(3*a)=0.666.../a ;
l(A-L)=1/(sqrt(3)*a)=0.577.../a ;
l(L-H)=1/(3*a)=0.333.../a ;
l(H-L)=1/(3*a)=0.333.../a ;
l(L-M)=1/(2*c)=0.5.../c ;
l(M-Gamma)=-1/(sqrt(3)*a)=0.577.../a ;
l(Gamma-A)=1/(2*c)=0.5.../c
<p>

<p>D. <b>Rhombohedral lattices</b>
<p>Rhombohedral lattices are characterised by two parameters, the length of the primitive
vectors, that we will denote a0, and the angle they form, alpha.
These can be directly input of ABINIT, as
<a href="varbas.html#acell">acell</a> and <a href="varbas.html#angdeg">angdeg</a>
<p>This will generate the primitive vectors in real space , with
<pre>
<a href="varbas.html#acell">acell</a> a0 a0 a0    and      <a href="varbas.html#rprim">rprim</a>  a 0 c    -a/2 a*sqrt(0.75) c    -a/2 -a*sqrt(0.75) c
</pre>
with a^2+c^2=1, a^2=(1-cos(alpha))*2/3, c^2=(1+2*cos(alpha))*1/3, (a/c)^2=2*(1-cos(alpha))/(1+2*cos(alpha))
 and also cos(alpha)=(1-(a/c)^2/2)/(1+(a/c)^2).
Alternatively, these values of rprim might directly be the input of ABINIT (then, the balance
of the scaling factor might be adjusted between
<a href="varbas.html#acell">acell</a> and <a href="varbas.html#rprim">rprim</a>).
<p>
Unlike for the simple cubic, FCC, BCC, hexagonal (and some other) Bravais lattice,
the topology of the Brillouin zone will depend on the alpha (or a/c) value. We give below
information concerning the case when cos(alpha) is positive, that is, (a/c)^2 lower than 2.
<p>
The coordinates of several special points with respect to primitive vectors in reciprocal space will
not depend on the a/c ratio, but some others will depend on it. So, some care has to be exercised.
Notations for the Brillouin Zone special points are the same as in Phys. Rev. B 41, 11827 (1990).
<pre>
L (1/2 0 0) or (0 1/2 0) or (0 0 1/2) (or with negative signs)
T (1/2 1/2 1/2)
X (1/2 1/2 0) or (1/2 0 1/2) or (0 1/2 1/2) (or with separate negative signs)
W (5/6 - (a/c)^2/6 , 1/2 , 1/6 + (a/c)^2/6 ) = (1 0 -1)*(1-(a/c)^2/2)/3 + (1 1 1)/2
U ( (1+(a/c)^2)/6 , (8-(a/c)^2)/12 , (8-(a/c)^2)/12 ) = (-1 1/2 1/2)*(1-(a/c)^2/2)/3 + (1 1 1)/2
K (1 0 -1)*(1+(a/c)^2/4)/3
</pre>
So, if you want to specify a typical circuit, the following might do the work (the representative points on lines of symmetry are indicated - there are sometimes more than one way to go from one point to another) :
X-V-K-Sigma-Gamma-Lambda-T-Q-W-Y-L-sigma-Gamma-sigma-X . The suggestion is to sample this path
with the following coordinates
for the special points X, Gamma, T, L, Gamma, X :
<br>
<pre>kptbounds  1/2 0 -1/2   0 0 0    1/2 1/2 1/2  1 1/2 0   1 0 0  1 1/2 1/2
</pre>
<p>
In order to find the lengths of segments
(this information is useful to draw the band structure,
with the correct relative scale between special points)
one needs to know the a and c lattice parameters. Also, in what follows, we omit the 2*pi factor sometimes
present in the definition of the reciprocal space vectors.
The reciprocal vectors are (2/(3*a) 0 1/(3*c)) , -(1/(3*a) 1/(sqrt(3)*a) 1/(3*c), -(1/(3*a) -1/(sqrt(3)*a) 1/(3*c) ). The lengths of
the above-mentioned segments can be computed as :
l(X-Gamma)=2/(sqrt(3)*a)=1.155.../a , with l(K-Gamma)=(1+(a/c)^2/4)*4/(3*sqrt(3)*a);
l(Gamma-T)=1/(2*c) ;
l(T-L)=2/(sqrt(3)*a)=1.155.../a , with l(T-W)=(1-(a/c)^2/2)*4/(3*sqrt(3)*a);
l(L-Gamma)=sqrt(4/(a^2)+1/(c^2))/3
l(Gamma-X)=sqrt(1/(a^2)+1/(c^2))*2/3
<p>

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="kptrlatt">kptrlatt</a></font>
<br><font id="definition">Mnemonics: K - PoinTs grid : Real space LATTice </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array kptrlatt(3,3)  </font>
<br><font id="default">Default is No default.</font>
<br><br><font id="text">
This input variable is used only when <a href="varbas.html#kptopt">kptopt</a>
is positive. It partially defines the k point grid.
The other piece of information is contained in
<a href="varbas.html#shiftk">shiftk</a>.
<b>kptrlatt</b> cannot be used together with <a href="varbas.html#ngkpt">ngkpt</a>.

<p>The values kptrlatt(1:3,1), kptrlatt(1:3,2), kptrlatt(1:3,3)
are the coordinates of three vectors in real space, expressed
in the <a href="varbas.html#rprim">rprim</a> coordinate system (reduced coordinates).
They defines a super-lattice in real space.
The k point lattice is the reciprocal of this super-lattice,
eventually shifted (see <a href="varbas.html#shiftk">shiftk</a>).

<p>If neither <a href="varbas.html#ngkpt">ngkpt</a> nor <b>kptrlatt</b>
are defined, ABINIT will automatically generate a set
of k point grids, and select the best combination
of <b>kptrlatt</b> and <a href="varbas.html#shiftk">shiftk</a>
that allows to reach a sufficient value of <a href="vargs.html#kptrlen">kptrlen</a>.
See this latter variable for a complete description of this
procedure.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="kptrlen">kptrlen</a></font>
<br><font id="definition">Mnemonics: K - PoinTs grid : Real space LENgth </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 20.0d0.</font>
<br><br><font id="text">
This input variable is used only when <a href="varbas.html#kptopt">kptopt</a>
is positive and non-zero.

<p>Preliminary explanation :
<br>
The k point lattice defined by <a href="varbas.html#ngkpt">ngkpt</a>
or <a href="vargs.html#kptrlatt">kptrlatt</a> is used to perform integrations
of periodic quantities in the Brillouin Zone, like
the density or the kinetic energy. One can relate the
error made by replacing the continuous integral by a sum
over k point lattice to the Fourier transform of the
periodic quantity. Erroneous contributions will appear
only for the vectors in real space that belong to the reciprocal
of the k point lattice, except the origin.
Moreover, the expected size of these
contributions usually decreases exponentially with the distance.
So, the length of the smallest of these real space vectors
is a measure of the accuracy of the k point grid.

<p>When either <a href="varbas.html#ngkpt">ngkpt</a> or
<a href="vargs.html#kptrlatt">kptrlatt</a> is defined, <b>kptrlen</b> is not
used as an input variable, but the length of the
smallest vector will be placed in this variable, and echoed
in the output file.

<p>On the other hand, when neither <a href="varbas.html#ngkpt">ngkpt</a> nor
<a href="vargs.html#kptrlatt">kptrlatt</a> are defined, ABINIT will
automatically generate a large set of possible k point grids,
and select among this set, the grids that give
a length of smallest vector LARGER than <b>kptrlen</b>,
and among these grids, the one that, when used with
<a href="varbas.html#kptopt">kptopt</a>=1, reduces to the smallest number
of k points. Note that this procedure can be time-consuming.
It is worth doing it once for a given unit cell
and set of symmetries, but not use this procedure by default.
The best is then to set <a href="varfil.html#prtkpt">prtkpt</a>=1, in order
to get a detailed analysis of the set of grids.

<p>If some layer of vacuum is detected in the unit cell
(see the input variable <a href="vargs.html#vacuum">vacuum</a>), the
computation of <b>kptrlen</b> will ignore the
dimension related to the direction perpendicular
to the vacuum layer, and generate a bi-dimensional k point grid.
If the system is confined in a tube,
a one-dimensional k point grid will be generated.
For a cluster, this procedure will only generate the Gamma point.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="mixalch">mixalch</a></font>
<br><font id="definition">Mnemonics: MIXing coefficients for ALCHemical potentials</font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer array
mixalch(<a href="vargs.html#npspalch">npspalch</a>,<a href="vargs.html#ntypalch">ntypalch</a>)</font>
<br><font id="default">Default is 0.d0 (will not accepted !)</font>
<br><br><font id="text">
<p> Used for the generation of alchemical pseudoatoms, that is,
when <a href="vargs.html#ntypalch">ntypalch</a> is non-zero.
<p> This array gives, for each type of alchemical pseudatom (there are
<a href="vargs.html#ntypalch">ntypalch</a> such pseudoatoms), the mixing coefficients
of the basic <a href="vargs.html#npspalch">npspalch</a> pseudopotentials for
alchemical use. For each type of alchemical pseudoatom, the sum of the
mixing coefficients must equal 1.
<p> The actual use of the mixing coefficients is defined by the input
variable <a href="vargs.html#algalch">algalch</a>.
<p> Example 1. Suppose that we want to describe Ba(0.25) Sr(0.75) Ti O3.
<br> The input variables related to the construction of the alchemical Ba(0.25) Sr(0.75)
potential will be :
<pre>
npsp   4                 ! 4 pseudopotentials should be read.
znucl  8 40 56 38        ! The nuclear charges. Note that the two
                         ! atoms whose pseudopotentials are to be mixed
                         ! are mentioned at the end of the series.
ntypat  3                ! There will be three types of atoms.
ntypalch   1             ! One pseudoatom will be alchemical.
                         ! Hence, there will be ntyppure=2 pure pseudoatoms,
                         ! with znucl 8 (O) and 40 (Ti), corresponding to
                         ! the two first pseudopotentials. Out of the
                         ! four pseudopotentials, npspalch=2 are left
                         ! for alchemical purposes, with znucl 56 (Ba)
                         ! and 38 (Sr).
mixalch    0.25  0.75    ! For that unique pseudoatom to be
                         ! generated, here are the mixing coeeficients,
                         ! to be used to combine the Ba and Sr pseudopotentials.
</pre>
<p> Example 2. More complicated, and illustrate some minor drawback of the
design of input variables.
Suppose that one wants to generate Al(0.25)Ga(0.75) As(0.10)Sb(0.90).
<br> The input variables will be :
<pre>
npsp  4                  ! 4 pseudopotentials should be read
znucl  13 31 33 51       ! The atomic numbers. All pseudopotentials
                         ! will be used for some alchemical purpose
ntypat  2                ! There will be two types of atoms.
ntypalch   2             ! None of the atoms will be "pure".
                         ! Hence, there will be npspalch=4 pseudopotentials
                         !  to be used for alchemical purposes.
mixalch    0.25  0.75 0.0  0.0   ! This array is a (4,2) array, arranged in the
           0.0   0.0  0.1  0.9   ! usual Fortran order.
</pre>
Minor drawback : one should not forget to fill <b>mixalch</b> with the needed zero's, in this later case.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="natsph">natsph</a></font>
<br><font id="definition">Mnemonics: Number of ATomic SPHeres for the atom-projected density-of-states</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is <a href="varbas.html#natom">natom</a> </font>
<br><br><font id="text">
This input variable is active only in the
<a href="varfil.html#prtdos">prtdos</a>=3 case.
<br>It gives the number of atoms around which the sphere
for atom-projected density-of-states will be built,
in the <a href="varfil.html#prtdos">prtdos</a>=3 case.
The indices of these atoms are given by <a href="vargs.html#iatsph">iatsph</a>.
The radius of these spheres is given by <a href="vargs.html#ratsph">ratsph</a>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nbdbuf">nbdbuf</a></font>
<br><font id="definition">Mnemonics: Number of BanDs for the BUFfer</font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type:
integer parameter </font>
<br><font id="default">Default is 0.
However, the default is changed to 2 in some cases, see later.</font>
<br><br><font id="text">
<b>nbdbuf</b> gives the number of bands, the highest in energy, that,
among the
<a href="varbas.html#nband">nband</a> bands, are to be considered
as part of a buffer. This concept is useful in three situations:
in non-self-consistent
calculations, for the determination of the convergence tolerance ;
for response functions of metals, to avoid instabilities,
and also when finite electric fields or non-linear responses (with electric field
perturbations) are considered.
For the two first, the need of a buffer is a natural requirement
of the problem, so that the default value is changed to 2 automatically,
as explained in the following.
The third case is only for implementation convenience.

<p> In non-self-consistent GS calculations (<a href="varbas.html#iscf">iscf</a>&lt;0),
the highest levels might be
difficult to converge, if they are degenerate with another level,
that does not belong to the set of bands treated. Then, it might
take extremely long to reach <a href="varbas.html#tolwfr">tolwfr</a>, although
the other bands are already extremely well-converged, and the energy
of the highest bands (whose residual are not yet good enough), is
also rather well converged.
<br> In response to this problem, for non-zero <b>nbdbuf</b>, the
largest residual (residm), to be later compared with <a href="varbas.html#tolwfr">tolwfr</a>,
will be computed only in the set of non-buffer bands (this modification
applies for non-self-consistent as well as self-consistent calculation,
for GS as well as RF calculations).
<br> For a GS calculation, with <a href="varbas.html#iscf">iscf</a>&lt;0, supposing
<b>nbdbuf</b> is not initialized in the input file,
then ABINIT will overcome the default <b>nbdbuf</b> value,
and automatically set <b>nbdbuf</b> to 2.
<p> In metallic RF calculations, in the conjugate gradient optimisation
of first-order wavefunctions, there is an instability situation
when the q wavevector of the perturbation brings the eigenenergy of the
highest treated band at some k point higher than the lowest
untreated eigenenergy at some k+q point.
If one accept a buffer of frozen states, this instability can be made to
disappear. Frozen states receive automatically a residual value of -0.1d0.
<br> For a RF calculation, with 3&lt;=<a href="varbas.html#occopt">occopt</a>&lt;=7,
supposing
<b>nbdbuf</b> is not initialized in the input file, then
ABINIT will overcome the default <b>nbdbuf</b> value,
and automatically set <b>nbdbuf</b> to 2. This value might be too low
in some cases.

<p>Also, the number of active bands, in all cases, is imposed
to be at least 1, irrespective of the value of <b>nbdbuf</b>.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nberry">nberry</a></font>
<br><font id="definition">Mnemonics: Number of BERRY phase computations</font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer nberry</font>
<br><font id="default">Default is 1</font>
<br><br><font id="text">
<p> Used for non-zero values of <a href="vargs.html#berryopt">berryopt</a>.
<p> Gives the number of Berry phase computations of polarisation,
or finite-difference estimations of the derivative of wavefunctions
with respect to the wavevector,
each of which might be characterized by a different change of
wavevector <a href="vargs.html#kberry">kberry</a>.
<p> When equal to 0, no Berry phase calculation of polarisation
is performed. The maximal value of <b>nberry</b> is 20.
<p> Note that the computation of the polarisation for a set of bands
having different occupation numbers is meaningless (although
in the case of spin-polarized calculations, the spin up bands
might have an identical occupation number, that might differ
from the identical occupation number of spin down bands).
Although meaningless, ABINIT will perform such computation,
if required by the user. The input variable
<a href="vargs.html#bdberry">bdberry</a> governs the set of bands
for which a Berry phase is computed.
<p> The computation of the Berry phase is not yet implemented
for spinor wavefunctions (<a href="vargs.html#nspinor">nspinor</a>=2).
Moreover, it is not yet implemented in the parallel version of ABINIT.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ndivk">ndivk</a></font>
<br><font id="definition">Mnemonics: Number of DIVisions of K lines</font>
<br><font id="category">Characteristic: NOT INTERNAL </font>
<br><font id="vartype">Variable type:
integer array ndivk(abs(<a href="varbas.html#kptopt">kptopt</a>))  </font>
<br><font id="default">Default is No default.</font>
<br><br><font id="text">
Gives the number of divisions of each of the segments
of the band structure, whose path is determined by
<a href="varbas.html#kptopt">kptopt</a>
and
<a href="vargs.html#kptbounds">kptbounds</a>.
This is only needed when <a href="varbas.html#kptopt">kptopt</a>
is negative. In this case, the absolute value of
<a href="varbas.html#kptopt">kptopt</a> is the number of such segments.
<p>For example, suppose that the number of segment is just one
(<a href="varbas.html#kptopt">kptopt</a>=-1),
a value <b>ndivk</b>=4 will lead to the computation
of points with relative coordinates 0.0, 0.25, 0.5, 0.75 and 1.0 , along
the segment in consideration.
<p>Now, suppose that there are two segments
(<a href="varbas.html#kptopt">kptopt</a>=-2), with
<b>ndivk</b>(1)=4 and <b>ndivk</b>(2)=2, the computation of the
eigenvalues will be done at 7 points, 5 belonging to the
first segment, with relative coordinates 0.0, 0.25, 0.5, 0.75 and 1.0,
the last one being also the starting point of the next segment,
for which two other points must be computed, with relative coordinates
0.5 and 1.0 .
<p>It is easy to compute disconnected circuits (non-chained segments),
by separating
the circuits with the value <b>ndivk</b>=1 for the intermediate
segment connecting the end of one circuit with the
beginning of the next one (in which case no intermediate
point is computed along this segment).
<p>Alternatively it is possible to generate automatically the array <b>ndivk</b>
by just specifying the number of divisions for the smallest segment.
See the related input variable <a href="vargs.html#ndivsm">ndivsm</a>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="ndivsm">ndivsm</a></font>
<br><font id="definition">Mnemonics: Number of DIVisions for the SMallest segment</font>
<br><font id="category">Characteristic: NOT INTERNAL </font>
<br><font id="vartype">Variable type:integer </font>
<br><font id="default">Default is No default.</font>
<br><br><font id="text">
Gives the number of divisions used to sample the smallest segment
of the circuit employed during a band structure calculation
(see related input variables
<a href="varbas.html#kptopt">kptopt</a>
and
<a href="vargs.html#kptbounds">kptbounds</a>).
If <b>ndivsm</b> is given in the input file, there is no need to specify the number of divisions
to be used for the other segments.
Indeed <a href="vargs.html#ndivk">ndivk</a> is automatically calculated inside the
code in order to generate a path where the number of divisions in each segment is proportial
to the length of the segment itself.
This option is activated only when <a href="varbas.html#kptopt">kptopt</a> is negative.
In this case, the absolute value of
<a href="varbas.html#kptopt">kptopt</a> is the number of such segments.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="ngfft">ngfft</a></font>
<br><font id="definition">Mnemonics: Number of Grid points for
Fast Fourier Transform </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array ngfft(3)</font>
<br><font id="default">Default is 0 0 0 (so, automatic selection
of optimal values)</font>
<br><br><font id="text">gives the size of fast Fourier transform
(fft) grid in three dimensions.  Each number must be
composed of the factors 2, 3, and 5 to be consistent with
the radices available in our fft.  If no <b>ngfft</b> is provided or
if <b>ngfft</b> is set to 0 0 0, the code will automatically provide
an optimal set of <b>ngfft</b> values, based on <a href="varbas.html#acell">acell</a>,
<a href="varbas.html#rprim">rprim</a> and <a href="varbas.html#ecut">ecut</a>.
This is the recommended procedure, of course.
<br>The total number of FFT points
is the product:<br> <tele><b>ngfft</b>(1)*<b>ngfft</b>(2)*<b>ngfft</b>(3)=nfft </tele>. <br>
When <b>ngfft</b> is made smaller
than recommended values, the code runs faster and the
equations in effect are approximated by a low pass Fourier
filter.  The code reports to standard output (unit 06) a
parameter "boxcut" which is the smallest ratio of the fft
box side to the G vector basis sphere diameter.  When
boxcut is less than 2 the Fourier filter approximation is being
used.  When boxcut gets less than about 1.5 the
approximation may be too severe for realistic results
and should be tested against larger values of <b>ngfft</b>.
When boxcut is larger than 2, <b>ngfft</b> could be reduced without
loss of accuracy. In this case, the small variations
that are observed are solely due to the
xc quadrature, that may be handled with <a href="vardev.html#intxc">intxc</a>=1
to even reduce this effect.
<p>
Internally, <b>ngfft</b> is an array of size 18. The present
components are stored in <b>ngfft</b>(1:3), while
<ul>
 <li> <b>ngfft</b>(4:6) contains slightly different (larger) values,
  modified for efficiency of the FFT </li>
 <li> <b>ngfft</b>(7) is <a href="vardev.html#fftalg">fftalg</a> </li>
 <li> <b>ngfft</b>(8) is <a href="vardev.html#fftcache">fftcache</a> </li>
 <li> <b>ngfft</b>(9) is set to 0 if the parallelization of the FFT is not activated,
   while it is set to 1 if it is activated.</li>
 <li> <b>ngfft</b>(10) is the number of processors of the FFT group </li>
 <li> <b>ngfft</b>(11) is the index of the processor in the group of processors </li>
 <li> <b>ngfft</b>(12) is n2proc, the number of x-z planes, in reciprocal space, treated by the processor </li>
 <li> <b>ngfft</b>(13) is n3proc, the number of x-y planes, in real space, treated by the processor </li>
 <li> <b>ngfft</b>(14) is mpi_comm_fft, the handle on the MPI communicator in charge of the FFT parallelisation </li>
 <li> <b>ngfft</b>(15:18) are not yet used </li>
</ul>
<br>
The number of points stored by this processor in real space is n1*n2*n3proc, while in reciprocal
space, it is n1*n2proc*n3.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nline">nline</a></font>
<br><font id="definition">Mnemonics: Number of LINE minimisations </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 4.</font>
<br><br><font id="text">Gives maximum number of line minimizations
allowed in preconditioned conjugate gradient minimization
for each band. The Default, 4, is fine.
<br>Special cases, with degeneracies or near-degeneracies
of levels at the Fermi energy may require a larger value of
<b>nline</b> (5 or 6 ?)
Line minimizations will be stopped anyway when improvement
gets small. With the input variable <a href="vardev.html#nnsclo">nnsclo</a>,
governs the convergence of the wavefunctions
for fixed potential.
<br>Note that <b>nline</b>=0 can be used to diagonalize the Hamiltonian
matrix in the subspace spanned by the input wavefunctions.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="npsp">npsp</a></font>
<br><font id="definition">Mnemonics: Number of PSeudoPotentials </font>
<br><font id="category">Characteristic: NO MULTI </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is <a href="varbas.html#ntypat">ntypat</a></font>
<br><br><font id="text">
Usually, the number of pseudopotentials to be read is equal
to the number of type of atoms. However,
in the case an alchemical mixing of pseudopotential is to be used,
often the number of pseudopotentials to be read will not equal the number of types of atoms.
<p> Alchemical pseudopotentials will be present
when <a href="vargs.html#ntypalch">ntypalch</a> is non-zero.
See <a href="vargs.html#ntypalch">ntypalch</a>
to understand how
to use alchemical potentials in ABINIT.
The input variables
 <a href="vargs.html#ntypalch">ntypalch</a>,
 <a href="vargs.html#algalch">algalch</a>,<a href="vargs.html#mixalch">mixalch</a>)
are active, and generate alchemical potentials from the available
pseudopotentials. Also, the inner variables
<a href="vargs.html#ntyppure">ntyppure</a>,<a href="vargs.html#npspalch">npspalch</a>)
becomes active. See these input variables, especially
<a href="vargs.html#mixalch">mixalch</a>, to understand how
to use alchemical potentials in ABINIT.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="npspalch">npspalch</a></font>
<br><font id="definition">Mnemonics:
Number of PSeudoPotentials that are "ALCHemical" </font>
<br><font id="category">Characteristic: Inner </font>
<br><font id="vartype">Variable type: integer parameter, non-negative </font>
<br><br><font id="text">
<p> <b>npspalch</b>=<a href="vargs.html#npsp">npsp</a>-<a href="vargs.html#ntyppure">ntyppure</a>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nqpt">nqpt</a></font>
<br><font id="definition">Mnemonics: Number of Q - POINTs </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0.</font>
<br><br><font id="text">Determines whether one q point
must be read (See the variables <a href="vargs.html#qpt">qpt</a> and <a href="vargs.html#qptnrm">qptnrm</a>).
<br>Can be either 0 or 1.
<br>If 1 and used in ground-state calculation,
a global shift of all the k-points is applied, to give
calculation at k+q.
In this case, the output wavefunction will be appended
by _WFQ instead of _WFK (see the <a href="../users/abinis_help.html">section 4</a> of abinis_help)
Also, if 1 and a RF calculation is done, defines the
wavevector of the perturbation.</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nspden">nspden</a></font>
<br><font id="definition">Mnemonics: Number of SPin-DENsity components </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">The Default is the value of
<a href="varbas.html#nsppol">nsppol</a>.</font>
<br><br><font id="text">
If <b>nspden</b>=1, no spin-magnetisation : the density matrix is
diagonal, with same values spin-up and spin-down
(compatible with <a href="varbas.html#nsppol">nsppol</a>=1 only,
for both <a href="varbas.html#nspinor">nspinor</a>=1 or 2)
<p>
If <b>nspden</b>=2, scalar magnetization (the axis is arbitrarily
fixed in the z direction) : the density matrix is
diagonal, with different values for spin-up and spin-down
(compatible with <a href="vargs.html#nspinor">nspinor</a>=1,
either with <a href="varbas.html#nsppol">nsppol</a>=2 -general
collinear magnetisation- or
<a href="varbas.html#nsppol">nsppol</a>=1 -antiferromagnetism)
<p>
If <b>nspden</b>=4, vector magnetization : the density matrix is full,
with allowed x, y and z magnetisation
(useful only with <a href="vargs.html#nspinor">nspinor</a>=2 and
<a href="varbas.html#nsppol">nsppol</a>=1, either
because there is spin-orbit without time-reversal
symmetry - and thus spontaneous magnetization, or
with spin-orbit, if one allows for spontaneous
non-collinear magnetism). Not yet available for forces,
stresses, response functions.
<p>
The default (<b>nspden</b>=<a href="varbas.html#nsppol">nsppol</a>)
does not suit the case of vector magnetization.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="nspinor">nspinor</a></font>
<br><font id="definition">Mnemonics:
Number of SPINORial components of the wavefunctions </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">The Default is 1 (2 if <a href="varpaw.html#pawspnorb">pawspnorb</a>=1).</font>
<br><br><font id="text">
If <b>nspinor</b>=1, usual case : scalar wavefunction
(compatible with (<a href="varbas.html#nsppol">nsppol</a>=1,
<a href="vargs.html#nspden">nspden</a>=1) as well
 as (<a href="varbas.html#nsppol">nsppol</a>=2, <a href="vargs.html#nspden">nspden</a>=2) )
<p>
If <b>nspinor</b>=2, the wavefunction is a spinor
(compatible with <a href="varbas.html#nsppol">nsppol</a>=1, with
<a href="vargs.html#nspden">nspden</a>=1 or 4,
but not with <a href="varbas.html#nsppol">nsppol</a>=2)
<p>When <b>nspinor</b> is 2, the values of <a href="vardev.html#istwfk">istwfk</a>
are automatically set to 1. Also, the number of bands, for each k-point,
should be even.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="ntypalch">ntypalch</a></font>
<br><font id="definition">Mnemonics:
Number of TYPe of atoms that are "ALCHemical" </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
<p> Used for the generation of alchemical pseudopotentials :
when <b>ntypalch</b> is non-zero, alchemical mixing
will be used.
<p> Among the <a href="varbas.html#ntypat">ntypat</a> types of atoms, the
last <b>ntypalch</b> will be "alchemical" pseudoatoms, while only
the first <b>ntyppure</b> will be uniquely associated with a pseudopotential
(the <b>ntyppure</b> first of these, actually). The
<a href="vargs.html#ntypalch">ntypalch</a> types of alchemical
pseudoatoms are to be made
from the remaining <a href="vargs.html#npspalch">npspalch</a> pseudopotentials.
<p> In this case,
the input variables
 <a href="vargs.html#algalch">algalch</a>,<a href="vargs.html#mixalch">mixalch</a>
are active, and generate alchemical potentials from the available
pseudopotentials.  See these input variables, especially
<a href="vargs.html#mixalch">mixalch</a>, to understand how
to use alchemical potentials in ABINIT.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="ntyppure">ntyppure</a></font>
<br><font id="definition">Mnemonics:
Number of TYPe of atoms that are "PURe" </font>
<br><font id="category">Characteristic: Inner </font>
<br><font id="vartype">Variable type: integer parameter, non-negative </font>
<br><br><font id="text">
<p> <b>ntyppure</b>=<a href="varbas.html#ntypat">ntypat</a>-<a href="vargs.html#ntypalch">ntypalch</a>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="nwfshist">nwfshist</a></font>
<br><font id="definition">Mnemonics:
Number of WaveFunctionS HISTory </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter, non-negative </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
<p>In the wavelet basis set, the ground state is found by direct
	minimisation. The algorithm used can be either the steepest
	descent or the DIIS (Direct Inversion of Iteration
	Space). When <b>nwfshist</b> = 0, the steepest descent is used
      (<i>i.e.</i> there is no history storage of the previous
	iterations). If <b>nwfshist</b> is strictly positive, a DIIS
	is used. A typical value is 6. Using a DIIS increases the
	memory required by the program since N previous wavefunctions
	are stored during the electronic minimisation.</p>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>



<font id="title"><a name="positron">positron</a></font>
<br><font id="definition">Mnemonics: POSITRON calculation </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
For <b>positron</b>=1 or 2, will perform the calculation of positron
lifetime (and decay rate). In case of <b>positron</b>=1, one considers
that the electrons are not perturbed by the presence of the positron.
This is almost correct for a positron in a perfect bulk material.
But this approximation fails when defects exist in
the material. For example, the positron might be trapped by a vacancy.
Then locally its density will be important and
will influence the electrons density. In this case, one has to
use <b>positron</b>=2. However, <b>positron</b>=2 is in development,
and will not be described here.
<p>
In case <b>positron</b>=1, the calculation is done in two steps.
<p>
The first one is a normal GS calculation for the electrons,
with <b>positron</b>=0, in a large cell
(one or two atoms per unit cell is not enough, since the calculation has to be done subsequently
at the Gamma point only, see next paragraph). The only specific thing to
do is to set <a href="varfil.html#prtden">prtden</a> and <a href="varfil.html#prtvha">prtvha</a>
to 1 in the input file. This will create the
associated files _DEN and _VHA which will used as input files for the GS calculation
of the positron.
An important restriction exist for the pseudopotentials of this step :
no non-linear XC core correction is allowed (consult the documentation about pseudopotentials
in the proper directory Infos/Psp_infos).
<p>
The second step is the GS calculation of the positron and subsequently its
lifetime, with <b>positron</b>=1.
One has to define also <a href="vargs.html#ixcpositron">ixcpositron</a>.
A proper calculation must be done with only one band (<a href="varbas.html#nband">nband</a>=1) and
only the gamma point in the BZ (<a href="varbas.html#kptopt">kptopt</a>=0,
<a href="varbas.html#nkpt">nkpt</a>=1, and <a href="varbas.html#kpt">kpt</a>= 0 0 0).
One has also to use specific pseudopotentials for the positron calculation.
They must be of the FHI type, and must contain at their
end, the all-electrons core density generated with FHI98PP. They must have
lmax=lloc=0 (check that this works for the electronic GS !! No ghost, etc ...)
and pspxc=0 (no self-interaction terms must be taken
into account for the positron). Otherwise, their are similar to a usual FHI pseudopotential.
<p>
References :
<ul>
 <li>J. Arponen and E. Pajanne, Ann. Phys. (N.Y.) 121, 343 (1979).</li>
 <li>E. Boronski and R.M. Nieminen, Phys. Rev. B 34, 3820 (1986).</li>
 <li>M.J. Puska, A.P. Seitsonen, and R.M. Nieminen, Phys. Rev. B 52, 10947 (1994).</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="occ">occ</a></font>
<br><font id="definition">Mnemonics: OCCupation numbers </font>
<br><font id="category">Characteristic: EVOLVING </font>
<br><font id="vartype">Variable type: real array occ(<a href="varbas.html#nband">nband</a>)  </font>
<br><font id="default">Default is 0's.</font>
<br><br><font id="text">Gives occupation numbers for all
bands in the problem. Needed if <a href="varbas.html#occopt">occopt</a>==0 or
<a href="varbas.html#occopt">occopt</a>==2.
Ignored otherwise. Also ignored when <a href="varbas.html#iscf">iscf</a>=-2.
<br>Typical band occupancy is either
2 or 0, but can be 1 for half-occupied band or other
choices in special circumstances.  <br>If <a href="varbas.html#occopt">occopt</a> is not 2,
then the occupancies must be the same for each k point.
<br>If <a href="varbas.html#occopt">occopt</a>=2, then the band occupancies must be
provided explicitly for each band, EACH k POINT,
and EACH SPIN-POLARIZATION, in an
array which runs over all bands, k points,
and spin-polarizations.
<br>The order of entries in the array would correspond to
all bands at the first k point (spin up), then all bands at the
second k point (spin up), etc, then all k-points spin down.
<br>The total number of array elements
which must be provided is <br>
( <a href="varbas.html#nband">nband</a>(1)+<a href="varbas.html#nband">nband</a>(2)+...+
<a href="varbas.html#nband">nband</a>(<a href="varbas.html#nkpt">nkpt</a>) ) *
<a href="varbas.html#nsppol">nsppol</a> .
<br>The occupation numbers evolve only for metallic occupations,
that is, <a href="varbas.html#occopt">occopt</a>=3 .</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="optdriver">optdriver</a></font>
<br><font id="definition">Mnemonics: OPTions for the DRIVER </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">The Default is <b>optdriver</b>=0 </font>
<br><br><font id="text">For each dataset, choose
the task to be done, at the level of the "driver" routine.
<p>The choice is among :
<br><b>optdriver</b>=0 : ground-state calculation (GS), routine "gstate"
<br><b>optdriver</b>=1 : response-function calculation (RF), routine "respfn"
<br><b>optdriver</b>=2 : susceptibility calculation (SUS), routine "suscep"
<br><b>optdriver</b>=3 : susceptibility and dielectric matrix calculation (SCR), routine "screening"
 <br>
(see the input variables <a href="vargw.html#ecutwfn">ecutwfn</a>,
 <a href="vargw.html#ecuteps">ecuteps</a>,
 <a href="vargw.html#ppmfrq">ppmfrq</a>,
 <a href="varfil.html#getkss">getkss</a>,
 as well as <a href="vargw.html#nbandkss">nbandkss</a> and <a href="varbas.html#nband">nband</a>)
<br><b>optdriver</b>=4 : self-energy calculation (SIG), routine "sigma"
<br><b>optdriver</b>=5 : non-linear response functions, using the 2n+1 theorem, routine "nonlinear"
<p>
If one of <a href="varrf.html#rfphon">rfphon</a>, <a href="varrf.html#rfphon">rfelfd</a>,
or <a href="varrf.html#rfstrs">rfstrs</a> is non-zero, while <b>optdriver</b>
is not defined in the input file, ABINIT will set <b>optdriver</b> to 1
automatically. These input variables (<a href="varrf.html#rfphon">rfphon</a>,
<a href="varrf.html#rfphon">rfelfd</a>, and <a href="varrf.html#rfstrs">rfstrs</a>) must be
zero if <b>optdriver</b> is not set to 1.
<!--
<br>When <b>optdriver</b> is 3 or 4, <a href="vargw.html#symmorphi">symmorphi</a> must be set to 0
in case there are non-symmorphic symmetry operations.
-->
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="optstress">optstress</a></font>
<br><font id="definition">Mnemonics: OPTion for the computation of STRess</font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer </font>
<br><font id="default">Default is 1</font>
<br><br><font id="text">If set to 1, the computation of stresses is done,
in the SCF case
(under the conditions <a href="varbas.html#iscf">iscf</a> > 0 , <a href="varfil.html#prtstm">prtstm</a>==0 ,
<a href="vargs.html#positron">positron</a>==0,
and either  <a href="varbas.html#nstep">nstep</a> >0 , or
<a href="varint.html#usepaw">usepaw</a>==0 or <a href="varfil.html#irdwfk">irdwfk</a>==1).
<br>
Otherwise, to save CPU time, if no optimization of the cell is required,
one can skip the computation of stresses. The CPU time saving might be interesting
for some PAW calculations.
</font>



<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="so_psp">so_psp</a></font>
<br><font id="definition">Mnemonics:
 Spin-Orbit treatment for each PSeudoPotential </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer array
 <b>so_psp</b>(<a href="varbas.html#npsp">npsp</a>) </font>
<br><font id="default">Default is <a href="varbas.html#npsp">npsp</a>*1 </font>
<br><br><font id="text">
For each type of atom (each pseudopotential), specify
the treatment of spin-orbit interaction (if <a href="varbas.html#nspinor">nspinor</a>==2).
<br> If 0 : no spin-orbit interaction, even if <a href="vargs.html#nspinor">nspinor</a>=2
<br> If 2 : treat spin-orbit in the HGH form
                 (not allowed for all pseudopotentials)
<br> If 3 : treat spin-orbit in the HFN form
                 (not allowed for all pseudopotentials)
<p>Also, <b>so_psp</b>=1 lead automatically to treatments 0, 2, or 3 according
   to the data contained in the pseudopotential file
 (0= there is no spin-orbit information in the psp file;
  2= the spin-orbit information is of the HGH form;
  3= the spin-orbit information is of the HFN form )
 So, for typical usage, one will need only the values 0 or 1
<p>Note that if <a href="varbas.html#nspinor">nspinor</a>==1, the spin-orbit cannot be treated
anyhow, so the value of <b>so_psp</b> is irrelevant.
<p>Prior to v5.4, the input variable <b>so_typat</b> (or <b>pspso</b>)
was used, in place of <b>so_psp</b>. Because the values 0 and 1 have been switched
between <b>so_psp</b> and so_typat, it was dangerous to continue to allow the use of so_typat.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="qpt">qpt</a></font>
<br><font id="definition">Mnemonics: Q PoinT </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real array of 3 elements  </font>
<br><font id="default">Default is 0 0 0.</font>
<br><br><font id="text">Define a q vector.
<br>See <a href="vargs.html#qptnrm">qptnrm</a> for extra normalization.
<br>In ground-state calculation, if <a href="vargs.html#nqpt">nqpt</a> is 1,
the vector
<a href="varint.html#qptn">qptn</a>(1:3)=
<b>qpt</b>(1:3)/<a href="vargs.html#qptnrm">qptnrm</a> is added to
each renormalized k point
<a href="varint.html#kpt">kpt</a>(1:3)/<a href="vargs.html#kptnrm">kptnrm</a>
to generate the normalized, shifted, set of k-points
<a href="varint.html#kptns">kptns</a>(1:3,1:<b>nkpt</b>).
<br>In response-function calculations,
<a href="varint.html#qptn">qptn</a>(1:3)=
<b>qpt</b>(1:3)/<a href="vargs.html#qptnrm">qptnrm</a>
is the wavevector of the phonon-type calculation.
<br>For insulators, there is no restriction on the
q-points to be used for the perturbations. By contrast,
for metals, for the time being, it is advised to take
q points for which the k and k+q grids are the same
(when the periodicity in reciprocal space is taken
into account). <br>Tests remain to be done to see whether
other q points might be allowed (perhaps with some
modification of the code).</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="prtdensph">prtdensph</a></font>
<br><font id="definition">Mnemonics: PRinT integral of DENsity inside atomic SPHeres</font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter</font>
<br><font id="default">Default is 0 except when antiferro-magnetism is activated (<a href="varbas.html#nsppol">nsppol</a>=1, <a href="vargs.html#nspden">nspden</a>=2).</font>
<br><br><font id="text">
When this flag is activated, values of integral(s) of total density inside sphere(s) around each atom are printed in output file (for each spin component).
Spheres around atoms are defined by a radius given by <a href="vargs.html#ratsph">ratsph</a> keyword.<br>
Note: integral of density inside a sphere around an atom
can be used to determine a rough approximation of the local magnetic moment;
this is particulary useful for antiferromagnetic systems.
<br>
The algorithm to compute this integral is particularly primitive : the points on the FFT grids, belonging
to the interior of the sphere are determined, and the value of the functions on these points are summed,
taking into account a fixed volume attributed to each point.
In particular, the integral as a function of the radius will be a constant, except when
a new point enters the sphere, in which case a sudden jump occurs.
However, since the purpose of this output is to get a rough idea of the repartitjon of the density,
this is not a real problem. If you are interested in a more accurate estimation
of the density within a sphere, you should use the cut3d postprocessor.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="qptnrm">qptnrm</a></font>
<br><font id="definition">Mnemonics: Q PoinTs NoRMalization </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 1.0  </font>
<br><br><font id="text">Provides re-normalization
of <a href="vargs.html#qpt">qpt</a>.
Must be positive, non-zero.
The actual q vector (renormalized) is
<a href="varint.html#qptn">qptn</a>(1:3)=
<a href="vargs.html#qpt">qpt</a>(1:3)/<b>qptnrm</b>.</font>
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="ratsph">ratsph</a></font>
<br><font id="definition">Mnemonics: Radii of the ATomic SPHere(s) </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: real array ratsph(<a href="varbas.html#ntypat">ntypat</a>)  </font>
<br><font id="default">Default is 2.0 Bohr for norm-conserving psps, PAW radius (found in PAW dataset file) for PAW</font>
<br><br><font id="text">Relevant only when
<a href="varfil.html#prtdos">prtdos</a>=3 or <a href="vargs.html#prtdensph">prtdensph</a>=1.<br>
<br>When <a href="varfil.html#prtdos">prtdos</a>=3:<br>
Provides the radius of the spheres around the <a href="vargs.html#natsph">natsph</a> atoms
of indices <a href="vargs.html#iatsph">iatsph</a>, in which the local
DOS and its angular-momentum projections will be analysed.
The choice of this radius is quite arbitrary. In a plane-wave basis set,
there is no natural definition of an atomic sphere. However, it might be wise
to use the following well-defined and physically motivated procedure
(in version 4.2, this procedure is NOT implemented, unfortunately) :
from the Bader analysis, one can define the radius of the sphere
that contains the same charge as the Bader volume. This
"Equivalent Bader charge atomic radius" might then be used to perform
the present analysis.
See the <A href="../users/aim_help.html"><B>AIM (Bader)</B></a> help file for more explanations.
Another physically motivated choice would be to rely on another
charge partitioning, like the Hirshfeld one (see the cut3d utility).
The advantage of using charge partitioning schemes comes from the fact that the
sum of atomic DOS, for all angular momenta and atoms, integrated on the
energy range of the occupied states,
gives back the total charge.
If this is not an issue, one could rely on the half of the nearest-neighbour distances, or
any scheme that allows to define an atomic radius. Note that the choice of this
radius is however critical for the balance between the s, p and d components. Indeed,
the integrated charge within a given radius, behave as a different power of the
radius, for the different channels s, p, d. At the limit of very small radii, the s component
dominates the charge contained in the sphere ...
<br><br>When <a href="vargs.html#prtdensph">prtdensph</a>=1:<br>
Provides the radius of the spheres around (all) atoms in which the total charge density will be integrated.
<br><br>In case of PAW, <a href="vargs.html#ratsph">ratsph</a> radius has to be greater or equal to
PAW radius of considered atom type (which is read from the PAW dataset file; see rc_sph or r_paw).

</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="slabwsrad">slabwsrad</a></font>
<br><font id="definition">Mnemonics: jellium SLAB Wigner-Seitz RADius</font>
<br><font id="category">Characteristic: LENGTH</font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.0d0. </font>
<br><br><font id="text">Fix the bulk-mean positive charge density n<sub>bulk</sub>
of a jellium slab (if the latter is employed, e.g. <a href="vargs.html#jellslab">jellslab</a> &ne 0).
Often called "r<sub>s</sub>" [see for example N. D. Lang and W. Kohn PRB 1, 4555 (1970)],
<b>slabwsrad</b> is the radius of a sphere which has the same volume
as the average volume per particle in a homogeneous electron gas with density n<sub>bulk</sub>, so:
<pre>
1/n<sub>bulk</sub> = 4/3 Pi * <a href="vargs.html#slabwsrad">slabwsrad</a><sup>3</sup>
</pre>
For example, the bulk aluminum fcc lattice constant
is a=4.0495 Angstroms (webelements.com), each cubic centered cell
includes 4 Al atoms and each atom has 3 valence electrons,
so the average volume per electron is a<sup>3</sup>/12=37.34 Bohr<sup>3</sup>
which has to be equal to 4/3 Pi*r<sub>s</sub><sup>3</sup>.
Consequently Al has approximately r<sub>s</sub>=2.07 Bohr, while for example magnesium has r<sub>s</sub>=2.65 Bohr, sodium 3.99 Bohr.
<br>
By default, given in Bohr atomic units (1 Bohr=0.5291772108 Angstroms).</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="slabzbeg">slabzbeg</a></font>
<br><font id="definition">Mnemonics: jellium SLAB BEGinning edge along the Z direction</font>

<p>
<font id="title"><a name="slabzend">slabzend</a></font>
<br><font id="definition">Mnemonics: jellium SLAB ENDing edge along the Z direction</font>
<br><font id="category">Characteristic:</font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.0d0, 0.0d0.  </font>
<br><br><font id="text">Define the edges of the jellium slab (if used, so if <a href="vargs.html#jellslab">jellslab</a> &ne 0)
along z, namely the slab starts at a point along z which is expressed in Bohr by <b>slabzbeg</b>
and it ends at a point expressed in Bohr by <b>slabzend</b>.
The z direction is parallel to the third crystal primitive lattice vector
which has to be orthogonal to the other ones,
so the length of the cell along z is <a href="varbas.html#rprimd">rprimd</a>(3,3).
In addition <b>slabzbeg</b> and <b>slabzend</b> have to be such that:
<pre>
0 &le <b>slabzbeg</b> &lt <b>slabzend</b> &le <a href="varbas.html#rprimd">rprimd</a>(3,3)
</pre>
Together with <a href="vargs.html#slabwsrad">slabwsrad</a>
they define the jellium positive charge density distribution n<sub>+</sub>(x,y,z) in this way:
<pre>
n<sub>+</sub>(x,y,z) = n<sub>bulk</sub>   if <b>slabzbeg</b> &le z &le <b>slabzend</b>
          = 0      otherwise,
</pre>
so the positive charge density is invariant along the xy plane as well as the electrostatic potential generated by it.</font>

<br><br><br><br><a href="#top">Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>




<font id="title"><a name="spinat">spinat</a></font>
<br><font id="definition">Mnemonics: SPIN for AToms </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type:
real array spinat(3,<a href="varbas.html#natom">natom</a>)
 or spinat(3,<a href="vargeo.html#natrd">natrd</a>) if the symmetriser is used  </font>
<br><font id="default">Default is 0.0d0.</font>
<br><br><font id="text">Gives the initial electronic spin-magnetisation
for each atom, in unit of h-bar/2.
<p>Note that if <a href="vargs.html#nspden">nspden</a>=2,
the z-component must be given
for each atom, in triplets (0 0 z-component).
<br>For example, the electron of an hydrogen atom
can be spin up (0 0 1.0) or spin down (0 0 -1.0).
<p>This value is only used to create
the first exchange and correlation potential,
and is not used anymore afterwards.
<br>It is not checked against the initial occupation numbers
<a href="vargs.html#occ">occ</a> for each spin channel.
<br>It is meant to give an easy way to break
the spin symmetry, and to allow
to find stable local spin fluctuations, for example :
antiferromagnetism, or the spontaneous spatial
spin separation of elongated H2 molecule.
<br>If the geometry builder is used, <b>spinat</b> will be related
to the preprocessed set of atoms, generated by the
geometry builder. The user must thus foresee the effect
of this geometry builder (see <a href="vargeo.html#objarf">objarf</a>).
<br>If the geometry builder is not used, and the symmetries
are not specified by the user (<a href="varbas.html#nsym">nsym</a>=0),
spinat will be used, if present, to determine the anti-ferromagnetic
characteristics of the symmetry operations, see <a href="vargs.html#symafm">symafm</a>
<br>If the symmetries are specified, and the irreducible set of atoms
is specified, the anti-ferromagnetic characteristics of the symmetry
operations <a href="vargs.html#symafm">symafm</a> will be used to generate
<b>spinat</b> for all the non-irreducible atoms.
<br>In the case of PAW+U calculations using the <a href="varpaw.html#dmatpawu">dmatpawu</a>
initial occupation matrix, and if <a href="vargs.html#nspden">nspden</a>=4, <b>spinat</b> is
also used to determine the direction of the integrated magnetization matrix.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="stmbias">stmbias</a></font>
<br><font id="definition">Mnemonics: Scanning Tunneling Microscopy BIAS voltage </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.00</font>
<br><br><font id="text"> Gives, in Hartree, the
bias of the STM tip, with respect to the sample, in order to generate
the STM density map.
<br>Used with positive <a href="varbas.html#iscf">iscf</a>,
<a href="varbas.html#occopt">occopt</a>=7 (metallic, gaussian),
<a href="varbas.html#nstep">nstep</a>=1 ,
and positive <a href="varfil.html#prtstm">prtstm</a>, this
value is used to generate a charge density map from electrons
close to the Fermi energy, in a (positive or negative) energy range.
Positive <b>stmbias</b> will lead to the inclusion of occupied (valence) states only, while
negative <b>stmbias</b> will lead to the inclusion of unoccupied (conduction) states only.
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>stmbias</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
0.001 Ha = 27.2113845 meV = 315.773 Kelvin .
With <a href="varbas.html#occopt">occopt</a>=7,
one has also to specify an independent broadening <a href="vargs.html#tsmear">tsmear</a>.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="symafm">symafm</a></font>
<br><font id="definition">Mnemonics: SYMmetries, Anti-FerroMagnetic characteristics </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type:
integer array symafm(<a href="varbas.html#nsym">nsym</a>) </font>
<br><font id="default">Default is <a href="varbas.html#nsym">nsym</a>*1.</font>
<br><br><font id="text">
In case the material is magnetic (well, this is only interesting in the
case of antiferromagnetism), additional symmetries might appear, that
change the sign of the magnetisation.
They have been introduced by Shubnikov (1951). They can be used by ABINIT
to decrease the CPU time, by using them to decrease the number of k-points.
<br> <b>symafm</b> should be set to +1 for all the usual symmetry operations,
that do not change the sign of the magnetisation, while it should be
set to -1 for the magnetisation-changing symmetries.
<br> If the symmetry operations are not specified by the user
in the input file, that is, if <a href="varbas.html#nsym">nsym</a>=0,
then ABINIT will use the values of <a href="vargs.html#spinat">spinat</a>
to determine the content of <b>symafm</b>.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="timopt">timopt</a></font>
<br><font id="definition">Mnemonics: TIMing OPTion </font>
<br><font id="category">Characteristic: NO MULTI </font>
<br><font id="vartype">Variable type:
 integer parameter </font>
<br><font id="default">Default is 1 for sequential code,
0 for parallel code.</font>
<br><br><font id="text">
This input variable allows to modulate the use of the timing routines.
<p>
If 0 => as soon as possible, suppresses all calls to timing routines
<br>
If 1 => usual timing behaviour, with short analysis, appropriate
for sequential execution
<br>
If 2 => close to timopt=1, except that the analysis routine
does not time the timer, appropriate for parallel execution.
<br>
If 3 => close to timopt=1, except that the different parts of the lobpcg routine are timed in detail.
<br>
If -1 => a full analysis of timings is delivered
<br>
If -2 => a full analysis of timings is delivered,
                 except timing the timer
<br>
If -3 => a full analysis of timings is delivered, including the detailed timing of the different parts of the lobpcg routine.
            (this takes time, and is discouraged for too small runs - the timing would take more time than the run !)
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="tl_nprccg">tl_nprccg</a></font>
<br><font id="definition">Mnemonics: TaiL maximum Number of
      PReConditionner Conjugate Gradient iterations </font>
<br><font id="category">Characteristic:  </font>
<br><font id="vartype">Variable type: integer parameter </font>
<br><font id="default">Default is 30.</font>
<br><br><font id="text">
This variable is the same than <a href="#wvl_nprccg">wvl_nprccg</a>
      but for the preconditionner iterations during the tail
      corrections (see <a href="#tl_radius">tl_radius</a>).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="tl_radius">tl_radius</a></font>
<br><font id="definition">Mnemonics: TaiL expansion RADIUS </font>
<br><font id="category">Characteristic: LENGTH </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.0d0.</font>
<br><br><font id="text">
In the wavelet computation case, the linkage between the grid and the
      free boundary conditions can be smooth using an exponential
      decay. This means a correction on the energy at the end on each
      wavefunction optimisation run. If this parameter is set to zero,
      no tail computation is done. On the contrary, put it to a
      positive value makes the tail correction available. The value
      correspond to a length in atomic being the spacial expansion
      with the exponential decay around the grid.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="tphysel">tphysel</a></font>
<br><font id="definition">Mnemonics: Temperature (PHYSical) of the ELectrons </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.00</font>
<br><br><font id="text"> Gives, in Hartree, the physical temperature of the
system, in case <a href="varbas.html#occopt">occopt</a>=4, 5, 6, or 7.
<br>Can be specified in Ha (the default), Ry, eV or Kelvin, since
<b>ecut</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
0.001 Ha = 27.2113845 meV = 315.773 Kelvin .
One has to specify an independent broadening <a href="vargs.html#tsmear">tsmear</a>.
The combination of the two parameters
<b>tphysel</b> and <a href="vargs.html#tsmear">tsmear</a> is described
in a paper by M. Verstraete and X. Gonze, Phys. Rev. B (2002).
Note that the signification of the entropy is modified with respect
to the usual entropy. The choice has been made to use
<a href="vargs.html#tsmear">tsmear</a> as a prefactor of the entropy,
to define the entropy contribution to the free energy.
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="tsmear">tsmear</a></font>
<br><font id="definition">Mnemonics: Temperature of SMEARing </font>
<br><font id="category">Characteristic: ENERGY </font>
<br><font id="vartype">Variable type: real parameter </font>
<br><font id="default">Default is 0.04</font>
<br><br><font id="text">Gives the broadening of occupation
numbers <a href="vargs.html#occ">occ</a>, in the metallic cases
(<a href="varbas.html#occopt">occopt</a>=3, 4, 5, 6 and 7).
Can be specified in Ha (the default), eV, Ry, or Kelvin, since
<b>tsmear</b> has the
'<a href="../users/abinis_help.html#dimensions">ENERGY</a>' characteristics.
0.001 Ha = 27.2113845 meV = 315.773 Kelvin
<br>Default is 0.04 Ha. This should be OK for a free-electron
metal like Al. For d-band metals, use 0.01 Ha.
<br>Always check the convergence of the calculation
with respect to this parameter, and simultaneously,
with respect to the sampling of k-points (see <a href="varbas.html#nkpt">nkpt</a>)
<br>If <a href="varbas.html#occopt">occopt</a>=3, <b>tsmear</b> is the
physical temperature, as the broadening is based on Fermi-Dirac statistics.
However,
if <a href="varbas.html#occopt">occopt</a>=4, 5, 6, or 7,
the broadening is not based on Fermi-Dirac statistics, and
<b>tsmear</b> is only a convergence parameter. It is still possible
to define a physical temperature, thanks to the input variable
<a href="vargs.html#tphysel">tphysel</a>. See the paper
by M. Verstraete and X. Gonze, Phys. Rev. B (2002).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vacuum">vacuum</a></font>
<br><font id="definition">Mnemonics: VACUUM identification </font>
<br><font id="category">Characteristic: NOT INTERNAL </font>
<br><font id="vartype">Variable type: integer array <b>vacuum</b>(3)  </font>
<br><font id="default">Default is No Default</font>
<br><br><font id="text">
Establishes the presence (if 1) or absence (if 0) of a vacuum
layer, along the three possible directions normal to the
primitive axes.
<p>
This information might be used to generate k-point grids,
if <a href="varbas.html#kptopt">kptopt</a>=0 and neither
<a href="varbas.html#ngkpt">ngkpt</a> nor <a href="vargs.html#kptrlatt">kptrlatt</a>
are defined (see explanations with the input variable
<a href="varfil.html#prtkpt">prtkpt</a>).
<br> It will allow to select
a zero-, one-, two- or three-dimensional
grid of k points. The coordinate of the k points
along vacuum directions is automatically set to zero.
<p>
If <b>vacuum</b> is not defined, the input variable
<a href="vargs.html#vacwidth">vacwidth</a>
will be used to determine automatically whether the
distance between atoms is sufficient to have the
presence or absence of vacuum.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


<font id="title"><a name="vacwidth">vacwidth</a></font>
<br><font id="definition">Mnemonics: VACuum WIDTH </font>
<br><font id="category">Characteristic: LENGTH  </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 10.0</font>
<br><br><font id="text">
Give a minimum "projected" distance between
atoms to be found in order to declare that there
is some <a href="vargs.html#vacuum">vacuum</a> present for each of the three
directions.
By default, given in Bohr atomic units
(1 Bohr=0.5291772108 Angstroms), although Angstrom can be specified,
if preferred, since <b>vacwidth</b> has the
'<a href="../users/abinis_help.html#dimensions">LENGTH</a>' characteristics.
<br>The precise requirement is that a slab
of width <b>vacwidth</b>, delimited by two
planes of constant reduced coordinates in the
investigated direction, must be empty of atoms.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="wvl_crmult">wvl_crmult</a></font>
<br><font id="definition">Mnemonics: WaVeLet Coarse grid Radius MULTiplier </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 6.0</font>
<br><br><font id="text">
This factor is used to defined the expansion of the coarse resolution
      grid in the case of wavelets (see <a
	href="varbas.html#usewvl">usewvl</a>). The grid is made of
      points inside spheres centered on atoms. The radius of these
      spheres are the product between this factor and the covalent
      radius of element (read from the pseudo-potential file).<br />
This factor is responsible for the amount of used memory (see also <a href="varbas.html#wvl_hgrid">wvl_hgrid</a>).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="wvl_cpmult">wvl_cpmult</a></font>
<br><font id="definition">Mnemonics: WaVeLet Coarse grid Projector radius MULTiplier </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 10.0</font>
<br><br><font id="text">
This factor is used to defined the expansion of the coarse resolution
      grid for the description of the projectors in the case of wavelets (see <a
	href="varbas.html#usewvl">usewvl</a>).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="wvl_crmult">wvl_frmult</a></font>
<br><font id="definition">Mnemonics: WaVeLet Fine grid Radius MULTiplier </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 10.0</font>
<br><br><font id="text">
This factor is used to defined the expansion of the fine resolution
      grid in the case of wavelets (see <a
	href="varbas.html#usewvl">usewvl</a>). This fine resolution
      grid has the same grid step than the coarse one (see <a
	href="vargs.html#wvl_crmult">wvl_crmult</a>), but on each
      point, 8 coefficients are stored instead of one, increasing the
      precision of the calculation in this area. The grid is made of
      points inside spheres centered on atoms. The radius of these
      spheres are the product between this factor and a value read from the pseudo-potential file.<br />
This factor is responsible for the amount of used memory (see also <a href="varbas.html#wvl_hgrid">wvl_hgrid</a>).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="wvl_fpmult">wvl_fpmult</a></font>
<br><font id="definition">Mnemonics: WaVeLet Fine grid Projector radius MULTiplier </font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: real parameter  </font>
<br><font id="default">Default is 10.0</font>
<br><br><font id="text">
This factor is used to defined the expansion of the fine resolution
      grid for the description of the projectors in the case of wavelets (see <a
	href="varbas.html#usewvl">usewvl</a>).
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="wvl_nprccg">wvl_nprccg</a></font>
<br><font id="definition">Mnemonics: WaVeLet maximum Number of PReConditionner
    Conjugate Gradient iterations</font>
<br><font id="category">Characteristic: </font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 5</font>
<br><br><font id="text">
In the wavelet computation case, the wavefunctions are directly
      minimised using a real-space precondionner. This preconditonner
      has internally some conjugate gradient iterations. This value
      define a boundary for the number of conjugate gradient
      iterations on each wavefunction convergence step.
</font>

<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>

<font id="title"><a name="xclevel">xclevel</a></font>
<br><font id="definition">Mnemonics: eXchange Correlation functional level</font>
<br><font id="category">Characteristic: INTERNAL</font>
<br><font id="vartype">Variable type: integer parameter  </font>
<br><font id="default">Default is 0</font>
<br><br><font id="text">
Automatically determined from the value of <a href="varbas.html#ixc">ixc</a>.
<ul>
 <li>0 => No XC contribution.</li>
 <li>1 => LDA functional.</li>
 <li>2 => GGA functional.</li>
 <li>3 => Functional for TDDFT.</li>
</ul>
</font>


<br><br><br><br><a href=#top>Go to the top</a>
<B> | </B><a href="keyhr.html#list">Complete list of input variables</a><hr>


Goto :
<A href="http://www.abinit.org"><B>ABINIT home Page</B></A>
<B> | </B>
<A href="../users/acknowledgments.html"><B>Suggested acknowledgments</B></A>
<B> | </B>
<A href="keyhr.html"><B>List of input variables</B></A>
<B> | </B>
<A href="../tutorial/welcome.html"><B>Tutorial home page</B></A>
<B> | </B>
<A href="../users/bibliography.html"><B>Bibliography</B></A>
<HR ALIGN=left>
Help files :
<A href="../users/new_user_guide.html"><B>New user's guide</B></A>
<B> | </B>
<A href="../users/abinis_help.html"><B>Abinis (main)</B></A>
<B> | </B>
<A href="../users/respfn_help.html"><B>Abinis (respfn)</B></A>
<B> | </B>
<A href="../users/mrgddb_help.html"><B>Mrgddb</B></A>
<B> | </B>
<A href="../users/anaddb_help.html"><B>Anaddb</B></A>
<B> | </B>
<A href="../users/aim_help.html"><B>AIM (Bader)</B></A>
<B> | </B>
<A href="../users/cut3d_help.html"><B>Cut3D</B></A>
<B> | </B>
<A href="../users/optic_help.html"><B>Optic</B></A>
<B> | </B>
<A href="../users/mrgscr_help.html"><B>Mrgscr</B></A>
<HR ALIGN=left>

</body>
</html>


