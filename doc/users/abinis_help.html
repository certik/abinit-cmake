<html>
<head>
<title>Abinis help file</title>
</head>
<body bgcolor="#ffffff">

<h1>Help file for the main code of the ABINIT package.</h1>


<h3>This document explains the i/o parameters and format needed 
for the main code (abinis) in the ABINIT package.</h3>

<p>The new user is advised to read first the 
  <a href="new_user_guide.html">new user's guide</a>,
  before reading the present file. It will be easier to discover the 
  present file with the help of the <a "href="../tutorial/welcome.html">tutorial</a>. 
<p>It is worthwhile to print this help file, for ease of reading.

<p>When the user will be sufficiently familiarized with ABINIT, reading the 
  ~abinit/doc/users/tuning.txt file might be useful (this file, as many additional
  documentation files, is not available on the Web, but is available in the package). 
  For response-function calculations using 
  abinis, the complementary respfn help file 
  <a href="respfn_help.html">~abinit/doc/users/respfn_help.html</a>
  is needed. 

<h5>Copyright (C) 1998-2008 ABINIT group (DCA, XG)
<br> This file is distributed under the terms of the GNU General Public License, see
~abinit/COPYING or <a href="http://www.gnu.org/copyleft/gpl.txt">
http://www.gnu.org/copyleft/gpl.txt </a>.
<br> For the initials of contributors, see ~abinit/doc/developers/contributors.txt .
</h5>

<HR ALIGN=left>
Goto :
<A href="http://www.abinit.org"><B>ABINIT home Page</B></A>
<B> | </B>
<A href="acknowledgments.html"><B>Suggested acknowledgments</B></A>
<B> | </B>
<A href="../input_variables/keyhr.html"><B>List of input variables</B></A>
<B> | </B>
<A "href="../tutorial/welcome.html"><B>Tutorial home page</B></A>
<B> | </B>
<A href="bibliography.html"><B>Bibliography</B></A>
<HR ALIGN=left>
Help files :
<A href="new_user_guide.html"><B>New user's guide</B></A>
<B> | </B>
<A href="abinis_help.html"><B>Abinis (main)</B></A>
<B> | </B>
<A href="respfn_help.html"><B>Abinis (respfn)</B></A>
<B> | </B>
<A href="mrgddb_help.html"><B>Mrgddb</B></A>
<B> | </B>
<A href="anaddb_help.html"><B>Anaddb</B></A>
<B> | </B>
<A href="aim_help.html"><B>AIM (Bader)</B></A>
<B> | </B>
<A href="cut3d_help.html"><B>Cut3D</B></A>
<B> | </B>
<A href="optic_help.html"><B>Optic</B></A>
<B> | </B>
<A href="mrgscr_help.html"><B>Mrgscr</B></A>
<HR ALIGN=left>


<h3><b> Content of the help file.</b></h3>
<ul>
  <li><a href="abinis_help.html#1">1. How to run the code</a> 
    <ul>
      <li><a href="abinis_help.html#intro1">1.1. Introducing the files file.</a> 
      <li><a href="abinis_help.html#exec">1.2. Running the code</a> 
    </ul>
  <li><a href="abinis_help.html#2">2. The underlying theoretical framework and 
    algorithms</a> 
  <li><a href="abinis_help.html#3">3. The input file</a> 
    <ul> 
      <li><a href="abinis_help.html#intro3">3.1. Format of the input file.</a> 
      <li><a href="abinis_help.html#parameters">3.2. More about ABINIT input variables.</a> 
      <li><a href="abinis_help.html#multidataset">3.3. The multi-dataset mode</a> 
      <li><a href="abinis_help.html#series">3.4. Defining a series</a> 
      <li><a href="abinis_help.html#loop">3.5. Defining a double loop dataset</a> 
      <li><a href="abinis_help.html#3.6">3.6. File names in the multi-dataset mode</a> 
    </ul>
  <li><a href="abinis_help.html#4">4. The files file</a> 
  <li><a href="abinis_help.html#5">5. The pseudopotential files</a> 
  <li><a href="abinis_help.html#6">6. The different output files</a> 
    <ul>
      <li><a href="abinis_help.html#logfile">6.1. The log file</a> 
      <li><a href="abinis_help.html#outputfile">6.2. The main output file</a> 
      <li><a href="abinis_help.html#6.3">6.3. More on the main output file</a> 
      <li><a href="abinis_help.html#header">6.4. The header</a> 
      <li><a href="abinis_help.html#densoutputfile">6.5. The density output file</a> 
      <li><a href="abinis_help.html#localpotfile">6.6. The potential files</a> 
      <li><a href="abinis_help.html#wavefctfile">6.7. The wavefunction output file</a> 
      <li><a href="abinis_help.html#other_output">6.8. Other output files</a> 
    </ul>
  <li><a href="abinis_help.html#7">7. Numerical quality of the calculations</a> 
  <li><a href="abinis_help.html#8">8. Final remarks</a> 
</ul>





<h3>&nbsp;</h3>
<hr>
<h3>&nbsp;</h3>
<h3><b><a name="1"></a>1. How to run the code </b></h3>


  <p><b><a name="intro1"></a>1.1. Introducing the files file.</b>
  <p>Given an input file (parameters described below) and the required pseudopotential 
    files, the user must create a "files" file which lists names for the files 
    the job will require, including the main input file, the main output file, 
    root names for other input, output, or temporary files, and different pseudopotential 
    file names. 
  <p>The files file (called for example ab.files) could look like: </p>
  <p> 
  <pre>
    ab_in
    ab_out
    abi
    abo
    tmp
    14si.psp
  </pre>
  <p>In this example:<br>
    - The main input file is called "ab_in". <br>
    - The main output will be put into the file called "ab_out". <br>
    - The name of input wavefunctions (if any) will be built from the root "abi" 
    (namely abi_WFK, see later). <br>
    - The output wavefunctions will be written to abo_WFK. Other output files
    might be build from this root. <br>
    - The temporary files will have a name that use the root "tmp".
(for example tmp_STATUS).<br>
    - The pseudopotential needed for this job is "14si.psp". <br>
    <br>
    Other examples are given in the subdirectories of the ~abinit/tests directory. The maximal length 
    of names for the main input or output files is presently 132 characters. It 
    is 112 characters for the root strings, since they will be supplemented by 
    different character strings. 
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>



  <h4>&nbsp;</h4>
  <h4><a name="exec"></a>1.2. Running the code</h4>
  <p>The main executable files are called abinis (sequential version), or abinip 
    (parallel version). In the present help file, we will concentrate on the sequential 
    version. There is a brief introduction to the use of the parallel version 
    in the ~abinit/doc/users/paral_use.txt file. Supposing that the "files" file is called ab.files, 
    and that the executable is placed in your working directory, abinis is run 
    interactively (in Unix) with the command 
  <ul>
    <li><i>abinis < ab.files >& log </i></li>
  </ul>
  <br>
  or, in the background, with the command 
  <ul>
    <li><i>abinis < ab.files >& log & </i></li>
  </ul>
  <p> where standard out and standard error are piped to the log file called "log" 
    (piping the standard error, thanks to the '&' sign placed after '>' 
    is <b>really important</b> for the analysis of eventual failures, when not due 
    to ABINIT, but to other sources, like disk full problem ...). The user can specify 
    any names he/she wishes for any of these files. Variations of the above commands 
    could be needed, depending on the flavor of UNIX that is used on the platform 
    that is considered for running the code. 
    <br>
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  <p>&nbsp; 
  <hr>


 <p><a name="2">&nbsp;</a></p>
 <h3><b>2. The underlying theoretical framework and algorithms</b> </h3>

  <p>See the "<a href="bibliography.html">bibliography</a>" file. 
  <p>The methods employed in this computer code to solve the electronic structure 
    problem are described in part in different review papers as well as research 
    papers. The code is an implementation of the Local Density Approximation to 
    the Density Functional Theory, based upon a plane wave basis set and separable 
    pseudopotentials. The iterative minimization algorithm is a combination of 
    fixed potential preconditioned conjugate gradient optimization of wavefunction 
    and a choice of different algorithms for the update of the potential, one 
    of which is a potential-based conjugate gradient algorithm. 
  <p>The representation of potential, density and wavefunctions in real space 
    will be done on a regular 3D grid of points. Its spacing will be determined 
    by the cut-off energy (see the input variable "<a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a>") 
    of the planewave basis in reciprocal space. This grid of points will also 
    be the starting point of Fast Fourier Transforms between real and reciprocal 
    space. The number of such points, called "<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>", 
    should be sufficiently large for adequate representation of the functions, 
    but not too large, for reasons of computational efficiency. The trade-off between 
    accuracy and computational efficiency is present in many places of the code, 
    and addressed briefly at the end of the present help file. 
  <p>We recommend a good introduction to many different concepts valid for this 
    code, available in a Reviews of Modern Physics article, ``<cite>Iterative 
    minimization techniques for ab initio total-energy calculations: molecular 
    dynamics and conjugate gradients</cite>'', <cite>M. C. Payne, M. P. Teter, 
    D. C. Allan, T. A. Arias, and J. D. Joannopoulos, Rev. Mod. Phys. 64, 1045-1097 
    (1992)</cite>. <br>
    This paper does NOT reflect the present status of the code. ABINIT is closer 
    in spirit to the paper of of Kresse and Furthmuller, see the <a href="bibliography.html">bibliography</a> list.
  <p> If you have never used another electronic structure code
    or a Quantum Chemistry package, you should browse through the Chaps. 1 to 13 , and appendices L and M
    of the book <cite>Electronic Structure. Basic Theory and Practical Methods. R. M. Martin.
    Cambridge University Press (2004) ISBN 0 521 78285 6.</cite> 
  <p>&nbsp; 
  <hr>
  <p>&nbsp;</p>



 <h3><a name="3">&nbsp;</a>3. The input file </h3>
  

  <p><b><a name="intro3"></a>3.1. Format of the input file.</b></p>

  <p>Note that this input file was called ab_in in the example of 
    <a href=#intro1> section 1.1</a> .<br>
    We first explain the content of the input file without use of the "multi-dataset" 
    possibility (that will be explained in <a href=#multidataset>section 3.3</a>). 

  <p> The parameters are input to the code from a single input file. Each parameter 
    value is provided by giving the name of the input variable and then placing the 
    numerical value(s) beside the name, separated by one or more spaces, or
    even an equal sign (equal signs are replaced by blanks by the parser). Depending
    on the input variable, the numerical value
    may be an integer or a real number (internal representation as double precision 
    number), and may actually represent an array of values. If it represents an 
    array, the next set of numbers separated by spaces are taken as the values 
    for the array. 
  <p> 
  <ul>
    <li>Do NOT separate a minus sign from the number to which it applies. </li>
    <li>Do NOT use tabs. </li>
    <li>NOTE THAT NO LINE OF THE INPUT FILE MAY EXCEED 132 CHARACTERS. That is, 
      only the first 132 characters of each line of the input file will be read 
      and parsed for input variables and their values. </li>
  </ul>
  <p>The names of all the parameters can be found in the
    <A href="../input_variables/keyhr.html">input variables</a> file.
    The list of input variables present in the latter file links them to their definitions,
    contained in different files, e.g. :
<ul>
<li> Basic variables, <A href="../input_variables/varbas.html">VARBAS</a></li>
<li> Developpement variables, <A href="../input_variables/vardev.html">VARDEV</a></li>
<li> Files handling variables, <A href="../input_variables/varfil.html">VARFIL</a></li>
<li> Geometry builder + symmetry related variables, <A href="../input_variables/vargeo.html">VARGEO</a></li>
<li> Ground-state calculation variables, <A href="../input_variables/vargs.html">VARGS</a></li>
<li> GW variables, <A href="../input_variables/vargw.html">VARGW</a></li>
<li> Internal variables, <A href="../input_variables/varint.html">VARINT</a></li>
<li> Parallelisation variables, <A href="../input_variables/varpar.html">VARPAR</a></li>
<li> Projector-Augmented Wave variables, <A href="../input_variables/varpaw.html">VARPAW</a></li>
<li> Response Function variables, <A href="../input_variables/varrf.html">VARRF</a></li>
<li> Structure optimization variables, <A href="../input_variables/varrlx.html">VARRLX</a></li>
<li> Wannier fonctions variables, <A href="../input_variables/varwan.html">VARWAN</a></li>
</ul>
    In the actual input file, these parameters may be given in any desired order,
    and more than one may be given per line. Spaces are used to separate values 
    and additional spaces are ignored. <br>
    An as example of input, the parameter for length scales is called 
    "<a href="../input_variables/varbas.html#acell" target="kwimg">acell</a>" 
    and is an array <a href="../input_variables/varbas.html#acell" target="kwimg">acell</a>(3) for 
    the lengths of the primitive translations in Bohr atomic 
    units. To input a typical Si diamond lattice one would have the line 
    <p>
    <code>
    acell 10.25311 10.25311 10.25311</code>
    <p>in the input file. This may equivalently be written 
    <p>
    <code>acell 3*10.25311</code> 
    <p>
    and will still be parsed correctly : it is equivalent to the above line. Even<p>
    <code>
    acell *10.25311 </code>
    <p>will work. In the latter case the '*' sign means that the parser should use the given value to fill the array, by
    repeating it as many time as needed.
    <br>
    Multiple spaces are ignored, as is any text which does not contain the character 
    strings which correspond to some input parameters. In case of arrays, only 
    the needed numbers will be considered, and the eventual numbers after those 
    needed will also be ignored. For example, 
    <p>
    <code><a href="../input_variables/varbas.html#natom" target="kwimg">natom</a> 3 # This gives 
    the number of atoms <br>
    <a href="../input_variables/varbas.html#typat" target="kwimg">typat</a> 1 1 2 2 3 # typat(1:natom) 
    gives the type of each atom : only <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 
    the first three data are read, since <a href="../input_variables/varbas.html#natom" target="kwimg">natom</a>=3 
    </code><br>
    <p>
    A given variable is identified by the parser by having at least one blank 
    before it and after it (again, multiple blanks are irrelevant). <br>
    ABINIT has also some (very limited) interpretor capabilities :
    <ul>
     <li>It can identify one slash sign (/) being placed between two numbers (without a separating blank) 
         as being the definition of a fraction (e.g. 1/3 will be interpreted
         as 0.33333333333333d0) ; </li>
     <li>It can identify sqrt(...) or -sqrt(...) as being the definition of a square root,
         when applied to one valid number - also without a separating blank - (e.g. -sqrt(0.75) will be interpreted
         as -0.8660254038d0) ; </li>
     <li>Note, however, that these capabilities are NOT recursive, and cannot be used
         one with the other (e.g. sqrt(3/4) is invalid). </li>
    </ul>
    Comments should be placed to the right of 
    the comment characters # or ! ; anything to the right of a "#" or a "!"
    on any line is simply ignored by the parser. 
    Additional text, not preceeded by a "#" or a "!" would not otherwise 
    cause trouble unless the text inadvertantly contained character 
    strings which were the same as variable names 
     (e.g. "<a href="../input_variables/varbas.html#acell" target="kwimg">acell</a>"). 
    The characters "#" or "!" can also be used to "store" old values 
    of variables or place anything else of convenience into the file 
    in such a way as to be 
    ignored by the parser when the data is read. <br>
    Case is irrelevant as the entire input string is mapped to upper case before 
    parsing, to remove case sensitivity. <br>
    More than one parameter per line may be given. If a given parameter name is 
    given more than once in the input file, an error message is printed, and the 
    code stops. 
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>


  <p>&nbsp;</p>
  <p><a name="parameters"></a><b>3.2. More about ABINIT input variables.</b></p>

  <p>In each section of the ABINIT input variables files,
    a generic information on the input variable is given : 
    a mnemonics, some "characteristics",
    the variable type, and the default. Then, follows the description of the variable.
  <p>The <b>mnemonics</b> is indicated when available. </p>
  <p>The "characteristics" can be of different types : <b>DEVELOP</b>,
    <b>RESPFN</b>, <b>GEOMETRY BUILDER</b>, <b>SYMMETRISER</b>,
    <b>SYMMETRY FINDER</b>, <b>NO MULTI</b>, <b>EVOLVING</b>, <b>ENERGY</b>, <b>LENGTH</b>.
    We now explain each of these classes.
  <p> '<b>DEVELOP</b>' refers to input variables that are not used in production runs,
    but only during development time. 
    For non developers, it is strongly advised to skip them. </p>
  <p>Some input variables are related to response function features, and are indicated 
    '<b>RESPFN</b>'. Detailed explanations related to response function features 
    are to be found in the complementary respfn help file
    <a href="respfn_help.html">~abinit/doc/users/respfn_help.html</a>. 
    The initials RF are used for 'response 
    function', and non-response-function are often referred to as GS (for ground-state), 
    although this latter designation is not really satisfactory. </p>
  <p>There are also parameters related to the geometry builder, a preprocessor 
    of the input file, aimed at easing the work of the user when there are molecules 
    to be manipulated (rotation and translation), or group of atoms to be repeated. 
    The indication '<b>GEOMETRY BUILDER</b>' is given for them. These can also 
    be skipped for the first few steps in the use of the code. <br>
    Indeed, it should be <i>easy to set up the geometry of systems with less than 
    20-40 atoms without this geometry builder</i>. Even for larger systems, its 
    functionalities could eventually be of no help. For a step-to-step description 
    of this geometry builder, look at the variable '<a href="../input_variables/vargeo.html#nobj" target="kwimg">nobj</a>'. 
  </p>
  <p>Alternatively to the geometry builder, there is also a symmetriser. It allows 
    to generate the full set of atoms in the primitive cell from the knowledge 
    of the symmetry operations and the atoms in the asymetric cell. It also allows 
    to generate the symmetry operations from the knowledge of the number of the 
    space group according to the international crystallographic tables. The indication 
    '<b>SYMMETRISER</b>' is given for the variables related to its use. Look at 
    the variable '<a href="../input_variables/vargeo.html#spgroup" target="kwimg">spgroup</a>'. 
    <br>
    You may find in the space group <a href="spacegrouphelpfile.html">help file</a> 
    the crystallographic equivalence of the parameters belonging to the symmetriser.</p>
  <p>Still as an alternative to the geometry builder and the symmetriser, if all 
    the coordinates of the atoms are given, the code is able to deduce all symmetry 
    operations leaving the lattice and atomic sublattices invariant, see '<b>SYMMETRY 
    FINDER</b>'. </p>
  <p>Most of the variables can be used in the multi-dataset mode (see  
    <a href=#multidataset>section 3.3</a>), 
    but those that must have a unique value throughout all the 
    datasets are signaled with the indication '<b>NO MULTI</b>' </p>
  <p>Most of the input variables do not change while a run is performed. Some 
    of them, by contrast, may evolve, like the atomic positions, the atomic velocities, 
    the cell shape, and the occupation numbers. Their echo, after the run has 
    proceeded, will of course differ from their input value. They are signaled 
    by the indication '<b>EVOLVING</b>'. </p>
  <a name="dimensions"></a>
  <p>The use of the atomic unit system (e.g. the Hartree for energy, about 27.211
    eV, and the Bohr for lengths about 0.529 Angstroms) is strictly
    enforced within the code. However, the dimension of some input variables 
    can be specified and read correctly. At present, this applies to two types
    of variables : those that have the dimension of an energy, and 
    those that have a dimension of length.  The first class of variables
    have the characteristics '<b>ENERGY</b>', and can be specified
    in atomic units (Hartree), or electron-volts, or Rydbergs, or even Kelvin.
    The second class
    of variables have the characteristics '<b>LENGTH</b>', and can be
    specified in atomic units (Bohr) and angstrom.
    The abinit parser recognize a dimension if it is specified after the
    list of numbers following the input variable keyword, in the input file.
    The specification can be upper or lower case, or a mix thereof.
    Here is the list of recognized chains of characters :
    <ul>
     <li> 'Ry ' => Rydberg (for energies) </li>
     <li> 'eV ' => electron-volts (for energies)  </li>
     <li> 'K ' => Kelvin (for energies)   </li>
     <li> 'Angstr...' => Angstrom (for lengths)  </li>
    </ul>
    Except in the case of 'Angstr', the abbreviation must be used (i.e. 'Rydberg'
    will not be recognized presently).
    Other character chains, like "au" (for atomic units) or "Hartree",
    or "Bohr" are not recognized,
    but make the parser choose (by default) atomic units, which is the correct behaviour.
    Example :
  <pre>
     acell 8 8 8 angstrom
     ecut 8 Ry
     tsmear 1000 K
  </pre>
   or
  <pre>
      acell 3*10 Bohr  ecut 270 eV  tsmear 0.01
  </pre>
    The use of the atomic units is mandatory for other dimensioned input variables, like
    the tolerance on forces (<a href="../input_variables/varbas.html#toldff" target="kwimg">toldff</a>), 
    parameters that define an 'object' (<a href="../input_variables/vargeo.html#objaax" target="kwimg">objaax, 
    objbax</a>, <a href="../input_variables/vargeo.html#objatr" target="kwimg">objatr, objbtr</a>), 
    and the initial velocity of atoms (<a href="../input_variables/varrlx.html#vel" target="kwimg">vel</a> 
    - if needed). </p>
  <p>The initial atomic positions can be input in Bohr or Angstrom through '<a href="../input_variables/varbas.html#xcart" target="kwimg">xcart</a>', 
    but also, independently, in Angstrom through '<a href="../input_variables/varbas.html#xangst" target="kwimg">xangst</a>', 
    or even in reduced coordinates, through '<a href="../input_variables/varbas.html#xred" target="kwimg">xred</a>'. 
    Reduced cartesian coordinates must be used for the eventual translations accompanying 
    symmetry operations (<a href="../input_variables/varbas.html#tnons" target="kwimg">tnons</a>). 
  </p>

  <p><a name="chkexit">In addition to giving the input variables</a>, 
     the input file can be useful 
     for another purpose : placing the word "<b>exit</b>" on the top line 
     will cause the job to
     end smoothly on the very next iteration, if the
     <a href="../input_variables/vargs.html#chkexit" target="kwimg">chkexit</a> input variable is non-zero.  This functions because
     the program closes and reopens the input file on every iteration
     and checks the top line for the keyword "exit".  THE WORD MUST BE
     PLACED WITH SPACES (BLANKS) ON BOTH SIDES.  Thus placing exit on the top
     line of the input file WHILE THE JOB IS ALREADY RUNNING will force
     the job to end smoothly on the very next iteration.
     On some machines, this does not work always (we do not know why...).
     Another possibility is offered :
     one can create a file named "abinit.exit" in the directory where
     the job was started. The code should also smoothly end.
     In both cases, the stop is not immediate. It can take a significant
     fraction (about 20% at most) of one SCF step to execute properly the
     instruction still needed.

  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  <p>&nbsp; 


  <p><b><a name="multidataset"></a>3.3. The multi-dataset mode.</b> 
  <p>Until now, we have assumed that the user wants to make computations corresponding 
    to one set of data : for example, determination of the total energy for some 
    geometry, with some set of plane waves and some set of k-points. </p>
  <p>It is often needed to redo the calculations for different values of some 
    parameter, letting all the other things equal. As typical examples, we have 
    convergence studies needed to determine which cut-off energy gives the needed 
    accuracy. In other cases, one makes chains of calculations in order to compute 
    the band structure : first a self-consistent calculation of the density and 
    potential, then the eigenenergy computation along different lines. </p>
  <p>For that purpose, the <b>multi-dataset mode</b> has been implemented. </p>
  <p>It allows the code to treat, in one run, different sets of data, and to chain 
    them. The number of datasets to be treated is specified by the variable 
    <a href="../input_variables/varbas.html#ndtset" target="kwimg">ndtset</a>, 
    while the indices of the datasets (by default 1, 2, 3, 
    and so on) can be eventually provided by the array <a href="../input_variables/varbas.html#jdtset" target="kwimg">jdtset</a>. 
  </p>
  <p>For each dataset to be treated, characterized by some index, each input variable 
    will determined by the following <b>rules</b> (actually, it is easier to understand 
    when one looks at examples, see below) : </p>
  <ul>
    <li> (<a name="ref8_1"></a>1) ABINIT looks whether the variable name (e.g. 
      <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a> ), appended with the 
      index of the dataset (e.g. <a href="../input_variables/varbas.html#jdtset" target="kwimg">jdtset</a>=2), 
      exists (e.g. "ecut2" ) . It 
      will take the data that follows this keyword, if it exists.</li>
    <li> (<a name="ref8_2"></a>2) If this modified variable name does not exist, 
      it will look whether a metacharacter, a series or a double-loop data set 
      has been defined, see sections
      <a href=#series>3.4</a> or <a href=#loop>3.5</a>.</li>
    <li> (<a name="ref8_3"></a>3) If the variable name appended with the index 
      of the dataset does not exist, and if there is no series nor double-loop 
      dataset for this keyword, it looks for an occurence of the variable name 
      without any index appended, and take the corresponding data. (This corresponds 
      to the single dataset mode)</li>
    <li> (<a name="ref8_4"></a>4) If such occurences do not exist, it takes the 
      default value. (Also, similar to the single dataset mode)</li>
  </ul>
  <pre>     
     ---------------

     1st example. 

     ndtset   2   
      acell   8 8 8
       ecut1  10
       ecut2  15
</pre>
  means that there are 2 datasets : a first in which 
  <pre>     acell 8 8 8  ecut 10 </pre>
  has to be used, and a second in which 
  <pre>     acell 8 8 8  ecut 15</pre>
  has to be used. 
  <pre>
     ------------------

     2nd example

     ndtset 2     jdtset 4 5

     acell   8 8 8
     acell5 10 10 10
     ecut1  10
     ecut2  15
     ecut3  20
     ecut4  25
     ecut5  30
</pre>
  <p>this means that there are still two datasets, but now characterized by the 
    indices 4 and 5, so that the first run will use the generic "acell", 
    and "ecut4" : 
  <pre>     acell 8 8 8 ecut 25 
</pre>
  and the second run will use "acell5" 
  and "ecut5" : 
  <pre>     acell 10 10 10 ecut 30 </pre>
  <p>Note that ecut1, ecut2 and ecut3 are not used. </p> 
  <h4>&nbsp;</h4>
  
<h4><a name="series"></a>3.4. Defining a series. </h4>

Rule (2) is split in three parts : (2a), (2b) and (2c). 
<br> Series relate with (2b): 
<p>
(<a name="ref8_2b"></a>2b) If the variable name appended with the index of the 
dataset does not exist, the code looks whether a series has been defined for this 
keyword. 
<p>There are two kinds of series : 
<ul>
    <li>arithmetic series (constant <i>increment</i> between terms of the series) 
    <li> geometric series (constant <i>ratio</i> between terms of the series) 
  </ul>
  <p>The first term of the series is defined by the keyword appended with a colon 
    (e.g. <b>ecut:</b> ), while the increment of an arithmetic series is defined 
    by the keyword appended with a plus (e.g. <b>ecut+</b> ), and the factor of 
    a geometric series is defined by the keyword appended with a times (e.g. <b>ecut*</b> 
    ). </p>
  <p>If the index of the dataset is 1, the first term of the series is used, while 
    for index N , the appropriate input data is obtained by considering the Nth 
    term of the series. </p>
  <pre>
  ------------------

  3rd example 

    ndtset 6 
    ecut1 10 
    ecut2 15 
    ecut3 20 
    ecut4 25 
    ecut5 30 
    ecut6 35 
</pre>
  is equivalent to 
  <pre>    ndtset 6 ecut: 10 ecut+ 5 
</pre>
  <p>In both cases, there are six datasets, with increasing values of <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a>. 
  </p>
  <h4>&nbsp; </h4>
  
<h4><a name="loop"></a>3.5. Defining a double loop dataset </h4>
  <p>To define a double loop dataset, one has first to define the upper limit 
    of two loop counters, thanks to the variable <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>. 
    The inner loop will execute from 1 to <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>(2), 
    and the outer loop will execute from 1 to <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>(1). 
    Note that the largest value for <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>(1) 
    and <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>(2) is 9 presently. </p>
  <p>The value of <a href="../input_variables/varbas.html#ndtset" target="kwimg">ndtset</a> must 
    be coherent with <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a> (it 
    must equal the product <code>udtset(1)*udtset(2)</code> ). </p>
  <p>A dataset index is created by the concatenation of the outer loop index and 
    the inner loop index. <br>
    For example, if <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>(1) 
    is 2 and <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>(2) is 4, 
    the index will assume the following values : <code>11, 12, 13, 14, 21, 22, 
    23, and 24</code>. 
  <p> Independently of the use of <a href="../input_variables/varbas.html#udtset" target="kwimg">udtset</a>, 
    rules (2a) and (2c) will be used to define the value of an input variable: </p>
  <p><a name="ref8_2a"></a>(2a) The question mark "<b>?</b>" can be used as a 
    metacharacter, replacing any digit from 1 to 9, to define an index of a dataset. 
    <br>
    For example, <b>ecut?</b>1 means that the input value that follows it can 
    be used for <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a> for the datasets 
    <code>01, 11, 21, 31, 41, 51, 61, 71, 81, and 91</code>. </p>
  <p><a name="ref8_2c"></a>(2c) If the variable name appended with the index of 
    the dataset does not exist, the code looks whether a double-loop series has 
    been defined for this keyword. Series can be defined for the inner loop index 
    or the outer loop index. Two signs will be appended to the variable name (instead 
    of one in the simple series case). One of these signs must be a question mark 
    "<b>?</b>", again used as a metacharacter able to assume the values 1 to 9.<br>
    If it is found in the first of the two positions, it means that the series 
    does not care about the outer loop index (so the values generated are equal 
    for all outer loop index values). If it is found in the second of the two 
    positions, the series does not care about the inner loop index. The other 
    sign can be a colon, a plus or a times, as in the case of the series defined 
    in <a href="abinis_help.html#ref8_2a">(2a)</a>, with the same meaning. </p>
  <p>Rule (<a href="abinis_help.html#ref8_1">1</a>) has precedence over them,  
    they have precedence over rules (<a href="abinis_help.html#ref8_3">3</a>) or
    (<a href="abinis_help.html#ref8_4">4</a>), rule (<a href="abinis_help.html#ref8_2a">2a</a>)
    has precedence over rules <a href="abinis_help.html#ref8_2b">(2b)</a> or <a href="abinis_help.html#ref8_2c">(2c)</a>
    and the two latter cannot be used simultaneously for the same variable. </p>


  <pre>     
     ------------------

     4th example
     ndtset 6    udtset 2 3
     acell1?  10 10 10
     acell2?  15 15 15
     ecut?: 5    ecut?+ 1
</pre>
  is equivalent to 
  <pre>
     ndtset 6     jdtset 11 12 13  21 22 23   
     acell11  10 10 10     ecut11 5
     acell12  10 10 10     ecut12 6
     acell13  10 10 10     ecut13 7
     acell21  15 15 15     ecut21 5
     acell22  15 15 15     ecut22 6
     acell23  15 15 15     ecut23 7
</pre>
  <p><i>More examples can be found in the directory ~abinit/tests/v1, cases 59 and later.</i> 
  </p>

  <h4>&nbsp; </h4>

<h4><a name="3.6"></a>3.6. File names in the multi-dataset mode.</h4>

  <p>The root names for input and output files (potential, density, wavefunctions 
    and so on) will receive an appendix : '<b>_DS</b>' followed by the index of 
    the dataset. See <a href="abinis_help.html#4">section 4</a>. </p>
  <p><a name="get">The '<b>get</b>' variables</a> can be used to chain the calculations. </p>
  <p>Until now, there are eight of them : <a href="../input_variables/varfil.html#getwfk" target="kwimg">getwfk</a>, 
    <a href="../input_variables/varfil.html#getwfq" target="kwimg">getwfq</a>, <a href="../input_variables/varfil.html#getddk" target="kwimg">getddk</a>, 
    <a href="../input_variables/varfil.html#get1wf" target="kwimg">get1wf</a>, <a href="../input_variables/varfil.html#getden" target="kwimg">getden</a>, 
    <a href="../input_variables/varrlx.html#getcell" target="kwimg">getcell</a>, <a href="../input_variables/varrlx.html#getxred" target="kwimg">getxred</a> 
    and <a href="../input_variables/varrlx.html#getxcart" target="kwimg">getxcart</a>.</p>
  <p> 
  <ul>
    <li><a href="../input_variables/varfil.html#getwfk" target="kwimg">getwfk</a> allows to take 
      the output wavefunctions of a previous dataset and use them as input wavefunctions 
    <li> <a href="../input_variables/varfil.html#getwfq" target="kwimg">getwfq</a>, <a href="../input_variables/varfil.html#getddk" target="kwimg">getddk</a> 
      and <a href="../input_variables/varfil.html#get1wf" target="kwimg">get1wf</a> do similar things 
      for response function calculations 
    <li><a href="../input_variables/varfil.html#getden" target="kwimg">getden</a> does the same 
      for the density ; <a href="../input_variables/varrlx.html#getcell" target="kwimg">getcell</a> 
      does the same for <a href="../input_variables/varbas.html#acell" target="kwimg">acell</a> 
      and <a href="../input_variables/varbas.html#rprim" target="kwimg">rprim</a> 
    <li><a href="../input_variables/varrlx.html#getxred" target="kwimg">getxred</a> and <a href="../input_variables/varrlx.html#getxcart" target="kwimg">getxcart</a> 
      do the same for the atomic positions, either in reduced coordinates, or 
      in cartesian coordinates. 
  </ul>
  <p>The different variables corresponding to each dataset are echoed using the 
    same indexing convention as for the input step. For the last echo of the code 
    variables, some output variables are also summarized, using the same conventions 
    : 
  <ul>
    <li><b>etotal</b> (total energy) 
    <li><b>fcart</b> (cartesian forces) 
    <li><b>strten</b> (the stress tensor). 
  </ul>
  <p> 
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  
<p>&nbsp;</p><hr>
<p>&nbsp;</p>
<h3><a name="4"></a>4. The "files" file</h3>
  <p>Note: <i>This "files" file is called ab.files in 
  <a href=#intro1>section 1.1</a> .</i> 
  </p>
  <p>Contains the file names or root names needed to build file names. 
    These are listed below : there are 5 names or root names for input, 
    output and temporaries, and then a list of pseudopotentials. 
    These names may be provided from unit 05 interactively during the run but 
    are more typically provided by piping from a file in unix (the "files" file). </p>
  <p> <b>ab_in</b> <br>
    Filename of file containing the input data, described in the preceeding sections.
  <p><b>ab_out</b><br>
    Filename of the main file in which formatted output will be placed (the main output file). 
    Error messages 
    and other diagnostics will NOT be placed in this file, but sent to unit 06 
    (terminal or log file); the unit 06 output can be ignored unless something 
    goes wrong. The code repeats a lot of information to both unit 06 and to the 
    main output file. The unit 06 output is intended to be discarded if the run 
    completes successfully, with the main output file keeping the record of the 
    run in a nicer looking format. 
  <p><b>abi</b> <br>
    The other files READ by the code will have a name that is constructed from 
    the root "abi". This apply to optionally read wavefunction, density or potential 
    files. In the multi-dataset mode, this root will be complemented by<a name="ds"></a> 
    '<b>_DS</b>' and the dataset index. The list of possible input files, with 
    their name created from the root 'abi' is the following (a similar list exist 
    when '<b>_DS</b>' and the dataset index are appended to 'abi'): 
  <ul>
    <li> 
      <p><b>abi_WFK</b> <br>
        filename of file containing input wavefunction coefficients created from 
        an earlier run (with <a href="../input_variables/vargs.html#nqpt" target="kwimg">nqpt</a>=0). 
        Will be opened and read if <a href="../input_variables/varfil.html#irdwfk" target="kwimg">irdwfk</a> 
        is 1 . The wavefunction file is unformatted and can be very large.
        <b>Warning</b> : in the multi dataset mode, if getwfk is non-zero, a wavefunction
        file build from <b>abo</b> will be read. </p>
    <li> 
      <p><b>abi_WFQ</b> <br>
        filename of file containing input wavefunction coefficients created from 
        an earlier run (with <a href="../input_variables/vargs.html#nqpt" target="kwimg">nqpt</a>=1), 
        as needed for response function calculations.
        The wavefunction file is unformatted and can be very large.
        <b>Warning</b> : in the multi dataset mode, if getwfk is non-zero, a wavefunction
        file build from <b>abo</b> will be read.</p>
    <li> 
      <p><b>abi_1WFxx</b> <br>
        filename of file containing input first-order wavefunctions created from 
        an earlier RF run. xx is the index of the perturbation </p>
    <li> 
      <p><b>abi_DEN</b> <br>
        filename of file containing density created from an earlier run. See explanations 
        related to negative values of <a href="../input_variables/varbas.html#iscf" target="kwimg">iscf</a>. 
        This file is also unformatted. 
        <b>Warning</b> : in the multi dataset mode, if getwfk is non-zero, a density
        file build from <b>abo</b> will be read.</p>
    <li> 
      <p><b>abi_HES</b> <br>
        filename of file containing an approximate hessian, for eventual (re)initialisation 
        of Broyden minimisation. See brdmin.F90 routine. 
        The use of <a href="../input_variables/varrlx.html#restartxf" target="kwimg">restartxf</a> 
        is preferred.</p>
  </ul>
  <p><b>abo</b> <br>
    Except "ab_out" and "log", the other files WRITTEN by the code will have a name 
    that is constructed from the root "abo". 
    This apply to optionally written wavefunction, density, potential, 
    or density of states files. In the multi-dataset mode, this root will be complemented 
    by <a name="ds"></a>'<b>_DS</b>' and the dataset index. 
    Also in the multi-dataset mode, the root "abo" can be used to build
    the name of <b>input</b> files, thanks to the 
    <a href=#get>'get' variables</a>. The list of possible 
    output files, with their name created from the root 'abo' is the following 
    (a similar list exists when '<b>_DS</b>' and the dataset index are appended to 'abo') : 
  <ul>
    <li> 
      <p><b>abo_WFK</b> <br>
        Filename of file containing output wavefunction coefficients, if <a href="../input_variables/vargs.html#nqpt" target="kwimg">nqpt</a>=0. 
        The wavefunction file is unformatted and can be very large. </p>
    <li> 
      <p><b>abo_WFQ</b> <br>
        Same as <b>abo_WFK</b>, but for the case <a href="../input_variables/vargs.html#nqpt" target="kwimg">nqpt</a>=1. 
        The wavefunctions are always output, either with the name <b>abo_WFK</b>, 
        or with the name <b>abo_WFQ</b>. </p>
    <li> 
      <p><b>abo_1WFxx</b> <br>
        Same as <b>abo_WFK</b>, but for first-order wavefunctions, xx is the index 
        of the perturbation, see the section <a href="respfn_help.html#6.3">6.3</a> 
        of the respfn_help.html file. </p>
    <li>
      <p><b>abo_DDB</b> <br>
        The derivative database, produced by a response-function dataset,
        see the section <a href="respfn_help.html#6.5">6.5</a> of the
        respfn_help.html file.</p>
    <li> 
      <p><b>abo_DEN</b> <br>
        filename of file containing density, in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=0. 
        See the keyword <a href="../input_variables/varfil.html#prtden" target="kwimg">prtden</a>. 
        This file is unformatted, but can be read by cut3d. </p>
    <li> 
      <p><b>abo_TIMx_DEN</b> <br>
        filenames of files containing density, in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>/=0. 
        The value of "x" after "<b>TIM</b>" is described hereafter. See the keyword 
        <a href="../input_variables/varfil.html#prtden" target="kwimg">prtden</a>. This file is 
        unformatted, but can be read by cut3d. </p>
    <li> 
      <p><b>abo_POT</b> <br>
        filename of file containing Kohn-Sham potential See the keyword <a href="../input_variables/varfil.html#prtpot" target="kwimg">prtpot</a>. 
        This file is unformatted, but can be read by cut3d. </p>
    <li> 
      <p><b>abo_TIMx_POT</b> <br>
        filenames of files containing Kohn-Sham potential in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>/=0. 
        The value of "x" after "TIM" is described hereafter. See the keyword <a href="../input_variables/varfil.html#prtpot" target="kwimg">prtpot</a>. 
        This file is unformatted, but can be read by cut3d. </p>
    <li> 
      <p><b>abo_DOS</b> <br>
        filename of file containing density of states. See the keyword 
        <a href="../input_variables/varfil.html#prtdos" target="kwimg">prtdos</a>. This file is 
        formatted. </p>
    <li>
      <p><b>abo_TIMx_DOS</b> <br>
        filenames of files containing the density of states
        in the case  <a href="../input_variables/varfil.html#prtdos" target="kwimg">prtdos</a>=2 
        and <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=1
        or 2. The value of "x" after "TIM" is described hereafter. See also the
        keyword <a href="../input_variables/varfil.html#prtdos" target="kwimg">prtdos</a>. This
        file is formatted. </p>
    <li> 
      <p><b>abo_GEO</b> <br>
        filename of file containing the geometrical analysis (bond lengths and 
        bond angles) in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=0. 
        See the keyword <a href="../input_variables/varfil.html#prtgeo" target="kwimg">prtgeo</a>. 
        This file is formatted. </p>
    <li> 
      <p><b>abo_TIMx_GEO</b> <br>
        filenames of files containing the geometrical analysis (bond lengths and 
        bond angles) in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=1 
        or 2. The value of "x" after "TIM" is described hereafter. See also the 
        keyword <a href="../input_variables/varfil.html#prtgeo" target="kwimg">prtgeo</a>. This 
        file is formatted. </p>
    <li>
      <p><b>abo_CML.xml</b> <br>
        filename of file containing the Chemical Markup Language description of the system
        (crystallographic data, symmetry data, atomic symbols and reduced coordinates) 
        in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=0.
        See the keyword <a href="../input_variables/varfil.html#prtcml" target="kwimg">prtcml</a>.
        This file is formatted. </p>
    <li>
      <p><b>abo_TIMx_GEO</b> <br>
        filenames of files containing the  Chemical Markup Language description of the system
        (crystallographic data, symmetry data, atomic symbols and reduced coordinates)
        in the case <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=1
        or 2. The value of "x" after "TIM" is described hereafter. See also the
        keyword <a href="../input_variables/varfil.html#prtcml" target="kwimg">prtcml</a>. This
        file is formatted. </p>
    <li>
      <p><b>abo_KSS</b> <br>
        filename of file containing output wavefunction coefficients, if <a href="../input_variables/vargw.html#nbandkss" target="kwimg">nbandkss</a>/=0.
        This wavefunction file is unformatted and can be very large. 
        Its purpose is to start a GW calculation using M.Torrent's code.
        A different format than for <b>abo_WFK</b> is used, see the file ~abinit/doc/developers/format_KSS.txt .</p>
     <li>
      <p><b>abo_EIG</b> <br> 
        A file containing the electronic eigenvalues, for subsequent plotting of band structure.</p>
  </ul>
  <p>When <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>/=0, 
    the <b>POT</b>, <b>DEN</b>, <b>GEO</b>, or <b>CML.xml</b> files are output 
    each time that a SCF cycle is finished. The "<b>x</b>" of <b>TIMx</b> aims 
    at giving each of these files a different name. It is attributed as follows:<br>
    - case ionmov==1 : there is an initialization phase, that takes 4 calls 
    to the SCF calculation. The value of x will be A, B, C, and D. Then, x will 
    be 1, 2, 3 ... , actually in agreement with the value of itime (see the keyword 
    <a href="../input_variables/varrlx.html#ntime" target="kwimg">ntime</a>) <br>
    - other ionmov cases : the initialisation phase take only one SCF call. 
    The value of x will be 0 for that call. Then, the value of x is 1, 2, 3 ... 
    in agreement with the value of itime (see the keyword <a href="../input_variables/varrlx.html#ntime" target="kwimg">ntime</a>) 
  </p>
  <p><b>tmp</b> <br>
    The temporary files created by the codes will have a name that is constructed 
    from the root "<b>tmp</b>". tmp should usually be chosen such as to give access 
    to a disk of the machine that is running the job, not a remote (NFS) disk. 
    Under Unix, the name might be something like <code>/tmp/user_name/temp</code>. 
    The most important temporary files, with their name created from the root "tmp" is 
    the following : 
  <ul>
    <p><b>tmp_FFT</b> <br>
      not created if <a href="../input_variables/varfil.html#mffmem" target="kwimg">mffmem</a>==1, 
      contains a few arrays defined in real space on the FFT grid. </p>
    <p><b>tmp_KG</b> <br>
      not created if <a href="../input_variables/varfil.html#mkmem" target="kwimg">mkmem</a>=<a href="../input_variables/varbas.html#nkpt" target="kwimg">nkpt</a>, 
      contains the data on G vectors inside the sphere around the different k 
      points </p>
    <p><b>tmp_KGS</b> <br>
      created if <a href="../input_variables/vargs.html#iprcel" target="kwimg">iprcel</a>/=0, contains 
      the data on G vectors inside the sphere around the different k points, for 
      the computation of the susceptibility </p>
    <p><b>tmp_WF1</b> and <b>tmp_WF2</b> <br>
      not created if <a href="../input_variables/varfil.html#mkmem" target="kwimg">mkmem</a>=<a href="../input_variables/varbas.html#nkpt" target="kwimg">nkpt</a>, 
      contains the wavefunctions in the process of the calculation </p>
    <p><b>tmp_STATUS</b> <br>
      gives the status of advancement of the calculation, and is updated very 
      frequently </p>
  </ul>
  <p><b>psp1</b> <br>
    filename of first pseudopotential input file. The pseudopotential data files 
    are formatted. There must be as many filenames provided sequentially here 
    as there are types of atoms in the system, and the order in which the names 
    are given establishes the identity of the atoms in the unit cell. (psp2, psp3, 
    ... ) 
  <p>&nbsp;
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  <p>&nbsp; 
  <hr>
  <p>&nbsp; 
  <h3><a name="5">&nbsp;</a> <b>5. The pseudopotential files</b></h3>
  <p>Actually, no real understanding of these files 
    is needed to run the code, but for different other reasons, it might be useful 
    to be able to understand the file structures. Different format are possible 
    (labelled 1 to 7 presently) The associated internal variable is called pspcod. 
    Examples of use are found in ~abinit/test/v1 . Information on the file structure 
    can be found in the ~abinit/doc/psp_infos directory. 
  <ul>
    <li>pspcod=1 : Troullier-Martins pseudopotentials, generated by DC Allan and 
      A Khein, see ~abinit/doc/psp_infos/psp1_info.txt ;
    <li>pspcod=2 : Goedecker-Teter-Hutter (GTH) pseudopotentials. See Phys. Rev. 
      B 54, 1703 (1996) if needed ;
    <li>pspcod=3 : Hartwigsen-Goedecker-Hutter pseudopotentials. See Phys. Rev. 
      B 58, 3641 (1998) if needed, and the file ~abinit/doc/psp_infos/psp3_info.txt ; 
    <li>pspcod=4 or 5 : old format pseudopotentials, see ~abinit/doc/psp_infos/psp45_info.txt ;
    <li>pspcod=6 : pseudopotentials from the fhi98pp code, see ~abinit/doc/psp_infos/psp6_info.txt ;
    <li>pspcod=7 : pseudo atomic data for PAW ;
    <li>pspcod=8 : pseudopotential file format from Don Hamann, providing additional flexibility.
  </ul>
  <p>&nbsp; 
  <hr>




  <p> <a name="6">&nbsp;</a> 
  <h3><b>6. The different output files</b></h3>
  <p>Explanation of the output from the code 
  <p>Output from the code goes to several places listed below. 
  <p>&nbsp; 


  <p><b><a name="logfile"></a>6.1. The log file</b> </p>
  <p>The "log" file (this is the standard UNIX output file, and corresponds to 
    Fortran unit number 06) : a file which echoes the values of the input parameters 
    and describes various steps of the calculation, typically in much more detail 
    than is desired as a permanent record of the run. This log file is intended 
    to be informative in case of an error or for a fuller description of the run. 
    For a successful run the user will generally delete the log file afterwards. 
    There are four types of exception messages : <b>ERROR</b>, <b>BUG</b>, <b>WARNING</b> 
    and <b>COMMENT</b> messages. </p>
  <p><b>ERROR</b> and <b>BUG</b> messages cause the code to stop, immediately, 
    or after a very small delay. An <b>ERROR</b> is attributed to the user, while 
    a <b>BUG</b> is attributed to the developer. </p>
  <p>A <b>WARNING</b> message indicates that something happened that is not as 
    expected, but this something is not so important as to make the code stop. 
    A <b>COMMENT</b> message gives some information to the user, concerning something 
    unusual. None of them should appear when the run is completely normal. 
    <p> 
    After a run is completed, always have a look at the end of the log file, to 
    see whether an <b>ERROR</b> or a <b>BUG</b> occurred. <br>
    <p> Also, the code gives the number of <b>WARNING</b> or <b>COMMENT</b> it issued. 
    It is advised to read at least the <b>WARNING</b> messages, during the
    first month of ABINIT use. </p>

  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>



  <p>&nbsp; 
  <p><a name="outputfile"></a><b>6.2. The main output file </b> 
  <p>The <b>main output file</b> is a formatted output file to be kept as the permanent 
    record of the run. </p>
  <p>Note that it is expected <b>not</b> to exist at the beginning of the run: 
    <br>
    If a file with the name specified in the "files" file already exists, the 
    code will generate, from the given one, another name, appended with <b>.A</b> 
    . If this new name already exists, it will try to append <b>.B</b> , and so 
    on, until <b>.Z</b> . <br>
    Then, the code stops, and asks you to clean the directory. </p>
  <p>The <b>main output file</b> starts with a heading: 
  <ul>
    <li>version number and specified platform 
    <li>copyright notice and distribution licence
    <li>date 
    <li>echo of "files" file (except pseudopotential name)
  </ul>
  <p></p>
  <p>Then, for each dataset, it reports the point symmetry group and Bravais lattice,
    and the expected memory needs. It echoes 
    the input data, and report on checks of data consistency for each dataset. </p>
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  <p>&nbsp; 
  
<p><b><a name="6.3"></a>6.3. More on the main output file </b></p>
  <p> Then, for each dataset, the real computation is done, and the code will 
    report on some initialisations, the SCF convergence, and the final analysis of 
    results for this dataset. Each of these phases is now described in more details. 
    <p>
    The code reports: 
  <ul>
    <li>the real and reciprocal space translation vectors (<i>Note</i>: the definition 
      of the reciprocal vector is such that R<sub>i</sub>.G<sub>j</sub>= 
      delta<sub>ij</sub>)</li>
    <li>the volume of the unit cell</li>
    <li>the ratio between linear dimension of the FFT box and the sphere of plane 
      waves, called "<b>boxcut</b>". <br>
      It must be above 2 for exact treatment of convolutions by FFT. 
      <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a> 
      has been automatically chosen to give a boxcut value larger than 2, but 
      not much larger, since more CPU time is needed for larger FFT grids; </li>
    <li> the code also mention that for the same FFT grid you might treat (slightly) 
      larger <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a> 
      (so, with a rather small increase of CPU time) </li>
    <li>the heading for each pseudopotential which has been input 
    <li>from the inwffil subroutine, a description of the wavefunction initialization 
      (random number initialization 
      or input from a disk file), that is, a report of the number of planewaves 
      (npw) in the basis at each k point</li>
    <li>from the setup2 subroutine, the average number of planewaves over all k points 
      is reported in two forms, arithmetic average and geometric average. </li>
  </ul>
  Until here, the output of a ground-state computation is identical
  to the one of a response-function calculation. 
  See the <a href="respfn_help.html">respfn_help</a> document for the latter,
  especially section <a href="respfn_help.html#6.2">6.2</a>.
  <p>
  Next the code reports information for each SCF iteration: 
  <ul>
    <li>the iteration number 
    <li>the (pseudo) total energy (Etot) in Hartree [This is not the total energy of the system, since the pseudopotential approximation has been made : a constant energy (in the frozen-core approximation) should be added to the present pseudo total energy in order to obtain a total energy, that includes the contributionts from the core electrons. Since only differences of total energy matter (except is extremely rare cases), one can work with this pseudo energy like if it were the true total energy, except that the missing constant depends on the pseudopotential that has been used. Thus one has to perform differences of pseudo energies between simulations that use the same pseudopotentials]. 
    <li>the change in Etot since last iteration (deltaE) 
    <li> the maximum squared residual residm over all bands and k points (residm 
      - the residual measures the quality of the wavefunction convergence) 
    <li>the squared residual of the potential in the SCF procedure (vres2) 
    <li>the maximum change in the gradients of Etot with respect to fractional 
      coordinates (diffor, in Hartree) 
    <li> the rms value of the gradients of Etot with respect to fractional coordinates 
      (maxfor, in Hartree).<br>
      <i>The latter two are directly related to forces on each atom.</i> 
    <li>Then comes an assessment of the SCF convergence : the criterion for fulfillment 
      of the SCF criterion (defined by <a href="../input_variables/varbas.html#toldfe" target="kwimg">toldfe</a>, 
      <a href="../input_variables/varbas.html#toldff" target="kwimg">toldff</a>, <a href="../input_variables/varbas.html#tolwfr" target="kwimg">tolwfr</a> 
      or <a href="../input_variables/varbas.html#tolvrs" target="kwimg">tolvrs</a>) might be satisfied 
      or not ... 
    <li>Then the stresses are reported. 
  </ul>
  <p>This ends the content of a fixed atomic position calculation. </p>
  <p>Many such blocks can follow. </p>
  <p>When the atomic positions have been eventually relaxed, according to the 
    value of <a href="../input_variables/varrlx.html#ntime" target="kwimg">ntime</a>, the code output 
    more information: 
  <ul>
    <li>The squared residuals for each band are reported, k point by k point. 
    <li> Then the fractional or reduced coordinates are given, 
    <li>followed by the energy gradients, 
    <li>followed by the cartesian coordinates in Angstroms, 
    <li>followed by the cartesian forces in Hartree/Bohr and eV/Angstrom. 
    <li>Also are given the rms force (<b>frms</b>) and the maximum absolute value 
      of any force component (<b>max</b>). 
    <li>Next are the length scales of the unit cell in Bohr and in Angstroms. 
    <li>Next are the eigenvalues of each band for each k point, in eV or Hartree 
      or both depending on the choice of <a href="../input_variables/vargs.html#enunit" target="kwimg">enunit</a>. <br>
      <a name="averagepot"> NOTE </a>
      that the average electrostatic potential of a periodically repeated 
      cell is UNDEFINED. <br>
      In the present implementation, the average Hartree potential and local potential are imposed 
      to be zero, but not the average exchange-correlation potential. 
      This definition gives some meaning to
      the absolute values of eigenenergies, thanks to Janak's theorem: they
      are derivatives of the total energy with respect to occupation number.
      Indeed, the G=0 contributions of the Hartree, local potential and ion-ion
      to the total energy is independent of the occupation number 
      in the present implementation.
      With this noticeable exception, one should always work with <b>differences</b> 
      in eigenenergies, as well as <b>differences</b> between eigenenergies and the potential. 
      For example, the absolute eigenenergies of a bulk cell should not be used
      to try to predict a work function. The latter quantity should be obtained
      in a supercell geometry, by comparing the Fermi energy in a slab and the potential
      in the vacuum in the same supercell.
    <li>Next are the minimum and maximum values for charge density, and next smaller 
      or larger values (in order to see degeneracies). 
    <li>Next are the total energy (Ha and eV) and its components: 
      <ul>
        <li> kinetic, 
        <li>Hartree, 
        <li>exchange and correlation (xc), 
        <li>Ewald (ion-ion energy),
        <li>"<i>core correction</i>" to the local pseudopotential, 
        <li>local pseudopotential, and
        <li>nonlocal pseudopotential. 
      </ul>
      The sum of the Kohn-Sham energies (termed "band energy") is also given.
    <li>Next is the stress tensor, <br>
      (1/ucvol) d(Etot)/d(strain(a,b)) <br>
      for Etot=total energy per unit cell and <br>
      <b>a</b>,<b>b</b> are <b>x</b>, <b>y</b>, or <b>z</b> components of strain. 
      <br>
      The stress tensor is given in cartesian coordinates in Hartree/Bohr<sup>3</sup> and GPa. 
      <br>
      The basics of the stress tensor are described in O. H. Nielsen and Richard 
      M. Martin, see the <a href="bibliography.html" target="filesimg">bibliography</a> 
      file. 
  </ul>
  <p>Having finished all the calculations for the different datasets, the code 
    echoes the parameters listed in the input file, using the latest values e.g. 
    for <a href="../input_variables/varbas.html#xred" target="kwimg">xred</a>, <a href="../input_variables/varrlx.html#vel" target="kwimg">vel</a>, 
    and <a href="../input_variables/varbas.html#xcart" target="kwimg">xcart</a>, and supplement 
    them with the values obtained for the total energy, the forces and stresses, 
    as well as occupation numbers. <br>
    The latter echoes are very convenient for a quick look at the result of calculation 
    ! </p>
  <p>This is followed finally by the timing output: both "cpu" 
    time and "wall clock" time as provided by calls within the code. <br>
    The total cpu and wall clock 
    times are reported first, in seconds, minutes, and hours for convenient checking 
    at a glance. <br>
    Next are the cpu and wall times 
    for the principal time-consuming subroutine calls, each of which is independent 
    of the others. The sum of these times usually accounts for about 90% of the 
    run time.<br>
    The main subroutines, for BIG jobs, are 
  <ul>
    <li>(1) fourwf: the subroutine which performs the fast Fourier transform for 
      the wavefunctions: 
    <li> (2) fourdp: the subroutine which performs the fast Fourier transform 
      related to density and potential 
    <li>(3) rhohxc: computes the Hartree and exchange-correlation energy and potential 
      and sometimes derivative of potential; only the XC timing is reported, excluding 
      time connected to the FFTs : <code>xc:pot/=fourdp.</code> 
    <li>(4) nonlop: computes 
      <pre>< G | V<sub>non-local</sub> | C ></pre>
      the matrix elements of the nonlocal pseudopotential; 
    <li>(5) projbd: Gram-Schmidt orthogonalisation 
  </ul>
  <p>In case of small jobs, other (initialisation) routines may take a larger 
    share, and the sum of the times for the principal time-consuming subroutine 
    calls will not make 90% of the run time.. </p>
  <p></p>
  <p>If the long printing option has been selected (<a href="../input_variables/varfil.html#prtvol" target="kwimg">prtvol</a>=1), 
    the code gives much more information in the whole output file. These should 
    be rather self-explanatory, usually. Some need more explanation. <br>
    In particular the cpu and wall times for major subroutines which are NOT independent 
    of each other; for example vtorho conducts the loop over k points and calls 
    practically everything else. In case of a ground state calculation, at fixed 
    atomic positions, these subroutines are 
  <ul>
    <li> (1) <b>abinit</b>: the main routine 
    <li> (2) <b>driver</b> : select ground state or response calculations 
    <li> (3) <b>gstate</b> : the driver of the ground state calculations 
    <li> (4) <b>scfcv</b> : the SCF cycle driver 
    <li> (5) <b>vtorho</b> : compute the density from the potential (it includes 
      a loop over spins and k-points) 
    <li> (6) <b>vtowfk</b> : compute the wavefunctions at one particular k-point 
      (includes a non self consistent loop, and a loop over bands) 
    <li> (7) <b>cgwf</b> : optimize one wavefunction in a fixed potential 
    <li> (8) <b>getghc</b>: computes < G | H | C >, that is, applies the Hamiltonian 
      operator to an input vector. 
  </ul>
  <p>&nbsp;
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  <p>&nbsp;

  <b><a name="header"></a>6.4. The header</b> 
  <p>The <b>wavefunction files</b>, <b>density files</b>, and
    <b>potential files</b> all begin with the same records, called the "header". <br>
    This header is treated using a hdr_type datastructure inside ABINIT. There
    are dedicated routines inside ABINIT for initializing a header, updating
    it, reading the header of an unformatted disk file, writing a header to an 
    unformatted disk file, echoing a header to a formatted disk file, cleaning
    a header datastructure.
    <p>
    The header is made of 4+<a href="../input_variables/varbas.html#ntypat" target="kwimg">npsp</a> unformatted records,
    obtained by the following Fortran90 instructions (format 5.3):
  <pre>
 write(unit=header) codvsn,headform,fform
 write(unit=header) bantot,date,intxc,ixc,natom,ngfft(1:3),&
& nkpt,nspden,nspinor,nsppol,nsym,npsp,ntypat,occopt,pertcase,usepaw,&
& ecut,ecutdg,ecutsm,ecut_eff,qptn(1:3),rprimd(1:3,1:3),stmbias,tphysel,tsmear
 write(unit=header) istwfk(1:nkpt),nband(1:nkpt*nsppol),&
& npwarr(1:nkpt),so_psp(1:npsp),symafm(1:nsym),symrel(1:3,1:3,1:nsym),typat(1:natom),&
& kpt(1:3,1:nkpt),occ(1:bantot),tnons(1:3,1:nsym),znucltypat(1:ntypat),wtk(1:nkpt)
 do ipsp=1,npsp
! (npsp lines, 1 for each pseudopotential ; npsp=ntypat, except if alchemical pseudo-atoms)
  write(unit=unit) title,znuclpsp,zionpsp,pspso,pspdat,pspcod,pspxc,lmn_size
 enddo
!(in case of usepaw==0, final record: residm, coordinates, total energy, Fermi energy)
 write(unit=unit) residm,xred(1:3,1:natom),etotal,fermie
!(in case of usepaw==1, there are some additional records)
 if (usepaw==1)then
  write(unit=unit)(pawrhoij(iatom)%nrhoijsel(1:nspden),iatom=1,natom)
  write(unit=unit)((pawrhoij(iatom)%rhoijselect(1:nrhoijsel(ispden),ispden),ispden=1,nspden),iatom=1,natom),&
&                 ((pawrhoij(iatom)%rhoijp     (1:nrhoijsel(ispden),ispden),ispden=1,nspden),iatom=1,natom) 
 endif
</pre>
  where the type of the different variables is :
  <pre>
character*6 :: codvsn
integer :: headform,fform
integer :: bantot,date,intxc,ixc,natom,ngfft(3),nkpt,npsp,
nspden,nspinor,nsppol,nsym,ntypat,occopt,pertcase,usepaw
double precision :: acell(3),ecut,ecutdg,ecutsm,ecut_eff,qptn(3),rprimd(3,3),stmbias,tphysel,tsmear
integer :: istwfk(nkpt),nband(nkpt*nsppol),npwarr(nkpt),so_psp(npsp),&
& symafm(nsym),symrel(3,3,nsym),typat(natom),nrhoijsel(nspden),rhoijselect(*,nspden)
double precision :: kpt(3,nkpt),occ(bantot),tnons(3,nsym),znucltypat(ntypat),wtk(nkpt)
character*132 :: title
double precision :: znuclpsp,zionpsp
integer :: pspso,pspdat,pspcod,pspxc,lmax,lloc,mmax=integers
double precision :: residm,xred(3,natom),etotal,fermie,rhoij(*,nspden)
</pre>
  <p> NOTE : <i>etotal is set to its true value only for density and potential
    files. For other files, it is set to 1.0d20</i>
  <br> NOTE : <i>ecut_eff=
      <a href="../input_variables/varbas.html#ecut">ecut</a>*
      <a href="../input_variables/varrlx.html#dilatmx">dilatmx</a><sup>2</sup></i>
  <br> NOTE : <i>For all cases where
    occupation numbers are defined (that is, positive iscf, and iscf=-3), and for
    non-metallic occupation numbers, the Fermi energy is
    set to the highest occupied eigenenergy. This might not correspond to the expected Fermi energy 
    for a later non-self-consistent calculation (e.g. the band structure)</i>

<p>The header might differ for different versions of ABINIT. One pre-v5.3 format 
is described below. Note however, that the current version
of ABINIT should be able to read all the previous formats (not to write them),
with the exception of wavefunction files for which the <a href="../input_variables/varrlx.html#ecutsm">ecutsm</a> value was non-zero
(there has been a change of definition of the smearing function in v4.4). 

<p>The format for version 4.4, 4.5, 4.6, 5.0, 5.1 and 5.2 was :
  <pre>
 write(unit=header) codvsn,headform,fform
 write(unit=header) bantot,date,intxc,ixc,natom,ngfft(1:3),&
& nkpt,nspden,nspinor,nsppol,nsym,npsp,ntypat,occopt,pertcase,usepaw,&
& ecut,ecutdg,ecutsm,ecut_eff,qptn(1:3),rprimd(1:3,1:3),stmbias,tphysel,tsmear
 write(unit=header) istwfk(1:nkpt),nband(1:nkpt*nsppol),&
& npwarr(1:nkpt),so_typat(1:ntypat),symafm(1:nsym),symrel(1:3,1:3,1:nsym),typat(1:natom),&
& kpt(1:3,1:nkpt),occ(1:bantot),tnons(1:3,1:nsym),znucltypat(1:ntypat)
 do ipsp=1,npsp
! (npsp lines, 1 for each pseudopotential ; npsp=ntypat, except if alchemical pseudo-atoms)
  write(unit=unit) title,znuclpsp,zionpsp,pspso,pspdat,pspcod,pspxc,lmn_size
 enddo
!(in case of usepaw==0, final record: residm, coordinates, total energy, Fermi energy)
 write(unit=unit) residm,xred(1:3,1:natom),etotal,fermie
!(in case of usepaw==1, there are some additional records)
 if (usepaw==1)then
  write(unit=unit)(pawrhoij(iatom)%nrhoijsel(1:nspden),iatom=1,natom)
  write(unit=unit)((pawrhoij(iatom)%rhoijselect(1:nrhoijsel(ispden),ispden),ispden=1,nspden),iatom=1,natom),&
&                 ((pawrhoij(iatom)%rhoijp     (1:nrhoijsel(ispden),ispden),ispden=1,nspden),iatom=1,natom)
 endif
</pre>

  <h3>&nbsp;</h3>



  <b><a name="densoutputfile"></a>6.5. The density output file</b>
  <p>This is an unformatted data file containing the electron density on the real 
    space FFT grid. It consists of the header records followed by 
  <pre>
do ispden=1,nspden
 write(unit) (rhor(ir),ir=1,cplex*ngfft(1)*ngfft(2)*ngfft(3))
enddo
</pre>
  where <b>rhor</b> is the electron density in electrons/Bohr^3, and cplex
  is the number of complex components of the density (cplex=1 for
  GS calculations -the density is real-, and cplex=1 or 2 for RF). 
  The input variable <a href="../input_variables/vargs.html#nspden" target="kwimg">nspden</a>
  describes the number of components of the density.
  The first component (the only one present when 
  <a href="../input_variables/vargs.html#nspden" target="kwimg">nspden</a>=1) is always the total
  charge density. When 
  <a href="../input_variables/vargs.html#nspden" target="kwimg">nspden</a>=2, the second
  component is the density associated with spin-up electrons. When
  <a href="../input_variables/vargs.html#nspden" target="kwimg">nspden</a>=4, the
  second, third and fourth components correspond to the x, y and z projections
  of the local magnetization, in units of hbar/2 .
  Note that the meaning of the different components
  of the density differs for the density array (rhor) and for the
  different potential arrays (vxc ...), see section <a href=#localpotfile> 6.6 </a>.
  <p>To identify the points in real space which correspond with the index "ir" 
    above, consider the following. <br>
    The first array value (ir=1) corresponds with the first grid point which is 
    at the origin of the unit cell, (x=0, y=0, z=0). <br>
    The next grid point (ir=2) lies along the first primitive translation at the 
    next fft grid point, which is (1/<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1))*<a href="../input_variables/varbas.html#acell" target="kwimg">acell</a>(1)*<a href="../input_variables/varbas.html#rprim" target="kwimg">rprim</a>(mu,1). 
    This is 1/<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1) of the 
    way along the first primitive translation. <br>
    The rest of the values up to ir=<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1) 
    lie along this vector, at (ir-1)/<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1) 
    of the way along the first primitive translation. The point at ir=<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1)+1 
    lies at 1/<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(2) along the 
    second primitive translation. <br>
    The next points up to ir=<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1)+<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1) 
    are displaced in the direction of the second primitive translation by 1/<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(2) 
    and in the first translation by (ir-<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1)-1)/<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1). 
    <br>
    This pattern continues until ir=<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1)*<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(2). 
    <br>
    The next point after that is displaced along the third primitive translation 
    by 1/ngfft(3), and so forth until ir varies all the way from 1 to <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1)*<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(2)*<a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(3). 
    This last point is in the corner diagonally opposite from the origin, or right 
    alongside the origin if the whole grid is viewed as being periodically repeated. 
  <p>&nbsp;</p>


  <b> <a name="localpotfile"></a>6.6. The potential files  </b>
  <p>Also unformatted files consisting of the header records and 
  <pre>
do ispden=1,nspden
 write(unit) (potential(ir),ir=1,cplex*ngfft(1)*ngfft(2)*ngfft(3))
enddo
</pre>
  <p>where <b>potential</b> can be either
    the sum of the Hartree potential, exchange-correlation 
    and local pseudopotential (see <a href="../input_variables/varfil.html#prtpot" target="kwimg">prtpot</a>), 
    the Hartree potential (see <a href="../input_variables/varfil.html#prtvha" target="kwimg">prtvha</a>),
    the Hartree+XC potential (see <a href="../input_variables/varfil.html#prtvhxc" target="kwimg">prtvhxc</a>),
    or
    the XC potential (see <a href="../input_variables/varfil.html#prtvxc" target="kwimg">prtvxc</a>),
    These are defined
    on the real space grid in Hartree energy units. 
    The underlying grid is as described above. 
    If <a href="../input_variables/vargs.html#nspden" target="kwimg">nspden</a>=2, the
    different components are the spin-up potential and the
    spin-down potential. In the case 
    <a href="../input_variables/vargs.html#nspden" target="kwimg">nspden</a>=4,
    the components correspond to the up-up potential, the down-down potential,
    the real part of the up-down potential, and the imaginary part of the up-down potential.
    Note that the Hartree potential is NOT spin-dependent, but in order
    to use the same format as for the other potential files, the
    spin-independent array is written twice,
    once for spin-up and one for spin-down.</p>
  <p>&nbsp; </p>


  <p>&nbsp;
  <p><b><a name="wavefctfile"></a>6.7. The wavefunction output file  </b>
  <p>This is an unformatted data file containing the planewaves coefficients of
    all the wavefunctions, and different supplementary data. 
  <p>The <b>ground-state</b> wf file consists
    of the header records,
    and data written with the following lines of FORTRAN (version 4.0 and more recent versions):
  <pre>
       bantot=0                                    <-- counts over all bands
       do isppol=1,nsppol
        do ikpt=1,nkpt
         write(unit) npw,nspinor,nband                    <-- for each k point
         write(unit) kg(1:3,1:npw)                        <-- plane wave reduced coordinates
         write(unit) eigen(1+bantot:nband+bantot),        <-- eigenvalues for this k point
                     occ(1+bantot:nband+bantot)           <-- occupation numbers for this k point
         do iband=1,nband
          write(unit) (cg(ii+index),ii=1,2*npw*nspinor)   <-- wavefunction coefficients
         enddo                                            for a single band and k point
         bantot=bantot+nband
        enddo
       enddo
</pre>
  <p> If the job ended without problem, and if one is not using <b>newsp</b>,
    a few supplementary lines are added, in order to give the history of atomic positions
    and corresponding forces. The integer nxfh gives the number of pairs (x,f)
    of positions and forces in reduced coordinates :
  <pre>
 write(unit)nxfh
 do ixfh=1,nxfh
  write(unit) xred(1:3,1:natom,ixfh),dummy(1:3,1:4),&
&             fred(1:3,1:natom,ixfh),dummy(1:3,1:4)
 enddo
</pre>
  The dummy variables might contain, in the future, the description of the unit
  cell, and the stresses.
  The type of the different variables is :
  <pre>
integer :: kg,nband,npw,nspinor,nxfh
double precision :: cg,dummy,eigen,fred,occ,xred
</pre>


  <p>The <b>response-function</b> wf file consists
    of the header records,
    and data written with the following lines of FORTRAN (version 4.0 and more recent versions):
<pre>
 bantot=0                                    <-- counts over all bands
 do isppol=1,nsppol
  do ikpt=1,nkpt
   write(unit) npw,nspinor,nband                    <-- for each k point
   write(unit) kg(1:3,1:npw)                        <-- plane wave reduced coordinates
   do iband=1,nband
    write(unit) (eigen(jband+(iband-1)*nband+bantot),jband=1,2*nband)  <-- column of eigenvalue matrix
    write(unit) (cg(ii+index),ii=1,2*npw*nspinor)     <-- wavefunction coefficients
   enddo                                            for a single band and k point
   bantot=bantot+nband
  enddo
 enddo
</pre>

<p> In version previous to 4.0 , npw and nspinor were combined :
<pre>
write(unit) npw*nspinor,nband
</pre>
while the planewave coordinate record was not present (in both GS and RF cases).

<p> Note that there is an alternative format (_KSS) for the output
of the wavefunction coefficients, activated by a non-zero
value of <a href="../input_variables/vargw.html#nbandkss" target="kwimg">nbandkss</a>. 

  <p>&nbsp;
  <p><b><a name="other_output"></a>6.8. Other output files.</b>

  <p>There are many other output files, optionally written, all formatted files at present.
  Their use is usually governed by a specific input variable. Please consult the
  description of this input variable, in order to have more information on such files :
  <ul>
    <li><a href="../input_variables/varfil.html#prtcml">prtcml</a> to print a CML file with geometry information</li>
    <li><a href="../input_variables/varfil.html#prtdos">prtdos</a> to print a file with the electronic Density-Of-States</li>
    <li><a href="../input_variables/varfil.html#prteig">prteig</a> to print a file with the list of k points and eigenenergies</li>
    <li><a href="../input_variables/varfil.html#prtgeo">prtgeo</a> to print a file with a geometrical analysis (bond lengths and bond angles), that also contains an XMOL section</li>
    <li><a href="../input_variables/varfil.html#prt1dm">prt1dm</a> to print a one-dimensional projection of potential and density, for the three axes.</li>
  </ul>



  <p>&nbsp;
  <h3>&nbsp;</h3>
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>
  <p>&nbsp;



  <hr>
  <h3>&nbsp;</h3>

  <h3><a name="7"></a>7. Numerical quality of the calculations</h3>
  <p>The following section describes various parameters which affect convergence 
    and the numerical quality of calculations. 
  <p>The list of these input parameters is 
  <ul>
    <li><a href="abinis_help.html#ref11_1">(1)</a> <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a> 
    <li><a href="abinis_help.html#ref11_2">(2)</a> <a href="../input_variables/varbas.html#toldfe" target="kwimg">toldfe</a>, 
      <a href="../input_variables/varbas.html#toldff" target="kwimg">toldff</a>, <a href="../input_variables/varbas.html#tolwfr" target="kwimg">tolwfr</a>, 
      and <a href="../input_variables/varbas.html#tolvrs" target="kwimg">tolvrs</a>, as well as 
      <a href="../input_variables/varbas.html#nstep" target="kwimg">nstep</a> 
    <li><a href="abinis_help.html#ref11_3">(3)</a> <a href="../input_variables/varbas.html#nkpt" target="kwimg">nkpt</a> 
    <li><a href="abinis_help.html#ref11_4">(4)</a> <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a> 
    <li><a href="abinis_help.html#ref11_5">(5)</a> <a href="../input_variables/varrlx.html#tolmxf" target="kwimg">tolmxf</a>, 
      as well as <a href="../input_variables/varrlx.html#amu" target="kwimg">amu</a>, <a href="../input_variables/varrlx.html#dtion" target="kwimg">dtion</a>, 
      <a href="../input_variables/varrlx.html#vis" target="kwimg">vis</a>, <a href="../input_variables/varrlx.html#ntime" target="kwimg">ntime</a> 
    <li><a href="abinis_help.html#ref11_6">(6)</a> <a href="../input_variables/varbas.html#acell" target="kwimg">acell</a> 
      and <a href="../input_variables/varbas.html#rprim" target="kwimg">rprim</a> 
  </ul>
  <br>
  The technical design of the pseudopotential also affects the quality of the 
  results. 


  <p><a name="ref11_1"></a>(1) The first issue regarding convergence is the number 
    of planewaves in the basis for a given set of atoms. Some atoms (notably those 
    in the first row or first transition series row) have relatively deep pseudopotentials 
    which require many planewaves for convergence. In contrast are atoms like 
    Si for which fewer planewaves are needed. A typical value of "<a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a>" 
    for silicon might be 5-10 Hartree for quite good convergence, while the value 
    for oxygen might be 25-35 Hartree or more depending on the convergence desired 
    and the design of the pseudo- potential. 
  <p>NOTE: It is necessary in every new problem to <b>TEST</b> the convergence 
    by <b>RAISING</b> <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a> for 
    a given calculation until the results being computed are constant to within 
    some tolerance. This is up to the user and is very important. For a given 
    <a href="../input_variables/varbas.html#acell" target="kwimg">acell</a> and <a href="../input_variables/varbas.html#rprim" target="kwimg">rprim</a>, 
    <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a> is the parameter which 
    controls the number of planewaves. Of course if <a href="../input_variables/varbas.html#rprim" target="kwimg">rprim</a> 
    or <a href="../input_variables/varbas.html#acell" target="kwimg">acell</a> is varied then the 
    number of planewaves will also change. 
  <p>Let us reiterate that extremely careful pseudopotential design can optimize 
    the convergence of <i>e.g.</i> the total energy within some range of planewave 
    number or <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a>. It is appropriate 
    to attempt to optimize this convergence, especially for difficult atoms like 
    oxygen or copper, as long as one does not significantly compromise the quality 
    or transferability of the pseudopotential. There are many people working on 
    new techniques for optimizing convergence. 
  <p>For information on extended norm conservation, see <cite>E. L. Shirley, D. 
    C. Allan, R. M. Martin, and J. D. Joannopoulos, Phys. Rev. B 40, 3652 (1989)</cite>. 
  <p>For information on optimizing the convergence of pseudopotentials, see <cite>A. 
    M. Rappe, K. M. Rabe, E. Kaxiras, and J. D. Joannopoulos, Phys. Rev. B 41, 
    1227 (1990)</cite>. 


  <p><a name="ref11_2"></a>(2) In addition to achieving convergence in the number 
    of planewaves in the basis, one must ensure that the SCF iterations which 
    solve the electronic structure for a given set of atomic coordinates are also 
    converged. This convergence is controlled by the parameters <a href="../input_variables/varbas.html#toldfe" target="kwimg">toldfe</a>, 
    <a href="../input_variables/varbas.html#toldff" target="kwimg">toldff</a>, <a href="../input_variables/varbas.html#tolwfr" target="kwimg">tolwfr</a>, 
    and <a href="../input_variables/varbas.html#tolvrs" target="kwimg">tolvrs</a>, as well as the 
    parameter <a href="../input_variables/varbas.html#nstep" target="kwimg">nstep</a>. One of the 
    "tolerance" parameters must be chosen, and, when the required level of tolerance 
    is fulfilled, the SCF cycles will stop. The <a href="../input_variables/varbas.html#nstep" target="kwimg">nstep</a> 
    variable also controls convergence in preconditioned conjugate gradient iterations 
    by forcing the calculation to stop whenever the number of such iterations 
    exceeds nstep. Usually one wants nstep to be set larger than needed to reach 
    a given tolerance, or else one wants to restart insufficiently converged calculations 
    until the required tolerance is reached. 
  <p>Note that, if the gap in the system closes (e.g. due to defect formation 
    or if the system is metallic in the first place), the presently coded algorithm 
    will be slower to converge than for insulating materials. Convergence trouble 
    during iterations usually signals closure of the gap. The code will suggest 
    to treat at least one unoccupied state (or band) in order to be able to monitor 
    such a closure. 


  <p><a name="ref11_3"></a>(3) For self consistent calculations (<a href="../input_variables/varbas.html#iscf" target="kwimg">iscf</a> 
    positive) it is important to test the adequacy of the k point integration. 
    If symmetry is used then one usually tests a set of "special point" grids. 
    Otherwise one tests the addition of more and more k points, presumably on 
    uniform grids, to ensure that a sufficient number has been included for good 
    k point integration. The parameter nkpt indicates how many k points are being 
    used, and their coordinates are given by kpt and kptnrm, described above. 
    The weight given to each k point is provided by input variable <a href="../input_variables/varbas.html#wtk" target="kwimg">wtk</a>. 
    Systematic tests of k point integration are much more difficult than tests 
    of the adequacy of the number of planewaves. The difficulty I refer to is 
    simply the lack of a very systematic method for generating k point grids for 
    tests. 
  <p><a name="ref11_4"></a>(4) It is possible to run calculations for which the 
    fft box is not quite large enough to avoid aliasing error in fft convolutions. 
    An aliasing error, or a Fourier filter approximation, is occurring when the 
    output variable "<b>boxcut</b>" is less than 2. boxcut is the smallest ratio 
    of the fft box side to the planewave basis sphere diameter. If this ratio 
    is 2 or larger then e.g. the calculation of the Hartree potential from the 
    charge density is done without approximation. <br>
    NOTE : the values of <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a>(1:3) 
    are chosen automatically by the code to give boxcut > 2, if <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a> 
    has not been set by hand. At ratios smaller than 2, certain of the highest 
    Fourier components are corrupted in the convolution. If the basis is nearly 
    complete, this Fourier filter can be an excellent approximation. In this case 
    values of boxcut can be as small as about 1.5 without incurring significant 
    error. For a given <a href="../input_variables/varbas.html#ecut" target="kwimg">ecut</a>, <a href="../input_variables/varbas.html#acell" target="kwimg">acell</a>, 
    and <a href="../input_variables/varbas.html#rprim" target="kwimg">rprim</a>, one should run 
    tests for which <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a> is large 
    enough to give boxcut >= 2, and then one may try smaller values of <a href="../input_variables/vargs.html#ngfft" target="kwimg">ngfft</a> 
    if the results are not significantly altered. See the descriptions of these 
    variables above. 
  <p><a name="ref11_5"></a>(5) If you are running calculations to relax or equilibrate 
    structures, i.e. with <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=1 
    and possibly <a href="../input_variables/varrlx.html#vis" target="kwimg">vis</a>>0, then the 
    quality of your molecular dynamics or relaxation will be affected by the parameters 
    <a href="../input_variables/varrlx.html#amu" target="kwimg">amu</a>, <a href="../input_variables/varrlx.html#dtion" target="kwimg">dtion</a>, 
    <a href="../input_variables/varrlx.html#vis" target="kwimg">vis</a>, <a href="../input_variables/varrlx.html#ntime" target="kwimg">ntime</a>, 
    <a href="../input_variables/varrlx.html#tolmxf" target="kwimg">tolmxf</a>. Clearly if you want 
    a relaxed structure you must either run long enough or make repeated runs 
    until the largest force in the problem (output as fmax) is smaller than what 
    you will tolerate (see <a href="../input_variables/varrlx.html#tolmxf" target="kwimg">tolmxf</a>). 
    <br>
    If <a href="../input_variables/varrlx.html#dtion" target="kwimg">dtion</a> is too large for 
    the given values of masses (<a href="../input_variables/varrlx.html#amu" target="kwimg">amu</a>) 
    and viscosity (<a href="../input_variables/varrlx.html#vis" target="kwimg">vis</a>) then the 
    molecular dynamics will be unstable. If <a href="../input_variables/varrlx.html#dtion" target="kwimg">dtion</a> 
    is too small, then the molecular dynamics will move inefficiently slowly. 
    A consensus exists in the community that forces larger than about 0.1 eV/Angstrom 
    are really too large to consider the relaxation to be converged. It is best 
    for the user to get experience with this in his/her own application. <br>
    The option <a href="../input_variables/varrlx.html#ionmov" target="kwimg">ionmov</a>=2, 3 or 
    7 are also available This uses the Broyden (BFGS) scheme for structural optimization 
    and is much more efficient than viscous damping for structural relaxation. 
  <p><a name="ref11_6"></a>(6) If you are running supercell calculations (i.e. 
    an isolated atom or molecule in a big box, or a defect in a solid, or a slab 
    calculation) you must check the convergence of your calculation with respect 
    to the supercell and system size. 
  <ul>
    <li>For an isolated molecule in a big box : increase concurrently the three 
      dimensions of your supercell (<a href="../input_variables/varbas.html#acell" target="kwimg">acell</a>), 
      and check the convergence of your physical property. 
    <li>For a defect in a solid : your supercell must be a multiple of the primitive 
      cell of the bulk solid, so you have less freedom. Still, be sure that your 
      supercell is large enough for your properties of interest to be accurate 
      at the level you want it to be. 
    <li>For a slab calculation : you must increase the vacuum in the cell, but 
      also the thickness of your slab systematically... 
  </ul>
  <p> <i>If you follow the tutorial, you should go back to the tutorial window now. </i>

  <p>&nbsp;</p><hr>

<h3><b><a name="8"></a>8. Final remarks</b></h3>
<p>The ABINIT package is developped by the ABINIT group. The status of this package 
  and the ABINIT group are explained in the file ~abinit/doc/users/context.txt and ~abinit/doc/developers/planning.txt , 
  or some recent version of them. 

<HR ALIGN=left>
Goto :
<A href="http://www.abinit.org"><B>ABINIT home Page</B></A>
<B> | </B>
<A href="acknowledgments.html"><B>Suggested acknowledgments</B></A>
<B> | </B>
<A href="../input_variables/keyhr.html"><B>List of input variables</B></A>
<B> | </B>
<A "href="../tutorial/welcome.html"><B>Tutorial home page</B></A>
<B> | </B>
<A href="bibliography.html"><B>Bibliography</B></A>
<HR ALIGN=left>
Help files :
<A href="new_user_guide.html"><B>New user's guide</B></A>
<B> | </B>
<A href="abinis_help.html"><B>Abinis (main)</B></A>
<B> | </B>
<A href="respfn_help.html"><B>Abinis (respfn)</B></A>
<B> | </B>
<A href="mrgddb_help.html"><B>Mrgddb</B></A>
<B> | </B>
<A href="anaddb_help.html"><B>Anaddb</B></A>
<B> | </B>
<A href="aim_help.html"><B>AIM (Bader)</B></A>
<B> | </B>
<A href="cut3d_help.html"><B>Cut3D</B></A>
<B> | </B>
<A href="optic_help.html"><B>Optic</B></A>
<B> | </B>
<A href="mrgscr_help.html"><B>Mrgscr</B></A>
<HR ALIGN=left>

</body>
</html>

