!{\src2tex{textfont=tt}}
!!****f* ABINIT/complete_gkk
!!
!! NAME
!! complete_gkk
!!
!! FUNCTION
!! Use the set of special q points calculated by the Monkhorst &
!! Pack Technique.
!! Check if all the informations for the q points are present in
!! the DDB to determine the elphon interaction matrices
!! Generate the gkk matrices of the set of q points which
!! samples homogeneously the entire Brillouin zone.
!!
!! COPYRIGHT
!! Copyright (C) 2004-2008 ABINIT group (MVer)
!! This file is distributed under the terms of the
!! GNU General Public Licence, see ~abinit/COPYING
!! or http://www.gnu.org/copyleft/gpl.txt .
!! For the initials of contributors, see ~abinit/doc/developers/contributors.txt .
!!
!! INPUTS
!! acell(3) = length scales by which rprim are to be multiplied
!! elph_ds = datastructure for elphon information (mainly
!!      matrix elements and dimensions)
!! FSfulltofull = FSkpt index mapping under symops
!! FSkpt = kpoints close enough to the fermi surface
!! gkk_flag = flag for existence of matrix element
!! gprimd(3,3)=dimensionful primitive translations in reciprocal space
!! indsym = map of atoms by inverses of symrels
!! mpert =maximum number of ipert
!! natom=number of atoms in unit cell
!! nqptirred=number of (supposedly) irreducible q points found in the
!!       GKK file
!! nsym=number of space group symmetries
!! qptirred = coordinates of distinct qpoints found in the GKK file
!! qpttoqpt = qpoint index mapping under symops
!! rprimd(3,3)=dimensionful primitive translations in real space
!! spqpt(3,nqpt)=set of special q points generated by the Monkhorst
!!  & Pack Method
!! symrec(3,3,nsym)=3x3 matrices of the group symmetries (recip space)
!! symrel(3,3,nsym)=3x3 matrices of the group symmetries (real space)
!! tnons(3,nsym)=nonsymmorphic translations associated to symrel
!! ucvol=unit cell volume in (whatever length scale units)**3
!! xred(3,natom)=relative coords of atoms in unit cell (dimensionless)
!!
!! OUTPUT
!! elph_ds%gkk_qpt = gkk matrices for all qpts on a full mesh
!!
!! TODO
!!
!! PARENTS
!!      get_all_gkq
!!
!! CHILDREN
!!
!! SOURCE

#if defined HAVE_CONFIG_H
#include "config.h"
#endif

subroutine complete_gkk(acell,elph_ds,FSfulltofull,FSkpt,gkk_flag,&
&   gprimd,indsym,mpert,natom,nqptirred,nsym,qptirred,qpttoqpt,rprimd,&
&   spqpt,symrec,symrel,tnons,ucvol,xred)

 use defs_basis
 use defs_elphon

 implicit none

!Arguments ------------------------------------
!scalars
 integer,intent(in) :: mpert,natom,nqptirred,nsym
 real(dp),intent(in) :: ucvol
 type(elph_type),intent(inout) :: elph_ds
!arrays
 integer,intent(in) :: FSfulltofull(2,nsym,elph_ds%nFSkpt),indsym(4,nsym,natom)
 integer,intent(in) :: qpttoqpt(2,nsym,elph_ds%nqpt),symrec(3,3,nsym)
 integer,intent(in) :: symrel(3,3,nsym)
 integer,intent(inout) :: gkk_flag(elph_ds%nbranch,elph_ds%nbranch,elph_ds%nFSkpt,elph_ds%nsppol,elph_ds%nqpt)
 real(dp),intent(in) :: FSkpt(3,elph_ds%nFSkpt),acell(3),gprimd(3,3)
 real(dp),intent(in) :: qptirred(3,nqptirred),rprimd(3,3),spqpt(3,elph_ds%nqpt)
 real(dp),intent(in) :: tnons(3,nsym),xred(3,natom)

!Local variables-------------------------------
  !integer :: nsym,itim
  !integer, allocatable :: symrel(:,:,:)
  !integer, allocatable :: symrec(:,:,:),qpttoqpt(:,:,:)
  !integer, allocatable :: FSfulltofull(:,:,:)
  !tol sets tolerance for equality of q points between those of
  !the DDB and those of the sampling grid
!scalars
 integer :: i1,i2,iFSkpt,ia,ib,ib1,ib2,iblok,ibranch,idir,ieqqpt,ii,iiqq,ikpt1
 integer :: ikpt2,ipert1,ipert2,ipertcase,iqpt,iqptirred,isppol,isym,isymq1
 integer :: itim,itimq1,jFSkpt,jbranch,jdir,jj,kbranch,kdir,kk,ll,mu,nblok
 integer :: neqqpt,new,q1,q2,symiFSkpt,symipert
 real(dp),parameter :: tol=2.d-8
 real(dp) :: arg1,arg2,im,re,res,sumi,sumr,timsign,tolherm
 character(len=500) :: message
!arrays
 integer :: symmetrized_qpt(elph_ds%nqpt)
 integer,allocatable :: qtest(:,:)
 real(dp) :: kpt(3),qq(3),qsym(6),redkpt(3),ss(3,3),ssinv(3,3)
 real(dp) :: tmp_mat(2,elph_ds%nbranch,elph_ds%nbranch)
 real(dp) :: tmp_mat2(2,elph_ds%nbranch,elph_ds%nbranch)
 real(dp),allocatable :: gkk_qpt_new(:,:,:,:,:),gkk_qpt_tmp(:,:,:,:,:)

! *********************************************************************

!Check if the blkqpt points and their symmetrics are sufficient
!in the DDB to retrieve all the q points of the B.Z. sampling

!Generation of the gkk matrices relative to the q points
!of the set which samples the entire Brillouin zone

 symmetrized_qpt(:) = -1

 isppol=1

 allocate (gkk_qpt_new(2,elph_ds%ngkkband*elph_ds%ngkkband,elph_ds%nbranch*elph_ds%nbranch,elph_ds%nFSkpt,elph_ds%nsppol))
 allocate (gkk_qpt_tmp(2,elph_ds%ngkkband*elph_ds%ngkkband,elph_ds%nbranch*elph_ds%nbranch,elph_ds%nFSkpt,elph_ds%nsppol))

 do iqpt=1,elph_ds%nqpt

! Already symmetrized?
  if (symmetrized_qpt(iqpt) == 1) cycle

  gkk_qpt_new(:,:,:,:,:) = zero

! loop over qpoints equivalent to iqpt
  neqqpt=0
! do not use time reversal symmetry to complete the qpoints:
! do not know what happens to the gamma matrices
  itim=1

! do itim=1,2
  do isym=1,nsym
!  ieqqpt is sent onto iqpt by itim/isym
   ieqqpt = qpttoqpt(itim,isym,iqpt)


   if (gkk_flag(1,1,1,1,ieqqpt) == -1) cycle
!  if we have information on this qpt

!  DEBUG
!  write (*,*) 'complete_gkk : qpt ', iqpt, ' found equiv to ', &
!  & ieqqpt, spqpt(:,iqpt), ' by ', isym
!  ENDDEBUG

!  iqpt is equivalent to ieqqpt: get it from file or memory
   if (elph_ds%gkqwrite == 0) then
    gkk_qpt_tmp(:,:,:,:,:) = elph_ds%gkk_qpt(:,:,:,:,:,ieqqpt)
   else
    read(elph_ds%unitgkq,REC=ieqqpt) gkk_qpt_tmp
   end if

!  DEBUG
!  this outputs a sum over all bands and kpts with weights multiplied in before
!  do ibranch =1,elph_ds%nbranch
!  do jbranch =1,elph_ds%nbranch
!  tmp_mat(1,jbranch,ibranch) = sum(gkk_qpt_tmp(1,:,(jbranch-1)*elph_ds%nbranch+ibranch,:))
!  tmp_mat(2,jbranch,ibranch) = sum(gkk_qpt_tmp(2,:,(jbranch-1)*elph_ds%nbranch+ibranch,:))
!  end do
!  end do
!  write (*,*) 'sum(gkk_qpt_tmp) = '
!  write (*,'(3(2E16.6,1x)))') tmp_mat
!  ENDDEBUG

   neqqpt=neqqpt+1

   if (elph_ds%doscalprod==1) then
    do ii=1,3
     do jj=1,3
      ss(ii,jj)=0.0_dp
      do kk=1,3
       do ll=1,3
        ss(ii,jj)=ss(ii,jj)+rprimd(ii,kk)*symrel(kk,ll,isym)*gprimd(ll,jj)
       end do
      end do
     end do
    end do
   else
    do ii=1,3
     do jj=1,3
      ss(ii,jj) = symrel(jj,ii,isym)
     end do
    end do
   end if

!  do ii=1,3
!  do jj=1,3
!  ssinv(ii,jj)=0.0_dp
!  do kk=1,3
!  do ll=1,3
!  ssinv(ii,jj)=ssinv(ii,jj)+gprimd(ii,kk)*rprimd(jj,ll)*symrec(ll,kk,isym)
!  end do
!  end do
!  end do
!  end do
!  DEBUG
!  write(06,*) 'complete_gkk : ss'
!  write(06,*)ss(1,1), ss(1,2), ss(1,3)
!  write(06,*)ss(2,1), ss(2,2), ss(2,3)
!  write(06,*)ss(3,1), ss(3,2), ss(3,3)
!  ENDDEBUG

   do isppol=1,elph_ds%nsppol
    do iFSkpt=1,elph_ds%nFSkpt
!    symiFSkpt is sent onto iFSkpt by itim/isym
     symiFSkpt=FSfulltofull(itim,isym,iFSkpt)

!    Do each element band1, band2 separately...
     do ib1=1,elph_ds%ngkkband*elph_ds%ngkkband

!     multiply by the ss matrices
      tmp_mat2(:,:,:) = zero
      do ibranch =1,elph_ds%nbranch
       idir = mod(ibranch-1,3)+1
       do jbranch =1,elph_ds%nbranch
        do kbranch=1,elph_ds%nbranch
         kdir = mod(kbranch-1,3)+1
         tmp_mat2(:,ibranch,jbranch) = tmp_mat2(:,ibranch,jbranch) + &
&         ss(idir,kdir)*&
&         gkk_qpt_tmp(:,ib1,(kbranch-1)*elph_ds%nbranch+jbranch,iFSkpt,isppol)
        end do
       end do
      end do
!     Transposed ssym matrix for other side
      tmp_mat(:,:,:) = zero
      do ibranch =1,elph_ds%nbranch
       do jbranch =1,elph_ds%nbranch
        jdir = mod(jbranch-1,3)+1
        do kbranch=1,elph_ds%nbranch
         kdir = mod(kbranch-1,3)+1
         tmp_mat(:,ibranch,jbranch) = tmp_mat(:,ibranch,jbranch)+ &
&         tmp_mat2(:,ibranch,kbranch)*ss(jdir,kdir)
!        &      tmp_mat2(:,ibranch,kbranch)*ssinv(kdir,jdir)
        end do
       end do
      end do

!     add to gkk_qpt_new
      do ibranch =1,elph_ds%nbranch
       do jbranch =1,elph_ds%nbranch
        gkk_qpt_new(:,ib1,(jbranch-1)*elph_ds%nbranch+ibranch,symiFSkpt,isppol) = &
&        gkk_qpt_new(:,ib1,(jbranch-1)*elph_ds%nbranch+ibranch,symiFSkpt,isppol) + &
&        tmp_mat(:,jbranch,ibranch)
       end do
      end do

!     DEBUG
!     if (iqpt == 11 .and. iFSkpt < 100) then
!     write (*,*) 'accumulate another tmp_mat = '
!     write (*,'(3(2E16.6)))') tmp_mat
!     write (*,*) 'from gkk_qpt_tmp = '
!     write (*,'(3(2E16.6)))') gkk_qpt_tmp(:,ib1,:,iFSkpt,isppol)
!     end if
!     ENDDEBUG
     end do ! end ib1 do
    end do ! end iFSkpt do
   end do ! end isppol do

!  DEBUG
!  if (iqpt == 11) then
!  do iFSkpt=1,100
!  write (*,*) ' gkk_qpt_new(band1,band1) now = '
!  write (*,'(3(2E16.6)))') gkk_qpt_new (:,1,1,:,:,iFSkpt)
!  end do
!  end if
!  ENDDEBUG
  end do
! end isym do
! end do
! ! end itim do


! divide by number of equivalent qpts found
  gkk_qpt_new(:,:,:,:,:) = gkk_qpt_new(:,:,:,:,:)/neqqpt

! DEBUG
! write (*,*) 'complete_gkk : neqqpt = ',  neqqpt
! do ibranch =1,elph_ds%nbranch
! do jbranch =1,elph_ds%nbranch
! tmp_mat(1,jbranch,ibranch) = sum(gkk_qpt_new(1,:,(jbranch-1)*elph_ds%nbranch+ibranch,:,:))
! tmp_mat(2,jbranch,ibranch) = sum(gkk_qpt_new(2,:,(jbranch-1)*elph_ds%nbranch+ibranch,:,:))
! end do
! end do
! ENDDEBUG

! copy the symmetrized version into all the equivalent qpoints, appropriately transformed
! See above
  itim=1
! do itim=1,2
  do isym=1,nsym
!  ieqqpt is sent onto iqpt by itim/isym
   ieqqpt = qpttoqpt(itim,isym,iqpt)

   if (symmetrized_qpt(ieqqpt) /= -1) cycle
   gkk_qpt_tmp(:,:,:,:,:) = zero

!  use symrec matrices to get inverse transform from isym^{-1}
   if (elph_ds%doscalprod==1) then
    do ii=1,3
     do jj=1,3
      ss(ii,jj)=0.0_dp
      do kk=1,3
       do ll=1,3
!       Use inverse of symop matrix here to get back to ieqqpt (inv+transpose is in symrec and in gprimd)
        ss(ii,jj)=ss(ii,jj)+rprimd(ii,kk)*symrec(ll,kk,isym)*gprimd(jj,ll)
       end do
      end do
     end do
    end do
   else
    do ii=1,3
     do jj=1,3
      ss(ii,jj) = symrec(ii,jj,isym)
     end do
    end do
   end if
!  do ii=1,3
!  do jj=1,3
!  ssinv(ii,jj)=0.0_dp
!  do kk=1,3
!  do ll=1,3
!  ! Use inverse of symop matrix here to get back to ieqqpt
!  ssinv(ii,jj)=ssinv(ii,jj)+gprimd(ii,kk)*rprimd(jj,ll)*symrel(kk,ll,isym)
!  end do
!  end do
!  end do
!  end do
!  DEBUG
!  write(06,*) 'complete_gkk : ssinv'
!  write(06,*)ss(1,1), ss(1,2), ss(1,3)
!  write(06,*)ss(2,1), ss(2,2), ss(2,3)
!  write(06,*)ss(3,1), ss(3,2), ss(3,3)
!  ENDDEBUG

   do isppol=1,elph_ds%nsppol
    do iFSkpt=1,elph_ds%nFSkpt
!    symiFSkpt is sent onto iFSkpt by itim/isym
     symiFSkpt=FSfulltofull(itim,isym,iFSkpt)

     do ib1=1,elph_ds%ngkkband*elph_ds%ngkkband

!     multiply by the ss^{-1} matrices
      tmp_mat2(:,:,:) = zero
      do ibranch =1,elph_ds%nbranch
       idir = mod(ibranch-1,3)+1
       do jbranch =1,elph_ds%nbranch
        do kbranch=1,elph_ds%nbranch
         kdir = mod(kbranch-1,3)+1
         tmp_mat2(:,ibranch,jbranch) = tmp_mat2(:,ibranch,jbranch) + &
&         ss(idir,kdir)*gkk_qpt_new(:,ib1,(kbranch-1)*elph_ds%nbranch+jbranch,iFSkpt,isppol)
        end do
       end do
      end do
!     Transposed ss matrix for other side
      tmp_mat(:,:,:) = zero
      do ibranch =1,elph_ds%nbranch
       do jbranch =1,elph_ds%nbranch
        jdir = mod(jbranch-1,3)+1
        do kbranch=1,elph_ds%nbranch
         kdir = mod(kbranch-1,3)+1
         tmp_mat(:,ibranch,jbranch) = tmp_mat(:,ibranch,jbranch)+ &
&         tmp_mat2(:,ibranch,kbranch)*ss(jdir,kdir)
!        &      tmp_mat2(:,ibranch,kbranch)*ssinv(kdir,jdir)
        end do
       end do
      end do

      do ibranch =1,elph_ds%nbranch
       do jbranch =1,elph_ds%nbranch
        gkk_qpt_tmp(:,ib1,(jbranch-1)*elph_ds%nbranch+ibranch,symiFSkpt,isppol) = tmp_mat(:,jbranch,ibranch)
       end do
      end do

      if (gkk_flag (1,1,symiFSkpt,isppol,ieqqpt) == -1) then
       gkk_flag (:,:,symiFSkpt,isppol,ieqqpt) = 0
      end if

     end do
!    end ib1 do
    end do ! end iFSkpt do
   end do ! end isppol do

!  DEBUG
!  !if (neqqpt == 3) then
!  write (*,*) ' getting ', ieqqpt, ' from ', iqpt, ' via symop ', isym, ' = '
!  write (*,*) 'symrel =  ', symrel(:,:,isym)
!  write (*,*) 'symrec =  ', symrec(:,:,isym)
!  do ibranch =1,elph_ds%nbranch
!  do jbranch =1,elph_ds%nbranch
!  tmp_mat(1,jbranch,ibranch) = sum(gkk_qpt_tmp(1,:,:,jbranch,ibranch,:,:))
!  tmp_mat(2,jbranch,ibranch) = sum(gkk_qpt_tmp(2,:,:,jbranch,ibranch,:,:))
!  end do
!  end do
!  !end if
!  ENDDEBUG


!  save symmetrized matrices for qpt ieqqpt
   if (elph_ds%gkqwrite == 0) then
    elph_ds%gkk_qpt(:,:,:,:,:,ieqqpt) = gkk_qpt_tmp(:,:,:,:,:)
   else
    write (elph_ds%unitgkq,REC=ieqqpt) gkk_qpt_tmp
   end if

   symmetrized_qpt(ieqqpt) = 1
  end do
! end do
! ! end itim do

 end do
!end iqpt do



!DEBUG
!! see if all the gkk_flag are 1
!do iqpt=1,elph_ds%nqpt
!do isppol=1,elph_ds%nsppol
!do iFSkpt=1,elph_ds%nFSkpt
!do ipertcase=1,elph_ds%nbranch
!do jpertcase=1,elph_ds%nbranch
!if (gkk_flag(jpertcase,ipertcase,iFSkpt,isppol,iqpt) == -1) then
!write (*,*) 'complete_gkk error: pertcase ',jpertcase,ipertcase,&
!&       ' for FSkpt,qpt ', iFSkpt,iqpt, ' not found '
!stop
!end if
!!write (*,'(i3,x,4(2(E10.4,x),x))') gkk_flag(jpertcase,ipertcase,iFSkpt,isppol,iqpt), &
!!     &               gkk_qpt_new(:,1,:,iFSkpt,isppol)
!end do
!end do
!end do
!end do
!end do
!ENDDEBUG


end subroutine complete_gkk
!!***
