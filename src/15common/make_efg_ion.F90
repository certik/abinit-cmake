!{\src2tex{textfont=tt}}
!!****f* ABINIT/make_efg_ion
!! NAME
!! make_efg_ion
!!
!! FUNCTION
!! compute the electric field gradient due to ionic cores
!!
!! COPYRIGHT
!! Copyright (C) 2005-2008 ABINIT group (JJ)
!! This file is distributed under the terms of the
!! GNU General Public License, see ~ABINIT/Infos/copyright
!! or http://www.gnu.org/copyleft/gpl.txt .
!!
!! INPUTS
!! gcart(ngfft(1),ngfft(2),ngfft(3),3), the G vectors on the grid in cartesian space
!! natom, number of atoms in the unit cell
!! ngfft(18), the details of the grid and fft
!! ntypat, the number of types of atoms in the unit cell
!! rprimd(3,3), the matrix giving the transformation from crystal to cartesian coordinates
!! typat(natom), the type of each atom in the unit cell
!! ucvol, the volume of the unit cell in atomic units
!! xred(3,natom) the location of each atom in the cell in crystallographic coordinates
!! zion(ntypat) the net charge on each type of atom 
!!
!! OUTPUT
!! efg(3,3,natom), the 3x3 efg tensors at each atomic site
!!
!! SIDE EFFECTS
!!
!!
!! NOTES
!! This routine computes the electric field gradient, specifically the components
!! $\partial^2 V/\partial x_\alpha \partial x_\beta$ of the potential generated by the ionic cores, 
!! at each atomic site in the unit cell. 
!! Key references: 
!! Profeta, Mauri, and Pickard, ``Accurate first principles prediction of $^{17}$O NMR parameters in
!! SiO$_2$: Assignment of the zeolite ferrierite spectrum'', J. Am. Chem. Soc. 125, 541--548 (2003); 
!! A. Honma, ``Dipolar lattice-sums with applications to the exciton bands of anthracene crystal and 
!! the crystal field due to point charges'', J. Phys. Soc. Jpn. 42, 1129--1135 (1977);
!! and Kresse and Joubert, ``From ultrasoft pseudopotentials to the projector augmented wave method'', Phys. Rev. B. 59, 
!! 1758--1775 (1999). In Kresse and Joubert's notation, the ionic cores are $n_{Zc}$; these charges are given by the net
!! core charges on the pseudoatoms. Due to otherwise slow convergence, the sum over atoms is carried out by an Ewald
!! method as detailed in the Honma reference, specifically his Eq. 4.8.
!!
!! PARENTS
!!      calc_efg
!!
!! CHILDREN
!!
!! SOURCE

#if defined HAVE_CONFIG_H
#include "config.h"
#endif

subroutine make_efg_ion(efg,gcart,natom,ngfft,ntypat,rprimd,typat,ucvol,xred,zion)

 use defs_basis
 use defs_datatypes


!This section has been created automatically by the script Abilint (TD). Do not modify the following lines by hand.
 use interfaces_11util
 use interfaces_12geometry
!End of the abilint section

 implicit none

!Arguments ------------------------------------
!scalars
 integer,intent(in) :: natom,ntypat
 real(dp) :: ucvol
!arrays
 integer,intent(in) :: ngfft(18),typat(natom)
 real(dp),intent(in) :: gcart(ngfft(1),ngfft(2),ngfft(3),3),rprimd(3,3)
 real(dp),intent(in) :: zion(ntypat)
 real(dp),intent(inout) :: xred(3,natom)
 real(dp),intent(out) :: efg(3,3,natom)

!Local variables-------------------------------
!scalars
 integer :: cellparam,iatom,igfft1,igfft2,igfft3,ii,jatom,jj,sx,sy,sz
 real(dp) :: conv_r_check,cph,damp,dampfac,derfc_karg,derivs,gminmax,karg
 real(dp) :: lenrho,lenrho3,phase,qk,rlkcut,sph,trace,xi0
!arrays
 real(dp) :: gmax(3),gvec(3),rhok(3),rhored(3),rpl(3)
 real(dp),allocatable :: efg_g(:,:,:,:),efg_r(:,:,:),efg_r_old(:,:,:)
 real(dp),allocatable :: xcart(:,:)
!no_abirules
!

! ************************************************************************

!DEBUG
!write(*,*)' make_efg_ion : enter'
!ENDDEBUG

 allocate(efg_g(2,3,3,natom),efg_r(3,3,natom),efg_r_old(3,3,natom),xcart(3,natom))
 call xredxcart(natom,1,rprimd,xcart,xred) ! get atomic locations in cartesian coords

 damp = 1.0D-12 ! xi0 will be chosen to guarantee convergence in both G and r space to this accuracy

 efg(:,:,:) = zero ! final efg tensor
 efg_g(:,:,:,:) = zero ! part of tensor accumulated in G space
 efg_r(:,:,:) = zero ! part of tensor accumulated in R space
 efg_r_old(:,:,:) = zero ! part of tensor accumulated in R space

 do ii = 1, 3 ! generate the lengths of the unit cell edges in atomic units
  rpl(ii) = sqrt(rprimd(1,ii)**2+rprimd(2,ii)**2+rprimd(3,ii)**2)
 end do
 xi0 = sqrt(pi/(maxval(rpl)*minval(rpl))) ! this estimate for xi0 is from Honma's paper
 rlkcut = sqrt(-LOG(damp))/xi0 ! this estimate for the r-cutoff follows from the fact that the
!damping in real space looks like exp(-xi0^2*r^2) for large r
 
!here starts the G space sum
 do igfft1 = 1, ngfft(1) ! summing over reciprocal space components in all three dimensions...
  do igfft2 = 1, ngfft(2)
   do igfft3 = 1, ngfft(3)
    gvec(:) = gcart(igfft1,igfft2,igfft3,:) ! the current G vector in Cartesian coords
    trace = dot_product(gvec,gvec)
    if (trace > 0.00) then
     dampfac = exp( -trace/(4.0*xi0*xi0)) ! the Gaussian damping in G space
     do iatom = 1, natom ! summing over the atoms in the unit cell
      do jatom = 1, natom ! summing over other atoms in the unit cell
       qk = zion(typat(jatom)) ! the charge on each atom
       rhok(:) = xcart(:,jatom) - xcart(:,iatom) ! the vector from the current target atom iatom to
!      the neighbor atom jatom
       phase = two_pi*dot_product(rhok,gvec)
       cph = cos(phase)
       sph = sin(phase)
       do ii = 1, 3 ! loop over tensor components
        do jj = 1, 3 ! loop over tensor components
         derivs = -3.0*gvec(ii)*gvec(jj)/trace
         if (ii == jj) derivs = 1.0 + derivs
         efg_g(1,ii,jj,iatom) = efg_g(1,ii,jj,iatom) + qk*cph*derivs*dampfac ! real tensor element in G space, 
!        weighted by charge and damping
         efg_g(2,ii,jj,iatom) = efg_g(2,ii,jj,iatom) - qk*sph*derivs*dampfac ! imaginary tensor element in G space
        end do ! end loop over jj in v_ij
       end do ! end loop over ii in v_ij
      end do ! end loop over jatom = 1, natom
     end do ! end loop over iatom = 1, natom
    end if ! end  if statement excluding G = 0.0
   end do ! end loop over ngfft(3)
  end do ! end loop over ngfft(2)
 end do ! end loop over ngfft(1)

!here starts the sum in real space

 cellparam = 2
 do ! the logic here is to implement a "do-while" loop in fortran, at each step computing the r-space
! contribution to the efg tensor over one more shell of unit cells and checking for convergence
  cellparam = cellparam + 1
  rlkcut = cellparam*minval(rpl) ! the cutoff is conservatively estimated from the shortest of the unit cell edges
  efg_r_old(:,:,:) = efg_r(:,:,:) ! save the current efg_r values as efg_r_old
  efg_r(:,:,:) = zero ! get ready to accumalate the new estimate of efg_r

  do iatom = 1, natom ! loop over atoms in unit cell
   do sx = -cellparam, cellparam ! loop over all cells in each dimension out to rlkcut 
    do sy = -cellparam, cellparam
     do sz = -cellparam, cellparam
      do jatom = 1, natom ! loop over atoms in all cells
       if (.NOT. (jatom == iatom .AND. sx == 0 .AND. sy == 0 .AND. sz == 0)) then ! avoid self term
        qk = zion(typat(jatom)) ! charge on each neighbor atom
        rhored(1) = xred(1,jatom) + sx - xred(1,iatom) ! rhored is the vector in crystal coords from neighbor to target
        rhored(2) = xred(2,jatom) + sy - xred(2,iatom)
        rhored(3) = xred(3,jatom) + sz - xred(3,iatom)
        rhok(1) = rprimd(1,1)*rhored(1)+rprimd(1,2)*rhored(2)+rprimd(1,3)*rhored(3) ! rhok is rhored in cartesian coords
        rhok(2) = rprimd(2,1)*rhored(1)+rprimd(2,2)*rhored(2)+rprimd(2,3)*rhored(3)
        rhok(3) = rprimd(3,1)*rhored(1)+rprimd(3,2)*rhored(2)+rprimd(3,3)*rhored(3)
        trace = dot_product(rhok,rhok)
        lenrho = sqrt(trace)
        if (lenrho < rlkcut) then ! this restriction is critical as it ensures that we sum over a sphere of atoms in real space
!        no matter what shape the unit cell has
         karg = xi0*lenrho
         call derfc(derfc_karg,karg)
!        see Honma eq. 2.10 for derivation of the following damping factor
         dampfac = (1.0+3.0/(2.0*karg*karg))*exp(-karg*karg)+3.0*sqrt(pi)*derfc_karg/(4.0*karg**3) 
         do ii = 1, 3 ! loop over tensor elements
          do jj = 1, 3 ! loop over tensor elements
           derivs = -3.0*rhok(ii)*rhok(jj)/trace
           if(ii == jj) derivs = derivs + 1.0
!          real space tensor element, weighted by charge of neighbor and Ewald damping factor
           efg_r(ii,jj,iatom) = efg_r(ii,jj,iatom) + qk*derivs*dampfac 
          end do ! end loop over jj in efg(ii,jj,iatom)
         end do ! end loop over ii in efg(ii,jj,iatom)
        end if ! end if statement restricting to a sphere of radius rlkcut
       end if ! end if statement avoiding the self atom term
      end do ! end loop over jatoms in cell
     end do ! end loop over sz cells
    end do ! end loop over sy cells
   end do ! end loop over sx cells
  end do ! end loop over i atoms in cell
  conv_r_check = 0.0 ! get read to accumulate all the changes due to the large number of cells
  do iatom = 1, natom
   do ii = 1, 3
    do jj = 1, 3
     conv_r_check = conv_r_check + abs(efg_r(ii,jj,iatom)-efg_r_old(ii,jj,iatom))
    end do
   end do
  end do
  if (conv_r_check < damp) exit ! condition to leave "do-while" loop
 end do ! end of "do-while" loop checking convergence

!finally, combine G space and R space results with appropriate weighting coefficients (Honma Eq. 4.8)
 do ii = 1, 3
  do jj = 1, 3
   do iatom = 1, natom
    efg(ii,jj,iatom) = (two_pi/(3.0*ucvol))*efg_g(1,ii,jj,iatom) - (2.0*xi0**3/(3.0*sqrt(pi)))*efg_r(ii,jj,iatom)
    if (abs(efg_g(2,ii,jj,iatom)) > damp) then
     write(6,*) 'Warning ! G-space part of EFG failed to converge. Increase ecut and re-run!'
    end if
   end do
  end do
 end do

 deallocate(efg_g,efg_r,xcart)

!DEBUG
!write(6,*)' make_efg_ion : exit '
!stop
!ENDDEBUG

 end subroutine make_efg_ion
!!***
