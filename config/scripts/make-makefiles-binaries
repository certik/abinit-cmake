#!/usr/bin/env python
#
# Copyright (c) 2005-2008 ABINIT Group (Yann Pouillon)
# All rights reserved.
#
# This file is part of the ABINIT software package. For license information,
# please see the COPYING file in the top-level directory of the ABINIT source
# distribution.
#

from time import gmtime,strftime

import commands
import os
import re
import sys

# ---------------------------------------------------------------------------- #

#
# Subroutines
#

# Makefile header
def makefile_header(name,stamp):

 return """#
# Makefile for ABINIT                                      -*- Automake -*-
# Generated by %s on %s

#
# IMPORTANT NOTE
#
# Any manual change to this file will systematically be overwritten.
# Please modify the %s script or its config file instead.
#

AM_CPPFLAGS = @CPPFLAGS_OPT@
AM_FCFLAGS  = @FCFLAGS_FREEFORM@ @fcflags_opt_main@

abiexecdir = @abinit_bindir@

""" % (name,stamp,name)



# ---------------------------------------------------------------------------- #

#
# Main program
#

# Initial setup
my_name    = "make-makefiles-binaries"
my_configs = [
  "config/specs/corelibs.cf",
  "config/specs/prereqs.cf",
  "config/specs/plugins.cf",
  "config/specs/binaries.cf"]
my_output  = "src/main/Makefile.am"

# Check if we are in the top of the ABINIT source tree
if ( not os.path.exists("configure.ac") or
     not os.path.exists("src/main/abinit.F90") ):
 print "%s: You must be in the top of an ABINIT source tree." % my_name
 print "%s: Aborting now." % my_name
 sys.exit(1)

# Read config file(s)
for cnf in my_configs:
 if ( os.path.exists(cnf) ):
  execfile(cnf)
 else:
  print "%s: Could not find config file (%s)." % (my_name,cnf)
  print "%s: Aborting now." % my_name
  sys.exit(2)

# What time is it?
now = strftime("%Y/%m/%d %H:%M:%S +0000",gmtime())

# Generate library and include lists
lib_list = ""
inc_list = ""

# Core libraries
for lib in abinit_corelibs:
 if ( lib in corelibs_specs ):
  lib_specs = corelibs_specs[lib]
 else:
  lib_specs = ABI_LIB_NIL

 # Add sequential and parallel libraries
 if ( (lib_specs & ABI_LIB_MPI) == 0 ):
  lib_list += "LIB_%s = $(top_builddir)/src/%s/lib%s.a\n" % \
   (lib.upper(),lib,lib)
 else:
  lib_list += "LIB_%sS = $(top_builddir)/src/%s/lib%ss.a\n" % \
   (lib.upper(),lib,lib)
  lib_list += "LIB_%sP = $(top_builddir)/src/%s/lib%sp.a\n" % \
   (lib.upper(),lib,lib)

# External prerequisites
lib_list += "LIB_FFT_EXT = @lib_fft_libs@\n"
for lib in abinit_prereqs:
 if ( lib in prereqs_specs ):
  lib_specs = prereqs_specs[lib][1]
  if ( lib_specs == None ):
   lib_specs = ABI_LIB_NIL
  else:
   lib_specs = ABI_LIB_INC
 else:
  lib_specs = ABI_LIB_NIL

 # Add libraries
 lib_list += "LIB_%s = @lib_%s_libs@\n" % (lib.upper(),lib)

# Plug-ins
for lib in abinit_plugins:
 lib_specs = ABI_LIB_NIL
 try:
  tmp_hdrs = eval("%s_hdrs" % (lib))
  lib_specs = ABI_LIB_INC
 except NameError:
  tmp_hdrs = None
 try:
  tmp_mods = eval("%s_mods" % (lib))
  lib_specs = ABI_LIB_INC
 except NameError:
  tmp_mods = None

 # Add libraries
 lib_list += "LIB_%s = @lib_%s_libs@\n" % (lib.upper(),lib)

lib_list += "\n"

# Generate binary list
bin_list = "abiexec_PROGRAMS ="
mpi_list = "if DO_BUILD_PARALLEL\n abiexec_PROGRAMS +="
add_list = ""
cln_list = "CLEANFILES ="

for bin in main_bins:

 # Init
 if ( bin in main_bins_specs ):
  specs = main_bins_specs[bin]
 else:
  specs = ABI_BIN_NIL

 # Regular binaries
 if ( (specs & ABI_BIN_ADD) == 0 ):
  cln_list += " \\\n\t%s_cpp.f90" % (bin)
  if ( not os.path.exists("src/main/%s.F90" % (bin)) ):
   sys.stderr.write("Error: No such file or directory: 'src/main/%s.F90'\n" % \
    (bin))
   sys.exit(4)

 # Sequential/parallel binaries
 if ( ((specs & ABI_BIN_MPI) == 0) and ((specs & ABI_BIN_ADD) == 0) ):
  bin_list += " \\\n\t%s" % (bin)
 else:
  if ( (specs & ABI_BIN_MPI) != 0 ):
   bin_list += " \\\n\t%s" % re.sub(".$","s",bin)
   mpi_list += " \\\n\t%s" % re.sub(".$","p",bin)
  if ( (specs & ABI_BIN_ADD) != 0 ):
   add_specs = main_bins_add_specs[bin]
   if ( add_specs[2] == "" ):
    bin_list += " \\\n\t%s" % (bin)
   else:
    add_list += "if %s\n abiexec_PROGRAMS += %s\nendif\n" % (add_specs[2],bin)

cln_list += "\n"
bin_list += "\n\n"
mpi_list += "\nendif\n\n"
if ( add_list != "" ):
 add_list += "\n"

# Start generating makefile content
makefile = makefile_header(my_name,now)

#makefile += "INCLUDES = %s\n\n" % (inc_list)
makefile += "# Internal libraries\n"+lib_list
makefile += "# Binary list\n"+bin_list+mpi_list+add_list

# Process each binary
for abibin in main_bins:

 # Init
 if ( abibin in main_bins_specs ):
  specs = main_bins_specs[abibin]
 else:
  specs = ABI_BIN_NIL

 if ( (specs & ABI_BIN_MPI) == 0 ):
  bins = [abibin]
 else:
  bins = [re.sub(".$","s",abibin),re.sub(".$","p",abibin)]

 if ( (specs & ABI_BIN_ADD) == 0 ):
  abisrc = abibin
  abicpp = ""
  abicnd = ""
 else:
  (abisrc,abicpp,abicnd) = main_bins_add_specs[abibin]

 # Produce all binaries related to one source file
 for bin in bins:

  # Init
  bin_cppflags = ""
  bin_libs = ""
  bin_ldflags = ""

  # Check all libraries the binary depends on
  for lib in eval("%s_deps" % (abibin)):

   # Init
   if ( lib in corelibs_specs ):
    lib_specs = corelibs_specs[lib]
   else:
    lib_specs = ABI_LIB_NIL

   # Set suffix for library
   if ( (lib_specs & ABI_LIB_MPI) == 0 ):
    lib_suffix = ""
   else:
    if ( (specs & ABI_BIN_MPI) == 0 ):
     lib_suffix = "s"
    else:
     if ( bin == bins[0] ):
      lib_suffix = "s"
     else:
      lib_suffix = "p"

   bin_libs += " \\\n\t$(LIB_%s%s)" % (lib.upper(),lib_suffix.upper())

   # Add includes in binary CPPFLAGS
   if ( (lib_specs & ABI_LIB_INC) != 0 ):
    bin_cppflags += " @src_%s_includes@" % (lib)

   if ( lib in abinit_prereqs ):
    if ( lib in prereqs_specs ):
     if ( prereqs_specs[lib][1] != None ):
      bin_cppflags += " @lib_%s_includes@" % (lib)

   if ( lib in abinit_plugins ):
    try:
     tmp_hdrs = eval("%s_hdrs" % (lib))
    except NameError:
     tmp_hdrs = None
    try:
     tmp_mods = eval("%s_mods" % (lib))
    except NameError:
     tmp_mods = None

    if ( (tmp_hdrs != None) or (tmp_mods != None) ):
     bin_cppflags += " @lib_%s_includes@" % (lib)

  # Check whether we are considering a parallel binary
  if ( ((specs & ABI_BIN_MPI) != 0) and (bin == bins[1]) ):
   bin_cppflags  = " @MPI_CPPFLAGS@ %s" % (bin_cppflags)
   bin_ldflags  += " \\\n\t$(MPI_FC_LDFLAGS)"
   bin_libs     += " \\\n\t$(MPI_FC_LIBS)"

  # Check whether the binary may use external FFT libraries
  if ( (specs & ABI_BIN_FFT) != 0 ):
   bin_cppflags += " @lib_fft_includes@"
   bin_libs += " \\\n\t$(LIB_FFT_EXT)"

  # Finish setting build-time parameters
  if ( abicpp != "" ):
   bin_cppflags = " %s %s" % (abicpp,bin_cppflags)
  if ( bin_cppflags != "" ):
   bin_cppflags = "@CPPFLAGS@ %s" % (bin_cppflags)
  bin_cppflags = re.sub(r"[ ]+"," ",bin_cppflags.strip())
  bin_cppflags = re.sub(" "," \\\n\t",bin_cppflags)
  bin_ldflags += " \\\n\t$(FC_LDFLAGS)"
  bin_libs += " \\\n\t$(FC_LIBS)\n"

  # Write results
  indent = ""
  makefile += "# %s.F90 ---> %s\n" % (abisrc,bin)

  # Parallel version
  if ( ((specs & ABI_BIN_MPI) != 0) and (bin == bins[1]) ):
   makefile += "if DO_BUILD_PARALLEL\n"
   indent = " "

  # Additional binary
  if ( abicnd != "" ):
   makefile += "if %s\n" % (abicnd)
   indent = " "

  # Binary sources
  makefile += "%s%s_SOURCES = %s.F90\n" % (indent,bin,abisrc)

  # Additional binary flags
  if ( bin_cppflags != "" ):
   makefile += "%s%s_CPPFLAGS = \\\n\t%s\n" % (indent,bin,bin_cppflags)
  if ( ((specs & ABI_BIN_MPI) != 0) and (bin == bins[1]) ):
   makefile += "%s%s_FCFLAGS = @FCFLAGS_FREEFORM@ @MPI_FCFLAGS@\n" % \
    (indent,bin)

  # LDFLAGS and additional libraries
  makefile += "%s%s_LDADD =%s%s" % (indent,bin,bin_ldflags,bin_libs)

  # Close conditionals
  if ( (((specs & ABI_BIN_MPI) != 0) and (bin == bins[1])) or (abicnd != "") ):
   makefile += "endif\n\n"
  else:
   makefile += "\n"

# Write list of files to clean
makefile += cln_list

# Init list of extra files
ext       = "EXTRA_DIST ="
ext_print = 0

# Include additional hand-made information
add = "src/main/abinit.amf"
if ( os.path.exists(add) ):
 ext += " \\\n\tabinit.amf"
 ext_print = 1

# Include RoboDOC header
hdr = "src/main/_main_"
if ( os.path.exists(hdr) ):
 ext += " \\\n\t_main_"
 ext_print = 1

# Finish list of extra files
ext += "\n"

# Write list of extra files
if ( ext_print == 1 ):
 makefile += "\n"+ext+"\n"

# Write additional hand-made information
if ( os.path.exists(add) ):
 makefile += "\n"+file(add,"r").read()

mf = file(my_output,"w")
mf.write(makefile)
mf.close()

#
# Binaries for nigthly builds
#

# Init makefile content
makefile = makefile_header(my_name,now)
makefile += "bin_PROGRAMS = timeout\n\ntimeout_SOURCES = timeout.c\n\n"

# Init list of extra files
ext       = "EXTRA_DIST ="
ext_print = 0

# Include additional hand-made information
add = "src/nightly/abinit.amf"
if ( os.path.exists(add) ):
 ext += " \\\n\tabinit.amf"
 ext_print = 1

# Include RoboDOC header
hdr = "src/nightly/_main_"
if ( os.path.exists(hdr) ):
 ext += " \\\n\t_main_"
 ext_print = 1

# Finish list of extra files
ext += "\n"

# Write list of extra files
if ( ext_print == 1 ):
 makefile += "\n"+ext+"\n"

# Write additional hand-made information
if ( os.path.exists(add) ):
 makefile += "\n"+file(add,"r").read()

# Finish
mf = file("src/nightly/Makefile.am","w")
mf.write(makefile)
mf.close()
